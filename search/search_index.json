{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoderDojo Twin Cities Micropython This GitHub repository is for sharing teaching resources to teach Micropython to students in 5th to 12th grades (10-18 years old). The course assumes that either a mentor, teacher or students have access to at least one microcontroller such as the $4 Raspberry Pi Pico or the $6 ESP32. Students should also have access to some low-cost sensors (buttons, potentiometers, ultrasonic distance sensor) and displays such as LEDs or OLED. Course Outline Introduction - Overview of Micropython and why we love it. Boards - Description of popular development boards that support Micropython (Pico and ESP32). How to choose the right microcontroller for your project. Raspberry Pi Pico - Details the Raspberry Pi Pico including features and pinouts. Thonny IDE - Thonny is an IDE that supports Micropython. We review the parts of the User interface. Blink - Blink an LED on and off. This is the equivalent of the \"Hello World!\" program in micropython. Button - see how a button can control the LED. Servo - Move a Servo. Glossary of Micropython Terms Contact Micropython References - links to other useful sites.","title":"Micropython Home"},{"location":"#coderdojo-twin-cities-micropython","text":"This GitHub repository is for sharing teaching resources to teach Micropython to students in 5th to 12th grades (10-18 years old). The course assumes that either a mentor, teacher or students have access to at least one microcontroller such as the $4 Raspberry Pi Pico or the $6 ESP32. Students should also have access to some low-cost sensors (buttons, potentiometers, ultrasonic distance sensor) and displays such as LEDs or OLED.","title":"CoderDojo Twin Cities Micropython"},{"location":"#course-outline","text":"Introduction - Overview of Micropython and why we love it. Boards - Description of popular development boards that support Micropython (Pico and ESP32). How to choose the right microcontroller for your project. Raspberry Pi Pico - Details the Raspberry Pi Pico including features and pinouts. Thonny IDE - Thonny is an IDE that supports Micropython. We review the parts of the User interface. Blink - Blink an LED on and off. This is the equivalent of the \"Hello World!\" program in micropython. Button - see how a button can control the LED. Servo - Move a Servo. Glossary of Micropython Terms Contact Micropython References - links to other useful sites.","title":"Course Outline"},{"location":"01-intro/","text":"Introduction to MicroPython Welcome to the CoderDojo course on MicroPython. This course is about MicroPython , a variation of the popular Python programming language that is used to program microcontrollers . Intended Audience Our target audience is students age 10-16 that are in Junior High or High School that have basic keyboarding skills. For example, students will need to be able to select, copy and paste text from the examples into their own code. This course is appropriate for students that already have a basic understanding of the Python programming language. We strongly suggest you take the Introduction to Python Programming CoderDojo Course if you are not familiar with Python. What is Micropython Why we love it Virtual emulators Hardware Costs Connections License of Content Our intent is to allow teachers and mentors around the world to integrate MicroPython into their courses without any fees. We want you to be able to use this content freely with a few conditions: you give us attribution and you don't resell our content for profit. Note that we use the same Creative Commons licensing as the Raspberry Pi Foundation and the CoderDojo Foundation: Creative Commons Attribution NonCommercial ShareAlike This means you are free to reuse and remix this content for non-commercial educational purposes as long as you keep the attribution. You may also use the content on this site to train your own language models as long as those language models are not sold for commercial profit.","title":"Introduction"},{"location":"01-intro/#introduction-to-micropython","text":"Welcome to the CoderDojo course on MicroPython. This course is about MicroPython , a variation of the popular Python programming language that is used to program microcontrollers .","title":"Introduction to MicroPython"},{"location":"01-intro/#intended-audience","text":"Our target audience is students age 10-16 that are in Junior High or High School that have basic keyboarding skills. For example, students will need to be able to select, copy and paste text from the examples into their own code. This course is appropriate for students that already have a basic understanding of the Python programming language. We strongly suggest you take the Introduction to Python Programming CoderDojo Course if you are not familiar with Python. What is Micropython Why we love it Virtual emulators Hardware Costs Connections","title":"Intended Audience"},{"location":"01-intro/#license-of-content","text":"Our intent is to allow teachers and mentors around the world to integrate MicroPython into their courses without any fees. We want you to be able to use this content freely with a few conditions: you give us attribution and you don't resell our content for profit. Note that we use the same Creative Commons licensing as the Raspberry Pi Foundation and the CoderDojo Foundation: Creative Commons Attribution NonCommercial ShareAlike This means you are free to reuse and remix this content for non-commercial educational purposes as long as you keep the attribution. You may also use the content on this site to train your own language models as long as those language models are not sold for commercial profit.","title":"License of Content"},{"location":"01a-microcontrollers/","text":"Microcontrollers This lesson is an overview of microcontrollers and their role in teaching [physical computing(https://en.wikipedia.org/wiki/Physical_computing). A microcontrollers is a small low-cost computer used to control physical devices such as LED, servos and motors. Microcontroller boards typically cost around $4 to $6 and are an ideal way to learn about computer science because you can use them to build fun projects. For example you can control a row of LEDs, move a robot and sense the world around us with a variety of light, sound and motion sensors. In the past, microcontrollers were difficult for younger students to program. They were also too expensive for every student to purchase and take home. A typical Arduino kit could easily cost over $20 and required you to learn C to program it. Today, microcontrollsers such as the Raspberry Pi Pico and the ESP32 cost as little as two dollars. And these devices are designed to be programmed in Python, the most popular programming language for students. What is Physical Computing? Physical Computing is a field of study that can sense and respond to the world around us. Unlike programming a cell phone or a laptop computer, our focus is reading sensor values and quickly responding to changes. Physical Computing is widely used to teach principals of computer science because students can create their own projects and express creativity such a controlling the patterns of lights or creating complex sounds. How Microcontrollsers are Used Microcontrollers do three things: They read sensor values of the world around them They transform this data into useful representations They send outputs to devices that control the world such as LEDs and motors as well as displays Here is a general diagram to think about when you are designing microcontroller systems: Here is a specific example instance of what inputs and outputs might do. Programming a Microcontroller In this class, we will use the MicroPython to program our Microcontrollers. Our programs will usually have the following structure: Imports: Specify the right Python libraries Setup: Setup initial data structures Main loop: Continuously monitor inputs and take actions The following is a small example of this code in Micropython: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Import Section import machine import time # Setup Section led = machine . Pin ( 16 , machine . Pin . OUT ) # Main Loop while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) Almost all our programs will start with the import machine line. This tells the system that we need to gather all the libraries that understand our physical machine.","title":"Microcontrollers"},{"location":"01a-microcontrollers/#microcontrollers","text":"This lesson is an overview of microcontrollers and their role in teaching [physical computing(https://en.wikipedia.org/wiki/Physical_computing). A microcontrollers is a small low-cost computer used to control physical devices such as LED, servos and motors. Microcontroller boards typically cost around $4 to $6 and are an ideal way to learn about computer science because you can use them to build fun projects. For example you can control a row of LEDs, move a robot and sense the world around us with a variety of light, sound and motion sensors. In the past, microcontrollers were difficult for younger students to program. They were also too expensive for every student to purchase and take home. A typical Arduino kit could easily cost over $20 and required you to learn C to program it. Today, microcontrollsers such as the Raspberry Pi Pico and the ESP32 cost as little as two dollars. And these devices are designed to be programmed in Python, the most popular programming language for students.","title":"Microcontrollers"},{"location":"01a-microcontrollers/#what-is-physical-computing","text":"Physical Computing is a field of study that can sense and respond to the world around us. Unlike programming a cell phone or a laptop computer, our focus is reading sensor values and quickly responding to changes. Physical Computing is widely used to teach principals of computer science because students can create their own projects and express creativity such a controlling the patterns of lights or creating complex sounds.","title":"What is Physical Computing?"},{"location":"01a-microcontrollers/#how-microcontrollsers-are-used","text":"Microcontrollers do three things: They read sensor values of the world around them They transform this data into useful representations They send outputs to devices that control the world such as LEDs and motors as well as displays Here is a general diagram to think about when you are designing microcontroller systems: Here is a specific example instance of what inputs and outputs might do.","title":"How Microcontrollsers are Used"},{"location":"01a-microcontrollers/#programming-a-microcontroller","text":"In this class, we will use the MicroPython to program our Microcontrollers. Our programs will usually have the following structure: Imports: Specify the right Python libraries Setup: Setup initial data structures Main loop: Continuously monitor inputs and take actions The following is a small example of this code in Micropython: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Import Section import machine import time # Setup Section led = machine . Pin ( 16 , machine . Pin . OUT ) # Main Loop while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) Almost all our programs will start with the import machine line. This tells the system that we need to gather all the libraries that understand our physical machine.","title":"Programming a Microcontroller"},{"location":"01b-libraries/","text":"Micropython Libraries When you start up your IDE, it may have a list of python modules built in. You can list the current modules you have installed by running the help('modules') command. 1 help ( 'modules' ) MicroPython Builtin Functions MicroPython is designed to run quickly in a small memory system. So it has trimmed down many of the standard Python libraries to fit the needs of microcontrollers. Most of these libraries start with the letter \"u\" so that you are aware they are designed to run on microcontrollers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cmath \u2013 mathematical functions for complex numbers gc \u2013 control the garbage collector math \u2013 mathematical functions uarray \u2013 arrays of numeric data uasyncio \u2014 asynchronous I/O scheduler ubinascii \u2013 binary/ASCII conversions ucollections \u2013 collection and container types uerrno \u2013 system error codes uhashlib \u2013 hashing algorithms uheapq \u2013 heap queue algorithm uio \u2013 input/output streams ujson \u2013 JSON encoding and decoding uos \u2013 basic \u201coperating system\u201d services ure \u2013 simple regular expressions uselect \u2013 wait for events on a set of streams usocket \u2013 socket module ussl \u2013 SSL/TLS module ustruct \u2013 pack and unpack primitive data types usys \u2013 system specific functions utime \u2013 time related functions uzlib \u2013 zlib decompression _thread \u2013 multithreading support MicroPython Specific Libraries 1 2 3 4 5 6 7 8 btree \u2013 simple BTree database framebuf \u2014 frame buffer manipulation machine \u2014 functions related to the hardware micropython \u2013 access and control MicroPython internals network \u2014 network configuration ubluetooth \u2014 low-level Bluetooth ucryptolib \u2013 cryptographic ciphers uctypes \u2013 access binary data in a structured way Adding a module When you are using python and you attempt to use a module that python can't find you will get an error. You must then use the python pip installer tool to add the new library. Getting MicroPython Libraries from PyPi Filter Only MicroPython Libraries Full List of modules 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 Please wait a moment while I gather a list of all available modules... ESP-test audioop filecmp random __future__ base64 fileinput re _abc bcrypt fnmatch readline _ast bdb formatter reedsolo _asyncio binascii fractions reprlib _bisect binhex ftplib resource _blake2 bisect functools rlcompleter _bootlocale bitstring gc runpy _bz2 blink-builtin-led genericpath sched _cffi_backend brain_argparse getopt secrets _codecs brain_attrs getpass select _codecs_cn brain_builtin_inference gettext selectors _codecs_hk brain_collections glob send2trash _codecs_iso2022 brain_crypt grp serial _codecs_jp brain_curses gzip setuptools _codecs_kr brain_dataclasses hashlib sh1106 _codecs_tw brain_dateutil heapq sh1106-test _collections brain_fstrings hmac shelve _collections_abc brain_functools html shlex _compat_pickle brain_gi http shutil _compression brain_hashlib i2c-display signal _contextvars brain_http i2c-scanner site _crypt brain_io i2c_lcd six _csv brain_mechanize i2clcd smtpd _ctypes brain_multiprocessing imaplib smtplib _ctypes_test brain_namedtuple_enum imghdr sndhdr _curses brain_nose imp socket _curses_panel brain_numpy_core_fromnumeric importlib socketserver _datetime brain_numpy_core_function_base inspect spi-debug _dbm brain_numpy_core_multiarray io sqlite3 _decimal brain_numpy_core_numeric ipaddress sre_compile _dummy_thread brain_numpy_core_numerictypes isort sre_constants _elementtree brain_numpy_core_umath itertools sre_parse _functools brain_numpy_ndarray jedi ssl _hashlib brain_numpy_random_mtrand json stat _heapq brain_numpy_utils keyword statistics _imp brain_pkg_resources lazy_object_proxy string _io brain_pytest led-strip stringprep _json brain_qt lib2to3 struct _locale brain_random linecache subprocess _lsprof brain_re list-modules sunau _lzma brain_six locale symbol _markupbase brain_ssl logging symtable _md5 brain_subprocess lzma sys _multibytecodec brain_threading macpath sysconfig _multiprocessing brain_typing mailbox syslog _opcode brain_uuid mailcap tabnanny _operator builtins marshal tarfile _osx_support bz2 math telnetlib _pickle cProfile mccabe tempfile _posixsubprocess calendar mimetypes termios _py_abc certifi mmap test _pydecimal cffi modulefinder textwrap _pyio cgi multiprocessing this _queue cgitb mypy thonny _random chunk mypy_extensions threading _scproxy clonevirtualenv mypyc time _sha1 cmath nacl timeit _sha256 cmd netrc tkinter _sha3 code nis token _sha512 codecs nntplib tokenize _signal codeop ntpath toml _sitebuiltins collections nturl2path trace _socket colorsys numbers traceback _sqlite3 compileall opcode tracemalloc _sre concurrent operator tty _ssl configparser optparse turtle _stat contextlib os turtledemo _string contextvars paramiko typed_ast _strptime copy parser types _struct copyreg parso typing _symtable crypt pathlib typing_extensions _sysconfigdata_m_darwin_darwin cryptography pdb unicodedata _testbuffer csv pickle unittest _testcapi ctypes pickletools urllib _testimportmultiple curses pip uu _testmultiphase dataclasses pipenv uuid _thread datetime pipes venv _threading_local dbm pkg_resources virtualenv _tkinter decimal pkgutil virtualenv_support _tracemalloc difflib platform warnings _uuid dir-example plistlib wave _warnings dis poplib weakref _weakref distutils posix webbrowser _weakrefset doctest posixpath websockets _xxtestfuzz docutils pprint wheel abc dummy_threading profile wrapt aifc easy_install pstats wsgiref antigravity ecdsa pty xdrlib argparse email ptyprocess xml array encodings pwd xmlrpc array-test ensurepip py_compile xxlimited ast enum pyclbr xxsubtype astroid errno pycparser zipapp asttokens espefuse pydoc zipfile asynchat espressif pydoc_data zipimport asyncio espsecure pyexpat zlib asyncore esptool pylint at faulthandler queue atexit fcntl quopri Enter any module name to get more help. Or, type \"modules spam\" to search for modules whose name or summary contain the string \"spam\".","title":"Python Libraries"},{"location":"01b-libraries/#micropython-libraries","text":"When you start up your IDE, it may have a list of python modules built in. You can list the current modules you have installed by running the help('modules') command. 1 help ( 'modules' )","title":"Micropython Libraries"},{"location":"01b-libraries/#micropython-builtin-functions","text":"MicroPython is designed to run quickly in a small memory system. So it has trimmed down many of the standard Python libraries to fit the needs of microcontrollers. Most of these libraries start with the letter \"u\" so that you are aware they are designed to run on microcontrollers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cmath \u2013 mathematical functions for complex numbers gc \u2013 control the garbage collector math \u2013 mathematical functions uarray \u2013 arrays of numeric data uasyncio \u2014 asynchronous I/O scheduler ubinascii \u2013 binary/ASCII conversions ucollections \u2013 collection and container types uerrno \u2013 system error codes uhashlib \u2013 hashing algorithms uheapq \u2013 heap queue algorithm uio \u2013 input/output streams ujson \u2013 JSON encoding and decoding uos \u2013 basic \u201coperating system\u201d services ure \u2013 simple regular expressions uselect \u2013 wait for events on a set of streams usocket \u2013 socket module ussl \u2013 SSL/TLS module ustruct \u2013 pack and unpack primitive data types usys \u2013 system specific functions utime \u2013 time related functions uzlib \u2013 zlib decompression _thread \u2013 multithreading support","title":"MicroPython Builtin Functions"},{"location":"01b-libraries/#micropython-specific-libraries","text":"1 2 3 4 5 6 7 8 btree \u2013 simple BTree database framebuf \u2014 frame buffer manipulation machine \u2014 functions related to the hardware micropython \u2013 access and control MicroPython internals network \u2014 network configuration ubluetooth \u2014 low-level Bluetooth ucryptolib \u2013 cryptographic ciphers uctypes \u2013 access binary data in a structured way","title":"MicroPython Specific Libraries"},{"location":"01b-libraries/#adding-a-module","text":"When you are using python and you attempt to use a module that python can't find you will get an error. You must then use the python pip installer tool to add the new library.","title":"Adding a module"},{"location":"01b-libraries/#getting-micropython-libraries-from-pypi","text":"Filter Only MicroPython Libraries","title":"Getting MicroPython Libraries from PyPi"},{"location":"01b-libraries/#full-list-of-modules","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 Please wait a moment while I gather a list of all available modules... ESP-test audioop filecmp random __future__ base64 fileinput re _abc bcrypt fnmatch readline _ast bdb formatter reedsolo _asyncio binascii fractions reprlib _bisect binhex ftplib resource _blake2 bisect functools rlcompleter _bootlocale bitstring gc runpy _bz2 blink-builtin-led genericpath sched _cffi_backend brain_argparse getopt secrets _codecs brain_attrs getpass select _codecs_cn brain_builtin_inference gettext selectors _codecs_hk brain_collections glob send2trash _codecs_iso2022 brain_crypt grp serial _codecs_jp brain_curses gzip setuptools _codecs_kr brain_dataclasses hashlib sh1106 _codecs_tw brain_dateutil heapq sh1106-test _collections brain_fstrings hmac shelve _collections_abc brain_functools html shlex _compat_pickle brain_gi http shutil _compression brain_hashlib i2c-display signal _contextvars brain_http i2c-scanner site _crypt brain_io i2c_lcd six _csv brain_mechanize i2clcd smtpd _ctypes brain_multiprocessing imaplib smtplib _ctypes_test brain_namedtuple_enum imghdr sndhdr _curses brain_nose imp socket _curses_panel brain_numpy_core_fromnumeric importlib socketserver _datetime brain_numpy_core_function_base inspect spi-debug _dbm brain_numpy_core_multiarray io sqlite3 _decimal brain_numpy_core_numeric ipaddress sre_compile _dummy_thread brain_numpy_core_numerictypes isort sre_constants _elementtree brain_numpy_core_umath itertools sre_parse _functools brain_numpy_ndarray jedi ssl _hashlib brain_numpy_random_mtrand json stat _heapq brain_numpy_utils keyword statistics _imp brain_pkg_resources lazy_object_proxy string _io brain_pytest led-strip stringprep _json brain_qt lib2to3 struct _locale brain_random linecache subprocess _lsprof brain_re list-modules sunau _lzma brain_six locale symbol _markupbase brain_ssl logging symtable _md5 brain_subprocess lzma sys _multibytecodec brain_threading macpath sysconfig _multiprocessing brain_typing mailbox syslog _opcode brain_uuid mailcap tabnanny _operator builtins marshal tarfile _osx_support bz2 math telnetlib _pickle cProfile mccabe tempfile _posixsubprocess calendar mimetypes termios _py_abc certifi mmap test _pydecimal cffi modulefinder textwrap _pyio cgi multiprocessing this _queue cgitb mypy thonny _random chunk mypy_extensions threading _scproxy clonevirtualenv mypyc time _sha1 cmath nacl timeit _sha256 cmd netrc tkinter _sha3 code nis token _sha512 codecs nntplib tokenize _signal codeop ntpath toml _sitebuiltins collections nturl2path trace _socket colorsys numbers traceback _sqlite3 compileall opcode tracemalloc _sre concurrent operator tty _ssl configparser optparse turtle _stat contextlib os turtledemo _string contextvars paramiko typed_ast _strptime copy parser types _struct copyreg parso typing _symtable crypt pathlib typing_extensions _sysconfigdata_m_darwin_darwin cryptography pdb unicodedata _testbuffer csv pickle unittest _testcapi ctypes pickletools urllib _testimportmultiple curses pip uu _testmultiphase dataclasses pipenv uuid _thread datetime pipes venv _threading_local dbm pkg_resources virtualenv _tkinter decimal pkgutil virtualenv_support _tracemalloc difflib platform warnings _uuid dir-example plistlib wave _warnings dis poplib weakref _weakref distutils posix webbrowser _weakrefset doctest posixpath websockets _xxtestfuzz docutils pprint wheel abc dummy_threading profile wrapt aifc easy_install pstats wsgiref antigravity ecdsa pty xdrlib argparse email ptyprocess xml array encodings pwd xmlrpc array-test ensurepip py_compile xxlimited ast enum pyclbr xxsubtype astroid errno pycparser zipapp asttokens espefuse pydoc zipfile asynchat espressif pydoc_data zipimport asyncio espsecure pyexpat zlib asyncore esptool pylint at faulthandler queue atexit fcntl quopri Enter any module name to get more help. Or, type \"modules spam\" to search for modules whose name or summary contain the string \"spam\".","title":"Full List of modules"},{"location":"02-boards/","text":"Micropython Boards Technically, any computer that has at least 16K of RAM can run Micropython. ESP32 ESP32 - $5 to $21 Raspberry Pi Pico Raspberry Pi Pico (../glossary.md#ESP32) - $4 Cables Getting Machine Statistics 1 2 import machine help(machine)","title":"Boards"},{"location":"02-boards/#micropython-boards","text":"Technically, any computer that has at least 16K of RAM can run Micropython.","title":"Micropython Boards"},{"location":"02-boards/#esp32","text":"ESP32 - $5 to $21","title":"ESP32"},{"location":"02-boards/#raspberry-pi-pico","text":"Raspberry Pi Pico (../glossary.md#ESP32) - $4","title":"Raspberry Pi Pico"},{"location":"02-boards/#cables","text":"","title":"Cables"},{"location":"02-boards/#getting-machine-statistics","text":"1 2 import machine help(machine)","title":"Getting Machine Statistics"},{"location":"02-esp32/","text":"ESP32 TTGO Step 1: Install the USB to UART Bridge VCP Drivers Follow the directions here: https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers Test this by running the ``ls -l /dev/cu*``` and verify you see: /dev/cu.SLAB_USBtoUART If you don't see this try to reboot. Mac: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/establish-serial-connection.html https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/raw/master/MicroPython_BUILD/firmware/MicroPython_LoBo_esp32_all.zip Step 2: Create a Python Conda Environment for ESP32 This is so we don't mess up other Python projects on your system. 1 2 conda create -n esp32 python = 3 conda activate esp32 Step #3: Install the esptool 1 2 3 4 5 6 7 $ pip3 install esptool Collecting esptool Downloading esptool-3.0.tar.gz ( 149 kB ) | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 149 kB 2 .9 MB/s ... Installing collected packages: pycparser, six, cffi, reedsolo, pyserial, ecdsa, cryptography, bitstring, esptool Successfully installed bitstring-3.1.7 cffi-1.14.5 cryptography-3.4.6 ecdsa-0.16.1 esptool-3.0 pycparser-2.20 pyserial-3.5 reedsolo-1.5.4 six-1.15.0 Step 4: Erase the Old Firmware 1 esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash Step 5: Download the New Firmware Get the ESP32_All prebuilt binary: https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/wiki/firmwares Step 6: Reflash the new ESP32 Firmware 1 2 cd esp32_all/ ../flash.sh -p /dev/cu.SLAB_USBtoUART this will run... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash esptool.py v3.0 Serial port /dev/cu.SLAB_USBtoUART Connecting........_ Detecting chip type... ESP32 Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 24 :62:ab:ca:62:84 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 2 .5s Hard resetting via RTS pin... Configure Thonny You must configure Thonny to use the ESP32. Set the Serial Port First, you must tell Thonny how to find the right port. Set the Interpreter Next, yo must tell Thonny to use the ESP32 interpreter. Run a test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import machine , display , time , math , network , utime tft = display . TFT () tft . init ( tft . ST7789 , bgr = False , rot = tft . LANDSCAPE , miso = 17 , backl_pin = 4 , backl_on = 1 , mosi = 19 , clk = 18 , cs = 5 , dc = 16 ) tft . setwin ( 40 , 52 , 320 , 240 ) for i in range ( 0 , 241 ): color = 0xFFFFFF - tft . hsb2rgb ( i / 241 * 360 , 1 , 1 ) tft . line ( i , 0 , i , 135 , color ) tft . set_fg ( 0x000000 ) tft . ellipse ( 120 , 67 , 120 , 67 ) tft . line ( 0 , 0 , 240 , 135 ) text = \"CoderDojo Rocks!\" tft . text ( 120 - int ( tft . textWidth ( text ) / 2 ), 67 - int ( tft . fontSize ()[ 1 ] / 2 ), text , 0xFFFFFF ) You should see the following on the ESP32 display: References https://www.instructables.com/TTGO-color-Display-With-Micropython-TTGO-T-display/","title":"ESP32"},{"location":"02-esp32/#esp32-ttgo","text":"","title":"ESP32 TTGO"},{"location":"02-esp32/#step-1-install-the-usb-to-uart-bridge-vcp-drivers","text":"Follow the directions here: https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers Test this by running the ``ls -l /dev/cu*``` and verify you see: /dev/cu.SLAB_USBtoUART If you don't see this try to reboot. Mac: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/establish-serial-connection.html https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/raw/master/MicroPython_BUILD/firmware/MicroPython_LoBo_esp32_all.zip","title":"Step 1: Install the USB to UART Bridge VCP Drivers"},{"location":"02-esp32/#step-2-create-a-python-conda-environment-for-esp32","text":"This is so we don't mess up other Python projects on your system. 1 2 conda create -n esp32 python = 3 conda activate esp32","title":"Step 2: Create a Python Conda Environment for ESP32"},{"location":"02-esp32/#step-3-install-the-esptool","text":"1 2 3 4 5 6 7 $ pip3 install esptool Collecting esptool Downloading esptool-3.0.tar.gz ( 149 kB ) | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 149 kB 2 .9 MB/s ... Installing collected packages: pycparser, six, cffi, reedsolo, pyserial, ecdsa, cryptography, bitstring, esptool Successfully installed bitstring-3.1.7 cffi-1.14.5 cryptography-3.4.6 ecdsa-0.16.1 esptool-3.0 pycparser-2.20 pyserial-3.5 reedsolo-1.5.4 six-1.15.0","title":"Step #3: Install the esptool"},{"location":"02-esp32/#step-4-erase-the-old-firmware","text":"1 esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash","title":"Step 4: Erase the Old Firmware"},{"location":"02-esp32/#step-5-download-the-new-firmware","text":"Get the ESP32_All prebuilt binary: https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/wiki/firmwares","title":"Step 5: Download the New Firmware"},{"location":"02-esp32/#step-6-reflash-the-new-esp32-firmware","text":"1 2 cd esp32_all/ ../flash.sh -p /dev/cu.SLAB_USBtoUART this will run... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash esptool.py v3.0 Serial port /dev/cu.SLAB_USBtoUART Connecting........_ Detecting chip type... ESP32 Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 24 :62:ab:ca:62:84 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 2 .5s Hard resetting via RTS pin...","title":"Step 6: Reflash the new ESP32 Firmware"},{"location":"02-esp32/#configure-thonny","text":"You must configure Thonny to use the ESP32.","title":"Configure Thonny"},{"location":"02-esp32/#set-the-serial-port","text":"First, you must tell Thonny how to find the right port.","title":"Set the Serial Port"},{"location":"02-esp32/#set-the-interpreter","text":"Next, yo must tell Thonny to use the ESP32 interpreter.","title":"Set the Interpreter"},{"location":"02-esp32/#run-a-test","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import machine , display , time , math , network , utime tft = display . TFT () tft . init ( tft . ST7789 , bgr = False , rot = tft . LANDSCAPE , miso = 17 , backl_pin = 4 , backl_on = 1 , mosi = 19 , clk = 18 , cs = 5 , dc = 16 ) tft . setwin ( 40 , 52 , 320 , 240 ) for i in range ( 0 , 241 ): color = 0xFFFFFF - tft . hsb2rgb ( i / 241 * 360 , 1 , 1 ) tft . line ( i , 0 , i , 135 , color ) tft . set_fg ( 0x000000 ) tft . ellipse ( 120 , 67 , 120 , 67 ) tft . line ( 0 , 0 , 240 , 135 ) text = \"CoderDojo Rocks!\" tft . text ( 120 - int ( tft . textWidth ( text ) / 2 ), 67 - int ( tft . fontSize ()[ 1 ] / 2 ), text , 0xFFFFFF ) You should see the following on the ESP32 display:","title":"Run a test"},{"location":"02-esp32/#references","text":"https://www.instructables.com/TTGO-color-Display-With-Micropython-TTGO-T-display/","title":"References"},{"location":"02-pi-pico/","text":"Getting Started with the Raspberry Pi Pico The Raspberry Pi Pico is a custom silicon microcontroller built by the Raspberry Pi Foundation with a retail list prices of $4. With 264K SRAM, it has around 100 times the RAM of an Arduino Uno (2K). It is ideal for projects that need more RAM such as project that require drawing to an OLED display. Specs RP2040 microcontroller chip designed by Raspberry Pi Foundation Dual-core Arm Cortex M0+ processor, flexible clock running up to 133 MHz 264KB of SRAM, and 2MB of on-board Flash memory Support for up to 16MB of off-chip Flash memory via dedicated QSPI bus DMA controller Interpolator and integer divider peripherals Castellated module allows soldering direct to carrier boards USB 1.1 and PHY with device and host support Low-power sleep and dormant modes Drag-and-drop programming using mass storage over USB 26 \u00d7 multi-function GPIO pins 3 12 bit analogue inputs 16 controllable PWM channels 2 SPI, 2 I2C, and 2 UART channels Accurate clock and timer on-chip 8 Raspberry Pi Programmable I/O (PIO) state machines Temperature sensor Accelerated floating-point libraries on-chip 8 \u00d7 Programmable I/O (PIO) state machines for custom peripheral support Created using the TSMC 40LP (40 nano meter low power) manufacturing process USB mass-storage boot mode with UF2 support, for drag-and-drop programming USB Cable The Raspberry Pi Pico uses a USB-micro connector. You can purchase USB Micro-B to USB-A or USB-C (Mac) cables on e-bay for under $2 or for $5 at Microcenter. - image from ebay Pico Pinout The pinout diagram for the Raspberry Pi Pico is shown below. It features: * 26 \u00d7 multi-function GPIO pins * 2 \u00d7 SPI, 2 \u00d7 I2C, 2 \u00d7 UART, 3 \u00d7 12-bit ADC, 16 \u00d7 controllable PWM Raspberry Pi Pico\u2019s 40 pins with pin 1 in the upper right corner with the USB connector at the top. The pin numbers are incremented as you go counterclockwise around the board. You go down the left side and then continue up on the right side until you get to pin 40 in the upper right corner. When you program the Pico, you use the machine.Pin() but you always use the GP* number, never the pin number on the board pin numbers. The diagram above shows the top view where pins 1, 2 and 40 are printed next to the pins. Pico Pinout Datasheet PDF Next to each pin is the primary label of what the pin does. Pins 3, 8, 13, 18, 23, 28, 33 and 38 with the black background are all GND pins. Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Label Name Description V3 3.3 volts power A source of 3.3 V power, the same voltage your Pico runs at internally, generated from the VSYS input. This power supply can be switched on and off using the 3V3_EN pin above it, which also switches your Pico off. VSYS ~2-5 volts power A pin directly connected to your Pico\u2019s internal power supply, which cannot be switched off without also switching Pico off. VBUS 5 volts power A source of 5 V power taken from your Pico\u2019s micro USB port, and used to power hardware which needs more than 3.3 V. GND 0 volts ground A ground connection, used to complete a circuit connected to a power source. Several of these pins are dotted around your Pico to make wiring easier. GPxx General-purpose input/output pin number \u2018xx The GPIO pins available for your program, labelled \u2018GP0\u2019 through to \u2018GP28\u2019. GPxx_ADCx General-purpose input/output pin number \u2018xx\u2019, with analogue input number \u2018x\u2019 A GPIO pin which ends in \u2018ADC\u2019 and a number can be used as an analogue input as well as a digital input or output \u2013 but not both at the same time. ADC_VREF Analogue-to-digital converter (ADC) voltage reference A special input pin which sets a reference voltage for any analogue inputs. AGND Analogue-to-digital converter (ADC) 0 volts ground A special ground connection for use with the ADC_VREF pin. RUN Enables or disables your Pico The RUN header is used to start and stop your Pico from another microcontroller. Steps To Get Micropython Running on the Mac Download the MicroPython UF2 file. Push and hold the BOOTSEL button and plug your Pico into the USB port of your Raspberry Pi or other computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2. Drag and drop the MicroPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. You are now running MicroPython. Using Thonny Thonny is a free lightweight Python development tool. Download the Thonny Application Download the Thonny Pico driver Configure Thonny to use the Pico interpreter Test using the help() function Test by running a blink application 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done! Using the Onboard LED 1 2 3 4 from machine import Pin import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) led_onboard . value ( 1 ) 1 2 3 4 5 6 7 8 9 from machine import Pin import utime # right uppermost pin with USB on the left led = Pin ( 16 , Pin . OUT ) led . low () while True : led . toggle () utime . sleep ( 1 ) Press the Play Button References Getting Started Guide Raspberry Pi Getting Started Book PDF Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)","title":"Raspberry Pi Pico"},{"location":"02-pi-pico/#getting-started-with-the-raspberry-pi-pico","text":"The Raspberry Pi Pico is a custom silicon microcontroller built by the Raspberry Pi Foundation with a retail list prices of $4. With 264K SRAM, it has around 100 times the RAM of an Arduino Uno (2K). It is ideal for projects that need more RAM such as project that require drawing to an OLED display.","title":"Getting Started with the Raspberry Pi Pico"},{"location":"02-pi-pico/#specs","text":"RP2040 microcontroller chip designed by Raspberry Pi Foundation Dual-core Arm Cortex M0+ processor, flexible clock running up to 133 MHz 264KB of SRAM, and 2MB of on-board Flash memory Support for up to 16MB of off-chip Flash memory via dedicated QSPI bus DMA controller Interpolator and integer divider peripherals Castellated module allows soldering direct to carrier boards USB 1.1 and PHY with device and host support Low-power sleep and dormant modes Drag-and-drop programming using mass storage over USB 26 \u00d7 multi-function GPIO pins 3 12 bit analogue inputs 16 controllable PWM channels 2 SPI, 2 I2C, and 2 UART channels Accurate clock and timer on-chip 8 Raspberry Pi Programmable I/O (PIO) state machines Temperature sensor Accelerated floating-point libraries on-chip 8 \u00d7 Programmable I/O (PIO) state machines for custom peripheral support Created using the TSMC 40LP (40 nano meter low power) manufacturing process USB mass-storage boot mode with UF2 support, for drag-and-drop programming","title":"Specs"},{"location":"02-pi-pico/#usb-cable","text":"The Raspberry Pi Pico uses a USB-micro connector. You can purchase USB Micro-B to USB-A or USB-C (Mac) cables on e-bay for under $2 or for $5 at Microcenter. - image from ebay","title":"USB Cable"},{"location":"02-pi-pico/#pico-pinout","text":"The pinout diagram for the Raspberry Pi Pico is shown below. It features: * 26 \u00d7 multi-function GPIO pins * 2 \u00d7 SPI, 2 \u00d7 I2C, 2 \u00d7 UART, 3 \u00d7 12-bit ADC, 16 \u00d7 controllable PWM Raspberry Pi Pico\u2019s 40 pins with pin 1 in the upper right corner with the USB connector at the top. The pin numbers are incremented as you go counterclockwise around the board. You go down the left side and then continue up on the right side until you get to pin 40 in the upper right corner. When you program the Pico, you use the machine.Pin() but you always use the GP* number, never the pin number on the board pin numbers. The diagram above shows the top view where pins 1, 2 and 40 are printed next to the pins. Pico Pinout Datasheet PDF Next to each pin is the primary label of what the pin does. Pins 3, 8, 13, 18, 23, 28, 33 and 38 with the black background are all GND pins. Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Label Name Description V3 3.3 volts power A source of 3.3 V power, the same voltage your Pico runs at internally, generated from the VSYS input. This power supply can be switched on and off using the 3V3_EN pin above it, which also switches your Pico off. VSYS ~2-5 volts power A pin directly connected to your Pico\u2019s internal power supply, which cannot be switched off without also switching Pico off. VBUS 5 volts power A source of 5 V power taken from your Pico\u2019s micro USB port, and used to power hardware which needs more than 3.3 V. GND 0 volts ground A ground connection, used to complete a circuit connected to a power source. Several of these pins are dotted around your Pico to make wiring easier. GPxx General-purpose input/output pin number \u2018xx The GPIO pins available for your program, labelled \u2018GP0\u2019 through to \u2018GP28\u2019. GPxx_ADCx General-purpose input/output pin number \u2018xx\u2019, with analogue input number \u2018x\u2019 A GPIO pin which ends in \u2018ADC\u2019 and a number can be used as an analogue input as well as a digital input or output \u2013 but not both at the same time. ADC_VREF Analogue-to-digital converter (ADC) voltage reference A special input pin which sets a reference voltage for any analogue inputs. AGND Analogue-to-digital converter (ADC) 0 volts ground A special ground connection for use with the ADC_VREF pin. RUN Enables or disables your Pico The RUN header is used to start and stop your Pico from another microcontroller.","title":"Pico Pinout"},{"location":"02-pi-pico/#steps-to-get-micropython-running-on-the-mac","text":"Download the MicroPython UF2 file. Push and hold the BOOTSEL button and plug your Pico into the USB port of your Raspberry Pi or other computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2. Drag and drop the MicroPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. You are now running MicroPython.","title":"Steps To Get Micropython Running on the Mac"},{"location":"02-pi-pico/#using-thonny","text":"Thonny is a free lightweight Python development tool. Download the Thonny Application Download the Thonny Pico driver Configure Thonny to use the Pico interpreter Test using the help() function Test by running a blink application 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done!","title":"Using Thonny"},{"location":"02-pi-pico/#using-the-onboard-led","text":"1 2 3 4 from machine import Pin import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) led_onboard . value ( 1 ) 1 2 3 4 5 6 7 8 9 from machine import Pin import utime # right uppermost pin with USB on the left led = Pin ( 16 , Pin . OUT ) led . low () while True : led . toggle () utime . sleep ( 1 ) Press the Play Button","title":"Using the Onboard LED"},{"location":"02-pi-pico/#references","text":"","title":"References"},{"location":"02-pi-pico/#getting-started-guide","text":"Raspberry Pi Getting Started","title":"Getting Started Guide"},{"location":"02-pi-pico/#book-pdf","text":"Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)","title":"Book PDF"},{"location":"02b-accessories/","text":"Micropython Accessories USB Cable For a Mac with USB-C connectors, you will need to get a USB micro to C cable: Breadboard You can purchase 1/2 size 400 connector breadboards on eBay for under two dollars each. Universal Mini Solderless Breadboard White Material 400 Points Breadboard Jumpers Use 22 gauge wire. Get a large spool of black and red and smaller spools of other colors. 65X 65PCS Jumper Wire Cable Kit For Solderless Breadboard LEDs and 330 Ohm resistors LED Strips $5 for a 1 meter strip with 60 pixels per meter. Ultrasonic Distance Sensors HC-SR04 Ultrasonic Distance Sensor - $1 on eBay Motor Controllers Mini Motor Drive Shield Expansion Board L293D Module For Arduino UNO MEGA2560 R3 $3 Motion Sensors Servos Photoresistors Speakers Stepper Motors Displays OLED Displays","title":"Accessories"},{"location":"02b-accessories/#micropython-accessories","text":"","title":"Micropython Accessories"},{"location":"02b-accessories/#usb-cable","text":"For a Mac with USB-C connectors, you will need to get a USB micro to C cable:","title":"USB Cable"},{"location":"02b-accessories/#breadboard","text":"You can purchase 1/2 size 400 connector breadboards on eBay for under two dollars each. Universal Mini Solderless Breadboard White Material 400 Points","title":"Breadboard"},{"location":"02b-accessories/#breadboard-jumpers","text":"Use 22 gauge wire. Get a large spool of black and red and smaller spools of other colors. 65X 65PCS Jumper Wire Cable Kit For Solderless Breadboard","title":"Breadboard Jumpers"},{"location":"02b-accessories/#leds-and-330-ohm-resistors","text":"","title":"LEDs and 330 Ohm resistors"},{"location":"02b-accessories/#led-strips","text":"$5 for a 1 meter strip with 60 pixels per meter.","title":"LED Strips"},{"location":"02b-accessories/#ultrasonic-distance-sensors","text":"HC-SR04 Ultrasonic Distance Sensor - $1 on eBay","title":"Ultrasonic Distance Sensors"},{"location":"02b-accessories/#motor-controllers","text":"Mini Motor Drive Shield Expansion Board L293D Module For Arduino UNO MEGA2560 R3 $3","title":"Motor Controllers"},{"location":"02b-accessories/#motion-sensors","text":"","title":"Motion Sensors"},{"location":"02b-accessories/#servos","text":"","title":"Servos"},{"location":"02b-accessories/#photoresistors","text":"","title":"Photoresistors"},{"location":"02b-accessories/#speakers","text":"","title":"Speakers"},{"location":"02b-accessories/#stepper-motors","text":"","title":"Stepper Motors"},{"location":"02b-accessories/#displays","text":"","title":"Displays"},{"location":"02b-accessories/#oled-displays","text":"","title":"OLED Displays"},{"location":"02c-thonny/","text":"Thonny Python IDE A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny has the following screen areas. Toolbar Script Area Python Shell Interpreter Thonny runs on Mac, Windows and Linux. Running help() You can enter the help() function in the main script area and then press the Play button. This will tell you 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 MicroPython v1.14 on 2021-02-02; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT Welcome to MicroPython! For online help please visit https://micropython.org/help/. For access to the hardware use the 'machine' module. RP2 specific commands are in the 'rp2' module. Quick overview of some objects: machine.Pin(pin) -- get a pin, eg machine.Pin(0) machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p methods: init(..), value([v]), high(), low(), irq(handler) machine.ADC(pin) -- make an analog object from a pin methods: read_u16() machine.PWM(pin) -- make a PWM object from a pin methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d]) machine.I2C(id) -- create an I2C object (id=0,1) methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True) readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg) machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1) methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf) machine.Timer(freq, callback) -- create a software timer object eg: machine.Timer(freq=1, callback=lambda t:print(t)) Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Useful control commands: CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') >>> Save Options You can save a python file in Thonny to either the Pico or to your local computer's file system. first stop execution of any program you are running. Downloading the Firmware After you start up Thonny there will be a button in the lower right corner. After you click on it you will see the following: 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done! Version After you press play the following will appear in the console. 1 2 3 MicroPython v1.13-290-g556ae7914 on 2021 -01-21 ; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT Background on Thonny Micropython was originally developed by Damien George and first released in 2014. Some support of Thonny is being done the University of Tartu Institute of Computer Science in Estonia. Several features were sponsored by the Raspberry Pi Foundation Thonny web site","title":"Thonny IDE"},{"location":"02c-thonny/#thonny-python-ide","text":"A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny has the following screen areas.","title":"Thonny Python IDE"},{"location":"02c-thonny/#toolbar","text":"","title":"Toolbar"},{"location":"02c-thonny/#script-area","text":"","title":"Script Area"},{"location":"02c-thonny/#python-shell","text":"","title":"Python Shell"},{"location":"02c-thonny/#interpreter","text":"Thonny runs on Mac, Windows and Linux.","title":"Interpreter"},{"location":"02c-thonny/#running-help","text":"You can enter the help() function in the main script area and then press the Play button. This will tell you 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 MicroPython v1.14 on 2021-02-02; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT Welcome to MicroPython! For online help please visit https://micropython.org/help/. For access to the hardware use the 'machine' module. RP2 specific commands are in the 'rp2' module. Quick overview of some objects: machine.Pin(pin) -- get a pin, eg machine.Pin(0) machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p methods: init(..), value([v]), high(), low(), irq(handler) machine.ADC(pin) -- make an analog object from a pin methods: read_u16() machine.PWM(pin) -- make a PWM object from a pin methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d]) machine.I2C(id) -- create an I2C object (id=0,1) methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True) readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg) machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1) methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf) machine.Timer(freq, callback) -- create a software timer object eg: machine.Timer(freq=1, callback=lambda t:print(t)) Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Useful control commands: CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') >>>","title":"Running help()"},{"location":"02c-thonny/#save-options","text":"You can save a python file in Thonny to either the Pico or to your local computer's file system. first stop execution of any program you are running.","title":"Save Options"},{"location":"02c-thonny/#downloading-the-firmware","text":"After you start up Thonny there will be a button in the lower right corner. After you click on it you will see the following: 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done!","title":"Downloading the Firmware"},{"location":"02c-thonny/#version","text":"After you press play the following will appear in the console. 1 2 3 MicroPython v1.13-290-g556ae7914 on 2021 -01-21 ; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT","title":"Version"},{"location":"02c-thonny/#background-on-thonny","text":"Micropython was originally developed by Damien George and first released in 2014. Some support of Thonny is being done the University of Tartu Institute of Computer Science in Estonia. Several features were sponsored by the Raspberry Pi Foundation Thonny web site","title":"Background on Thonny"},{"location":"03-blink/","text":"Blink in Micropython Overview In this lab, we will use Micropython to make an LED blink on and off using Python. We will assume that an LED is connected to pin GIO16 and is connected via a 330 ohm resistor to ground. Virual Lab Unicorn Emulator Sample Program This program has two parts. The first part is often called the preamble - this code gets executed once and loads the right libraries and initializes global variables. The second part is the main event loop. This program continues to run until the device is powered down or reset. The import machine statement is required to define the characteristics of our physical machine. The import time library is required for the python sleep function. Blinking the Builtin LED This lab is the perfect place to start since you only need the Pico and a micro USB cable. The pico has a single built in LED wired to GPIO 25. This program will blink the built-in LED on and off every 1/4 of a second. 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( . 25 ) If you save the file as main.py, this program will run when the pico starts up without the BOOTSEL being pressed. Here is the code that will blink an LED that is connected to PIN GIO16, which is in the upper right corner of the Pico. 1 2 3 4 5 6 7 8 9 10 11 import machine import time # upper right corner pin with USB on the left led = machine . Pin ( 16 , machine . Pin . OUT ) # loop forever while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( 5 )","title":"Blink"},{"location":"03-blink/#blink-in-micropython","text":"","title":"Blink in Micropython"},{"location":"03-blink/#overview","text":"In this lab, we will use Micropython to make an LED blink on and off using Python. We will assume that an LED is connected to pin GIO16 and is connected via a 330 ohm resistor to ground.","title":"Overview"},{"location":"03-blink/#virual-lab","text":"Unicorn Emulator","title":"Virual Lab"},{"location":"03-blink/#sample-program","text":"This program has two parts. The first part is often called the preamble - this code gets executed once and loads the right libraries and initializes global variables. The second part is the main event loop. This program continues to run until the device is powered down or reset. The import machine statement is required to define the characteristics of our physical machine. The import time library is required for the python sleep function.","title":"Sample Program"},{"location":"03-blink/#blinking-the-builtin-led","text":"This lab is the perfect place to start since you only need the Pico and a micro USB cable. The pico has a single built in LED wired to GPIO 25. This program will blink the built-in LED on and off every 1/4 of a second. 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( . 25 ) If you save the file as main.py, this program will run when the pico starts up without the BOOTSEL being pressed. Here is the code that will blink an LED that is connected to PIN GIO16, which is in the upper right corner of the Pico. 1 2 3 4 5 6 7 8 9 10 11 import machine import time # upper right corner pin with USB on the left led = machine . Pin ( 16 , machine . Pin . OUT ) # loop forever while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( 5 )","title":"Blinking the Builtin LED"},{"location":"03-button/","text":"Button In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. You will hook up an LED to GP15. 1 2 3 4 5 6 7 8 9 10 from machine import Pin import time led = Pin ( 15 , Pin . OUT ) button = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) # input with pull down resistor while True : if button . value (): # if the value changes led . toggle () time . sleep ( 0.1 ) # wait 1/10th of a second References Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video","title":"Button"},{"location":"03-button/#button","text":"In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. You will hook up an LED to GP15. 1 2 3 4 5 6 7 8 9 10 from machine import Pin import time led = Pin ( 15 , Pin . OUT ) button = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) # input with pull down resistor while True : if button . value (): # if the value changes led . toggle () time . sleep ( 0.1 ) # wait 1/10th of a second","title":"Button"},{"location":"03-button/#references","text":"Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video","title":"References"},{"location":"03-temperature/","text":"Using the Builtin Temperature Sensor Reading the temperature 1 2 3 4 5 6 7 8 import machine import utime sensor_temp = machine . ADC ( 4 ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 print ( temperature ) print ( ' \\n ' ) Logging the Temperature 1 2 3 4 5 6 7 8 9 10 11 import machine import utime sensor_temp = machine . ADC ( machine . ADC . CORE_TEMP ) conversion_factor = 3.3 / ( 65535 ) file = open ( \"temps.txt\" , \"w\" ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 file . write ( str ( temperature )) file . flush () utime . sleep ( 10 )","title":"Temperature"},{"location":"03-temperature/#using-the-builtin-temperature-sensor","text":"","title":"Using the Builtin Temperature Sensor"},{"location":"03-temperature/#reading-the-temperature","text":"1 2 3 4 5 6 7 8 import machine import utime sensor_temp = machine . ADC ( 4 ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 print ( temperature ) print ( ' \\n ' )","title":"Reading the temperature"},{"location":"03-temperature/#logging-the-temperature","text":"1 2 3 4 5 6 7 8 9 10 11 import machine import utime sensor_temp = machine . ADC ( machine . ADC . CORE_TEMP ) conversion_factor = 3.3 / ( 65535 ) file = open ( \"temps.txt\" , \"w\" ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 file . write ( str ( temperature )) file . flush () utime . sleep ( 10 )","title":"Logging the Temperature"},{"location":"04-servo/","text":"Micropython Servo Lab TBD 1 2 3 4 5 6 7 import machine import pyb # The pyboard has four simple servo connections servo = pyb . Servo ( 1 ) servo . angle ( 90 , 5000 )","title":"Servo"},{"location":"04-servo/#micropython-servo-lab","text":"TBD 1 2 3 4 5 6 7 import machine import pyb # The pyboard has four simple servo connections servo = pyb . Servo ( 1 ) servo . angle ( 90 , 5000 )","title":"Micropython Servo Lab"},{"location":"05-led-strip/","text":"LED Strip Note The current version of the runtime (rp2-pico-20210205-unstable-v1.14-8-g1f800cac3) accidentally dropped the array module. To run this you will need to use this See issue Issue 6837: rp2 port no module named array . This should be fixed in a day or two. Feb. 20th, 2021. - Dan Circuit connections LED Strip Pico Name Pico Pin Description GND GND 3 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 1 Topmost left with USB on top Parameters 1 2 3 NUM_LEDS = 60 PIN_NUM = 1 brightness = 1 full code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 # Example using PIO to drive a set of WS2812 LEDs. import array , time from machine import Pin import rp2 # Configure the number of WS2812 LEDs. NUM_LEDS = 60 PIN_NUM = 22 brightness = 0.2 @rp2 . asm_pio ( sideset_init = rp2 . PIO . OUT_LOW , out_shiftdir = rp2 . PIO . SHIFT_LEFT , autopull = True , pull_thresh = 24 ) def ws2812 (): T1 = 2 T2 = 5 T3 = 3 wrap_target () label ( \"bitloop\" ) out ( x , 1 ) . side ( 0 ) [ T3 - 1 ] jmp ( not_x , \"do_zero\" ) . side ( 1 ) [ T1 - 1 ] jmp ( \"bitloop\" ) . side ( 1 ) [ T2 - 1 ] label ( \"do_zero\" ) nop () . side ( 0 ) [ T2 - 1 ] wrap () # Create the StateMachine with the ws2812 program, outputting on pin sm = rp2 . StateMachine ( 0 , ws2812 , freq = 8_000_000 , sideset_base = Pin ( PIN_NUM )) # Start the StateMachine, it will wait for data on its FIFO. sm . active ( 1 ) # Display a pattern on the LEDs via an array of LED RGB values. ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) ########################################################################## def pixels_show (): dimmer_ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) for i , c in enumerate ( ar ): r = int ((( c >> 8 ) & 0xFF ) * brightness ) g = int ((( c >> 16 ) & 0xFF ) * brightness ) b = int (( c & 0xFF ) * brightness ) dimmer_ar [ i ] = ( g << 16 ) + ( r << 8 ) + b sm . put ( dimmer_ar , 8 ) time . sleep_ms ( 10 ) def pixels_set ( i , color ): ar [ i ] = ( color [ 1 ] << 16 ) + ( color [ 0 ] << 8 ) + color [ 2 ] def pixels_fill ( color ): for i in range ( len ( ar )): pixels_set ( i , color ) def color_chase ( color , wait ): for i in range ( NUM_LEDS ): pixels_set ( i , color ) time . sleep ( wait ) pixels_show () time . sleep ( 0.2 ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait ): for j in range ( 255 ): for i in range ( NUM_LEDS ): rc_index = ( i * 256 // NUM_LEDS ) + j pixels_set ( i , wheel ( rc_index & 255 )) pixels_show () time . sleep ( wait ) BLACK = ( 0 , 0 , 0 ) RED = ( 255 , 0 , 0 ) YELLOW = ( 255 , 150 , 0 ) GREEN = ( 0 , 255 , 0 ) CYAN = ( 0 , 255 , 255 ) BLUE = ( 0 , 0 , 255 ) PURPLE = ( 180 , 0 , 255 ) WHITE = ( 255 , 255 , 255 ) COLORS = ( BLACK , RED , YELLOW , GREEN , CYAN , BLUE , PURPLE , WHITE ) print ( \"fills\" ) for color in COLORS : pixels_fill ( color ) pixels_show () time . sleep ( 0.2 ) print ( \"chases\" ) for color in COLORS : color_chase ( color , 0.01 ) print ( \"rainbow\" ) rainbow_cycle ( 0 ) References Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video rp2 port no module named array","title":"LED Strip"},{"location":"05-led-strip/#led-strip","text":"Note The current version of the runtime (rp2-pico-20210205-unstable-v1.14-8-g1f800cac3) accidentally dropped the array module. To run this you will need to use this See issue Issue 6837: rp2 port no module named array . This should be fixed in a day or two. Feb. 20th, 2021. - Dan","title":"LED Strip"},{"location":"05-led-strip/#circuit-connections","text":"LED Strip Pico Name Pico Pin Description GND GND 3 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 1 Topmost left with USB on top","title":"Circuit connections"},{"location":"05-led-strip/#parameters","text":"1 2 3 NUM_LEDS = 60 PIN_NUM = 1 brightness = 1","title":"Parameters"},{"location":"05-led-strip/#full-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 # Example using PIO to drive a set of WS2812 LEDs. import array , time from machine import Pin import rp2 # Configure the number of WS2812 LEDs. NUM_LEDS = 60 PIN_NUM = 22 brightness = 0.2 @rp2 . asm_pio ( sideset_init = rp2 . PIO . OUT_LOW , out_shiftdir = rp2 . PIO . SHIFT_LEFT , autopull = True , pull_thresh = 24 ) def ws2812 (): T1 = 2 T2 = 5 T3 = 3 wrap_target () label ( \"bitloop\" ) out ( x , 1 ) . side ( 0 ) [ T3 - 1 ] jmp ( not_x , \"do_zero\" ) . side ( 1 ) [ T1 - 1 ] jmp ( \"bitloop\" ) . side ( 1 ) [ T2 - 1 ] label ( \"do_zero\" ) nop () . side ( 0 ) [ T2 - 1 ] wrap () # Create the StateMachine with the ws2812 program, outputting on pin sm = rp2 . StateMachine ( 0 , ws2812 , freq = 8_000_000 , sideset_base = Pin ( PIN_NUM )) # Start the StateMachine, it will wait for data on its FIFO. sm . active ( 1 ) # Display a pattern on the LEDs via an array of LED RGB values. ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) ########################################################################## def pixels_show (): dimmer_ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) for i , c in enumerate ( ar ): r = int ((( c >> 8 ) & 0xFF ) * brightness ) g = int ((( c >> 16 ) & 0xFF ) * brightness ) b = int (( c & 0xFF ) * brightness ) dimmer_ar [ i ] = ( g << 16 ) + ( r << 8 ) + b sm . put ( dimmer_ar , 8 ) time . sleep_ms ( 10 ) def pixels_set ( i , color ): ar [ i ] = ( color [ 1 ] << 16 ) + ( color [ 0 ] << 8 ) + color [ 2 ] def pixels_fill ( color ): for i in range ( len ( ar )): pixels_set ( i , color ) def color_chase ( color , wait ): for i in range ( NUM_LEDS ): pixels_set ( i , color ) time . sleep ( wait ) pixels_show () time . sleep ( 0.2 ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait ): for j in range ( 255 ): for i in range ( NUM_LEDS ): rc_index = ( i * 256 // NUM_LEDS ) + j pixels_set ( i , wheel ( rc_index & 255 )) pixels_show () time . sleep ( wait ) BLACK = ( 0 , 0 , 0 ) RED = ( 255 , 0 , 0 ) YELLOW = ( 255 , 150 , 0 ) GREEN = ( 0 , 255 , 0 ) CYAN = ( 0 , 255 , 255 ) BLUE = ( 0 , 0 , 255 ) PURPLE = ( 180 , 0 , 255 ) WHITE = ( 255 , 255 , 255 ) COLORS = ( BLACK , RED , YELLOW , GREEN , CYAN , BLUE , PURPLE , WHITE ) print ( \"fills\" ) for color in COLORS : pixels_fill ( color ) pixels_show () time . sleep ( 0.2 ) print ( \"chases\" ) for color in COLORS : color_chase ( color , 0.01 ) print ( \"rainbow\" ) rainbow_cycle ( 0 )","title":"full code"},{"location":"05-led-strip/#references","text":"Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video rp2 port no module named array","title":"References"},{"location":"10-character-lcd-display/","text":"Character LCD Display connections Address Scanner Scanner Code 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( i2c . scan ()) Scanner Result 1 2 3 >>> %Run -c $EDITOR_CONTENT [ 39 ] >>> Hello To The LCD 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) i2c . writeto ( 114 , ' \\x7C ' ) i2c . writeto ( 114 , ' \\x2D ' ) i2c . writeto ( 114 , \"hello world\" ) 1602 LCD MicroPython Forum on 1602 LCDs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import i2clcd lcd = i2clcd . i2clcd ( i2c_bus = 1 , i2c_addr = 0x27 , lcd_width = 16 ) lcd . init () # fill a line by the text lcd . print_line ( 'hello' , line = 0 ) lcd . print_line ( 'world!' , line = 1 , align = 'RIGHT' ) # print text at the current cursor position lcd . move_cursor ( 1 , 0 ) lcd . print ( 'the' ) # custom character char_celsius = ( 0x10 , 0x06 , 0x09 , 0x08 , 0x08 , 0x09 , 0x06 , 0x00 ) lcd . write_CGRAM ( char_celsius , 0 ) lcd . move_cursor ( 0 , 6 ) lcd . print ( b 'CGRAM: ' + i2clcd . CGRAM_CHR [ 0 ]) ssd1306 module SSD1306 Library - click the RAW button and then right click to do a \"Save As\" HD44780 Drivers Dave Hylands HD44780 Drivers in Python References https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py Adafruit LCD Guide","title":"Character LCD"},{"location":"10-character-lcd-display/#character-lcd-display","text":"","title":"Character LCD Display"},{"location":"10-character-lcd-display/#connections","text":"","title":"connections"},{"location":"10-character-lcd-display/#address-scanner","text":"","title":"Address Scanner"},{"location":"10-character-lcd-display/#scanner-code","text":"1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( i2c . scan ())","title":"Scanner Code"},{"location":"10-character-lcd-display/#scanner-result","text":"1 2 3 >>> %Run -c $EDITOR_CONTENT [ 39 ] >>>","title":"Scanner Result"},{"location":"10-character-lcd-display/#hello-to-the-lcd","text":"1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) i2c . writeto ( 114 , ' \\x7C ' ) i2c . writeto ( 114 , ' \\x2D ' ) i2c . writeto ( 114 , \"hello world\" )","title":"Hello To The LCD"},{"location":"10-character-lcd-display/#1602-lcd","text":"MicroPython Forum on 1602 LCDs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import i2clcd lcd = i2clcd . i2clcd ( i2c_bus = 1 , i2c_addr = 0x27 , lcd_width = 16 ) lcd . init () # fill a line by the text lcd . print_line ( 'hello' , line = 0 ) lcd . print_line ( 'world!' , line = 1 , align = 'RIGHT' ) # print text at the current cursor position lcd . move_cursor ( 1 , 0 ) lcd . print ( 'the' ) # custom character char_celsius = ( 0x10 , 0x06 , 0x09 , 0x08 , 0x08 , 0x09 , 0x06 , 0x00 ) lcd . write_CGRAM ( char_celsius , 0 ) lcd . move_cursor ( 0 , 6 ) lcd . print ( b 'CGRAM: ' + i2clcd . CGRAM_CHR [ 0 ])","title":"1602 LCD"},{"location":"10-character-lcd-display/#ssd1306-module","text":"SSD1306 Library - click the RAW button and then right click to do a \"Save As\"","title":"ssd1306 module"},{"location":"10-character-lcd-display/#hd44780-drivers","text":"Dave Hylands HD44780 Drivers in Python","title":"HD44780 Drivers"},{"location":"10-character-lcd-display/#references","text":"https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py Adafruit LCD Guide","title":"References"},{"location":"10-displays/","text":"Adding A Display to Your Project In the past, the memory available in an standard Arduino Uno (2K bytes) was too small to add high quality displays. With the arrival of the ESP32 and the Raspberry Pi Pico this has all changed. These microcontrollers have around 100 times that RAM - typically around 200K bytes. So we are integrating low-cost OLED displays into many of our CoderDojo projects! Display Types There are four main types of display technology that use for small microcontrollers. LED - Light Emitting Diode - these are often low-resolution but have larger area. The start with single color displays but there are also multi-color LED strips and LED matrix displays. OLED - Organic Light Emitting Diode - small low-cost and high-contrast monochrome displays used in watches. LCD - Liquid Crystal Display - many of these are monochrome displays that must have precise power to get consistent contrast. TFT - Thin Film Transistor - a type of LCD that are used for larger color screens. 240X240 TFT Display Full Color LCD TFT Display SPI HD 65K Module ST7735 Concepts Before you begin to use these displays, there are a few things to understand to use them effectively. Based on your project needs, you can use this knowledge to find the right solution for you. Framebuffers A framebuffer is a copy of the display information that is resident within the RAM of the microcontroller. It must be as large as the display. For a 128X64 monochrome display this would be 128 * 64 = 8192 bits or 1,024 bytes (1K). A full color 240X240 TFT which uses 8 bits for red, green and blue would require 3 X 8 X 240 X 240 = 1,382,400 bits or 172K bytes. Not all all displays need framebuffers. Some displays can take a series of vector drawing commands such as \"draw line\" and \"draw text\". These displays can be useful if you don't have a large amount of RAM. Display Chip Types There are two common versions: SSD1306 - This is the most popular and versatile chip. It can be used to drive many different types and sizes of OLEDs. The SSD1306 can be used with both the simple 4 wire I2C interface as well as the slightly faster 7 wire SPI interface. These devices have only four wires labeled VCC, GND, SDA and SCL. SDA is for data and SCL is for the clock. SH1106 - This is less popular version and supports the 4-wire I2C interface. ST7735 - This chip is used on larger color TFT displays. You can usually look on the back of the display device and see what type of check controls your OLED display. Communication Protocols In addition to the multiple types of displays and types of chips driving the displays, there are also two options on how you want to communicate between your microcontroller and the display. I2C - This is the most common type and only requires two wires beside power and ground. Us this as your default unless you display does not support it. The original specification of I2C had a communication speed of 100K bits per second. Many systems can be run at 400K per second. SPI - This is a more complex interface and requires up to seven wires. Some devices only support SPI interfaces. SPI typically runs around 1M bits/second although it can go up to 10M bits/second in some applications. SPI is ideal when you want to transfer a large amount of display data to a screen quickly. Basic Draw Functions For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function. Initializing the Framebuffer Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following: Full list of Drawing Functions Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state is 0=off (black) and 1=on (white). Function Description Example blit fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x1, x2, y, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert invert the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel Draw a single point on the screen rect Draw an empty rectangle scroll Scroll the display text Write text at a point vline Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display Initialize the display write_cmd Write a command to the display show Update the display from the frame buffer poweroff poweron contrast write_data Interfaces I2C Pros: Simple four wire interface Pin Purpose Description SPI Example: 128X64 pixel monochrome displays Types of Displays Summary Table Display Type Cost Links Notes LCD OLED TFT Displays References ST7735 Micropython Driver by Anthony Norman","title":"Displays"},{"location":"10-displays/#adding-a-display-to-your-project","text":"In the past, the memory available in an standard Arduino Uno (2K bytes) was too small to add high quality displays. With the arrival of the ESP32 and the Raspberry Pi Pico this has all changed. These microcontrollers have around 100 times that RAM - typically around 200K bytes. So we are integrating low-cost OLED displays into many of our CoderDojo projects!","title":"Adding A Display to Your Project"},{"location":"10-displays/#display-types","text":"There are four main types of display technology that use for small microcontrollers. LED - Light Emitting Diode - these are often low-resolution but have larger area. The start with single color displays but there are also multi-color LED strips and LED matrix displays. OLED - Organic Light Emitting Diode - small low-cost and high-contrast monochrome displays used in watches. LCD - Liquid Crystal Display - many of these are monochrome displays that must have precise power to get consistent contrast. TFT - Thin Film Transistor - a type of LCD that are used for larger color screens. 240X240 TFT Display Full Color LCD TFT Display SPI HD 65K Module ST7735","title":"Display Types"},{"location":"10-displays/#concepts","text":"Before you begin to use these displays, there are a few things to understand to use them effectively. Based on your project needs, you can use this knowledge to find the right solution for you.","title":"Concepts"},{"location":"10-displays/#framebuffers","text":"A framebuffer is a copy of the display information that is resident within the RAM of the microcontroller. It must be as large as the display. For a 128X64 monochrome display this would be 128 * 64 = 8192 bits or 1,024 bytes (1K). A full color 240X240 TFT which uses 8 bits for red, green and blue would require 3 X 8 X 240 X 240 = 1,382,400 bits or 172K bytes. Not all all displays need framebuffers. Some displays can take a series of vector drawing commands such as \"draw line\" and \"draw text\". These displays can be useful if you don't have a large amount of RAM.","title":"Framebuffers"},{"location":"10-displays/#display-chip-types","text":"There are two common versions: SSD1306 - This is the most popular and versatile chip. It can be used to drive many different types and sizes of OLEDs. The SSD1306 can be used with both the simple 4 wire I2C interface as well as the slightly faster 7 wire SPI interface. These devices have only four wires labeled VCC, GND, SDA and SCL. SDA is for data and SCL is for the clock. SH1106 - This is less popular version and supports the 4-wire I2C interface. ST7735 - This chip is used on larger color TFT displays. You can usually look on the back of the display device and see what type of check controls your OLED display.","title":"Display Chip Types"},{"location":"10-displays/#communication-protocols","text":"In addition to the multiple types of displays and types of chips driving the displays, there are also two options on how you want to communicate between your microcontroller and the display. I2C - This is the most common type and only requires two wires beside power and ground. Us this as your default unless you display does not support it. The original specification of I2C had a communication speed of 100K bits per second. Many systems can be run at 400K per second. SPI - This is a more complex interface and requires up to seven wires. Some devices only support SPI interfaces. SPI typically runs around 1M bits/second although it can go up to 10M bits/second in some applications. SPI is ideal when you want to transfer a large amount of display data to a screen quickly.","title":"Communication Protocols"},{"location":"10-displays/#basic-draw-functions","text":"For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function.","title":"Basic Draw Functions"},{"location":"10-displays/#initializing-the-framebuffer","text":"Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following:","title":"Initializing the Framebuffer"},{"location":"10-displays/#full-list-of-drawing-functions","text":"Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state is 0=off (black) and 1=on (white). Function Description Example blit fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x1, x2, y, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert invert the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel Draw a single point on the screen rect Draw an empty rectangle scroll Scroll the display text Write text at a point vline Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display Initialize the display write_cmd Write a command to the display show Update the display from the frame buffer poweroff poweron contrast write_data","title":"Full list of Drawing Functions"},{"location":"10-displays/#interfaces","text":"","title":"Interfaces"},{"location":"10-displays/#i2c","text":"Pros: Simple four wire interface Pin Purpose Description","title":"I2C"},{"location":"10-displays/#spi","text":"Example: 128X64 pixel monochrome displays","title":"SPI"},{"location":"10-displays/#types-of-displays","text":"","title":"Types of Displays"},{"location":"10-displays/#summary-table","text":"Display Type Cost Links Notes","title":"Summary Table"},{"location":"10-displays/#lcd","text":"","title":"LCD"},{"location":"10-displays/#oled","text":"","title":"OLED"},{"location":"10-displays/#tft-displays","text":"","title":"TFT Displays"},{"location":"10-displays/#references","text":"ST7735 Micropython Driver by Anthony Norman","title":"References"},{"location":"10-oled-bounce/","text":"OLED Bounce In this lesson, we will draw a box around the edge of the display using the commands that draw horizontal and vertical lines: hline and vline . Then we will draw a ball that bounces off these edges. Draw a border 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge oled . show () Make a Ball Bounce Around Inside the Wall 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 2 # start in the middle of the screen current_x = int ( width / 2 ) current_y = int ( height / 2 ) # start going down to the right direction_x = 1 direction_y = - 1 # delay_time = .0001 # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 2 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y","title":"OLED Bounce"},{"location":"10-oled-bounce/#oled-bounce","text":"In this lesson, we will draw a box around the edge of the display using the commands that draw horizontal and vertical lines: hline and vline . Then we will draw a ball that bounces off these edges.","title":"OLED Bounce"},{"location":"10-oled-bounce/#draw-a-border","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge oled . show ()","title":"Draw a border"},{"location":"10-oled-bounce/#make-a-ball-bounce-around-inside-the-wall","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 2 # start in the middle of the screen current_x = int ( width / 2 ) current_y = int ( height / 2 ) # start going down to the right direction_x = 1 direction_y = - 1 # delay_time = .0001 # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 2 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y","title":"Make a Ball Bounce Around Inside the Wall"},{"location":"11-oled-ping/","text":"OLED PING Circuit Coder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from machine import Pin , I2C , Timer from ssd1306 import SSD1306_I2C import utime # global toggle button variable measure_on = False # debounce for button def debounce ( pin ): timer . init ( mode = Timer . ONE_SHOT , period = 200 , callback = on_pressed ) # if button pressed, toggle measure_on def on_pressed ( timer ): global measure_on measure_on = not measure_on # Init button button = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) timer = Timer () button . irq ( debounce , Pin . IRQ_RISING ) # Init Display i2c = I2C ( 0 , sda = Pin ( 0 ), scl = Pin ( 1 ), freq = 40000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) # Init HC-SR04 pins trigger = Pin ( 14 , Pin . OUT ) echo = Pin ( 13 , Pin . IN ) def ultra (): trigger . low () utime . sleep_us ( 2 ) trigger . high () utime . sleep_us ( 5 ) trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance try : while True : oled . fill ( 0 ) if measure_on : result = ultra () oled . text ( \"Distance:\" , 0 , 0 ) oled . text ( str ( result ) + \" cm\" , 0 , 10 ) oled . show () utime . sleep ( 1 ) except KeyboardInterrupt : pass","title":"OLED Ping"},{"location":"11-oled-ping/#oled-ping","text":"","title":"OLED PING"},{"location":"11-oled-ping/#circuit","text":"","title":"Circuit"},{"location":"11-oled-ping/#coder","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from machine import Pin , I2C , Timer from ssd1306 import SSD1306_I2C import utime # global toggle button variable measure_on = False # debounce for button def debounce ( pin ): timer . init ( mode = Timer . ONE_SHOT , period = 200 , callback = on_pressed ) # if button pressed, toggle measure_on def on_pressed ( timer ): global measure_on measure_on = not measure_on # Init button button = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) timer = Timer () button . irq ( debounce , Pin . IRQ_RISING ) # Init Display i2c = I2C ( 0 , sda = Pin ( 0 ), scl = Pin ( 1 ), freq = 40000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) # Init HC-SR04 pins trigger = Pin ( 14 , Pin . OUT ) echo = Pin ( 13 , Pin . IN ) def ultra (): trigger . low () utime . sleep_us ( 2 ) trigger . high () utime . sleep_us ( 5 ) trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance try : while True : oled . fill ( 0 ) if measure_on : result = ultra () oled . text ( \"Distance:\" , 0 , 0 ) oled . text ( str ( result ) + \" cm\" , 0 , 10 ) oled . show () utime . sleep ( 1 ) except KeyboardInterrupt : pass","title":"Coder"},{"location":"11-oled-sh1106-i2c/","text":"OLED SSD1306 I2C Examples We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect via SPI. Just four wires: GND, VCC, Clock and Data. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. The first step is to find out what type of display graphics chip is used in your OLED. I2C Scanner Because your microcontroller might have multiple displays on it, their must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) returns: [60] SH1106 Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' ) Counter Example In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' ) Animated Box This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) ## note that we can only draw from 0 to 62 display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' ) Bounce on the SH1106 Display using I2C This example is a ball that bounces around the inside of a border rectangle. Is similar to other bounce examples with the exception that you can't draw on the last row of pixels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import machine import utime # from ssd1306 import SSD1306_I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 # we could make this be 63 but the init method should use the full value # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 5 current_x = int ( width / 2 ) current_y = int ( height / 2 ) direction_x = 1 direction_y = - 1 # delay_time = .0001 # oled.line(0, height-2, width-1, height-2, 1) # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 3 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y print ( 'done' )","title":"OLED SH1106 I2C Example"},{"location":"11-oled-sh1106-i2c/#oled-ssd1306-i2c-examples","text":"We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect via SPI. Just four wires: GND, VCC, Clock and Data. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. The first step is to find out what type of display graphics chip is used in your OLED.","title":"OLED SSD1306 I2C Examples"},{"location":"11-oled-sh1106-i2c/#i2c-scanner","text":"Because your microcontroller might have multiple displays on it, their must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) returns: [60]","title":"I2C Scanner"},{"location":"11-oled-sh1106-i2c/#sh1106-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' )","title":"SH1106 Example"},{"location":"11-oled-sh1106-i2c/#counter-example","text":"In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' )","title":"Counter Example"},{"location":"11-oled-sh1106-i2c/#animated-box","text":"This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) ## note that we can only draw from 0 to 62 display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' )","title":"Animated Box"},{"location":"11-oled-sh1106-i2c/#bounce-on-the-sh1106-display-using-i2c","text":"This example is a ball that bounces around the inside of a border rectangle. Is similar to other bounce examples with the exception that you can't draw on the last row of pixels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import machine import utime # from ssd1306 import SSD1306_I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 # we could make this be 63 but the init method should use the full value # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 5 current_x = int ( width / 2 ) current_y = int ( height / 2 ) direction_x = 1 direction_y = - 1 # delay_time = .0001 # oled.line(0, height-2, width-1, height-2, 1) # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 3 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y print ( 'done' )","title":"Bounce on the SH1106 Display using I2C"},{"location":"11-oled-ssd1306-i2c/","text":"OLED SSD1306 Examples We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect via SPI. Just four wires: GND, VCC, Clock and Data. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. The first step is to find out what type of display graphics chip is used in your OLED. I2C Scanner Because your microcontroller might have multiple displays on it, their must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) returns: [60] Using the SSD1306 with I2C Interfaces Add the ssd1306 Python Module You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command. I2C Hello World 1 2 3 4 5 6 7 8 9 10 11 import machine from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () print ( 'Done' ) After this program runs you should see the text on your OLED display. SH1106 Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' ) Counter Example In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' ) Animated Box This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' ) Install SSD1306 Module ssd1306 module SSD1306 Library - click the RAW button and then right click to do a \"Save As\" SSD1306 vs. SH1106 There is only one small difference between SSD1306 and SH1106: The SH1106 controller has an internal RAM of 132x64 pixel. The SSD1306 only has 128x64 pixel. The SPI interface The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy. SPI Baudrate https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__spi.html#ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display: CS - Chip Select - pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin Pico Pins 1 2 3 4 5 6 7 8 9 10 # Sample code sections 28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res SCK is the clock - hook this to the oled SCL MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 SPI0_SCK - pin 6 SPI0_MOSI - pin 7 SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO 1 2 3 spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4) SPI Terms Master Out Slave In (MOSI) We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4) Sample Nonworking SPI Code From the documentation: From spi is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. dc is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. res is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. cs is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import machine import machine import utime import ssd1306 led = machine . Pin ( 25 , machine . Pin . OUT ) # From: https://github.com/robert-hh/SH1106 # display = sh1106.SH1106_SPI(width, height, spi, dc, res, cs) #MOSI=machine.Pin(7) #SCK=machine.Pin(6) #spi = machine.SPI(0, baudrate=400000, sck=SCK, mosi=MOSI) spi_sck = machine . Pin ( 6 ) spi_tx = machine . Pin ( 7 ) # spi_rx=machine.Pin(4) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 8 ) DC = machine . Pin ( 9 ) RES = machine . Pin ( 10 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled . fill ( 1 ) oled . show () utime . sleep ( 0.5 ) oled . fill ( 0 ) oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) oled . show () # flash the LED to show end led . high () utime . sleep ( 0.5 ) led . low () print ( 'Done' ) References robert-hh's SH1106 Driver https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description Using I2C Defaults","title":"OLED SSD1306 I2C"},{"location":"11-oled-ssd1306-i2c/#oled-ssd1306-examples","text":"We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect via SPI. Just four wires: GND, VCC, Clock and Data. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. The first step is to find out what type of display graphics chip is used in your OLED.","title":"OLED SSD1306 Examples"},{"location":"11-oled-ssd1306-i2c/#i2c-scanner","text":"Because your microcontroller might have multiple displays on it, their must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) returns: [60]","title":"I2C Scanner"},{"location":"11-oled-ssd1306-i2c/#using-the-ssd1306-with-i2c-interfaces","text":"","title":"Using the SSD1306 with I2C Interfaces"},{"location":"11-oled-ssd1306-i2c/#add-the-ssd1306-python-module","text":"You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command.","title":"Add the ssd1306 Python Module"},{"location":"11-oled-ssd1306-i2c/#i2c-hello-world","text":"1 2 3 4 5 6 7 8 9 10 11 import machine from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () print ( 'Done' ) After this program runs you should see the text on your OLED display.","title":"I2C Hello World"},{"location":"11-oled-ssd1306-i2c/#sh1106-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' )","title":"SH1106 Example"},{"location":"11-oled-ssd1306-i2c/#counter-example","text":"In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' )","title":"Counter Example"},{"location":"11-oled-ssd1306-i2c/#animated-box","text":"This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' )","title":"Animated Box"},{"location":"11-oled-ssd1306-i2c/#install-ssd1306-module","text":"","title":"Install SSD1306 Module"},{"location":"11-oled-ssd1306-i2c/#ssd1306-module","text":"SSD1306 Library - click the RAW button and then right click to do a \"Save As\"","title":"ssd1306 module"},{"location":"11-oled-ssd1306-i2c/#ssd1306-vs-sh1106","text":"There is only one small difference between SSD1306 and SH1106: The SH1106 controller has an internal RAM of 132x64 pixel. The SSD1306 only has 128x64 pixel.","title":"SSD1306 vs. SH1106"},{"location":"11-oled-ssd1306-i2c/#the-spi-interface","text":"The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy.","title":"The SPI interface"},{"location":"11-oled-ssd1306-i2c/#spi-baudrate","text":"https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__spi.html#ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display: CS - Chip Select - pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin","title":"SPI Baudrate"},{"location":"11-oled-ssd1306-i2c/#pico-pins","text":"1 2 3 4 5 6 7 8 9 10 # Sample code sections 28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res SCK is the clock - hook this to the oled SCL MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 SPI0_SCK - pin 6 SPI0_MOSI - pin 7 SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO 1 2 3 spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4)","title":"Pico Pins"},{"location":"11-oled-ssd1306-i2c/#spi-terms","text":"Master Out Slave In (MOSI) We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4)","title":"SPI Terms"},{"location":"11-oled-ssd1306-i2c/#sample-nonworking-spi-code","text":"From the documentation: From spi is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. dc is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. res is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. cs is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import machine import machine import utime import ssd1306 led = machine . Pin ( 25 , machine . Pin . OUT ) # From: https://github.com/robert-hh/SH1106 # display = sh1106.SH1106_SPI(width, height, spi, dc, res, cs) #MOSI=machine.Pin(7) #SCK=machine.Pin(6) #spi = machine.SPI(0, baudrate=400000, sck=SCK, mosi=MOSI) spi_sck = machine . Pin ( 6 ) spi_tx = machine . Pin ( 7 ) # spi_rx=machine.Pin(4) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 8 ) DC = machine . Pin ( 9 ) RES = machine . Pin ( 10 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled . fill ( 1 ) oled . show () utime . sleep ( 0.5 ) oled . fill ( 0 ) oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) oled . show () # flash the LED to show end led . high () utime . sleep ( 0.5 ) led . low () print ( 'Done' )","title":"Sample Nonworking SPI Code"},{"location":"11-oled-ssd1306-i2c/#references","text":"robert-hh's SH1106 Driver https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description Using I2C Defaults","title":"References"},{"location":"11-oled-ssd1306-spi/","text":"OLED SSD1306 SPI Examples Using the SSD1306 with SPI Interfaces Add the ssd1306 Python Module You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command. Install SSD1306 Module ssd1306 module SSD1306 Library - click the RAW button and then right click to do a \"Save As\" SSD1306 Library Searchable The SPI interface The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy. Displaying SPI Defaults 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from machine import Pin from ssd1306 import SSD1306_SPI # default is data (MOSI) on GP7 and clock (sck) on GP6 spi = machine . SPI ( 0 ) print ( spi ) SPI ( 0 , baudrate = 992063 , polarity = 0 , phase = 0 , bits = 8 , sck = 6 , mosi = 7 , miso = 4 ) ### SPI Baudrate https : // raspberrypi . github . io / pico - sdk - doxygen / group__hardware__spi . html #ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display : ! []( img / oled - back - connections . png ) 1. CS - Chip Select - pin 4 2. DC - Data / Command - pin 5 3. RES - Reset - pin 6 4. SDA - Data - SPIO TX GP7 pin 10 5. SCL - Clock - Connect to SPIO SCK GP6 pin 9 6. VCC - Connect to the 3.3 V Out pin 36 7. GND - pin 38 or 3 any other GND pin ### Pico Pins Sample code sections 28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res 1 2 3 4 5 6 7 8 9 10 11 12 * SCK is the clock - hook this to the oled SCL * MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 1. SPI0_SCK - pin 6 2. SPI0_MOSI - pin 7 3. SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4) ## Sample Nonworking SPI Code From the documentation: !!! From Raspberry Pi Pico Documentation **spi** is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. **dc** is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. **res** is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. **cs** is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. ```py import machine import utime import ssd1306 led = machine.Pin(25, machine.Pin.OUT) spi_sck=machine.Pin(6) spi_tx=machine.Pin(7) # spi_rx=machine.Pin(4) spi=machine.SPI(0,baudrate=100000,sck=spi_sck, mosi=spi_tx) CS = machine.Pin(8) DC = machine.Pin(9) RES = machine.Pin(10) oled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS) # flash all pixels on oled.fill(1) oled.show() utime.sleep(0.5) oled.fill(0) oled.text('CoderDojo Rocks!', 0, 0, 1) oled.show() # flash the LED to show end led.high() utime.sleep(0.5) led.low() print('Done') References robert-hh's SH1106 Driver MicroPython SSD1306 Class https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description SSD1306 https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1306/ SSD1307 https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1307/","title":"OLED SSD1306 SPI V2"},{"location":"11-oled-ssd1306-spi/#oled-ssd1306-spi-examples","text":"","title":"OLED SSD1306 SPI Examples"},{"location":"11-oled-ssd1306-spi/#using-the-ssd1306-with-spi-interfaces","text":"","title":"Using the SSD1306 with SPI Interfaces"},{"location":"11-oled-ssd1306-spi/#add-the-ssd1306-python-module","text":"You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command.","title":"Add the ssd1306 Python Module"},{"location":"11-oled-ssd1306-spi/#install-ssd1306-module","text":"","title":"Install SSD1306 Module"},{"location":"11-oled-ssd1306-spi/#ssd1306-module","text":"SSD1306 Library - click the RAW button and then right click to do a \"Save As\" SSD1306 Library Searchable","title":"ssd1306 module"},{"location":"11-oled-ssd1306-spi/#the-spi-interface","text":"The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy.","title":"The SPI interface"},{"location":"11-oled-ssd1306-spi/#displaying-spi-defaults","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from machine import Pin from ssd1306 import SSD1306_SPI # default is data (MOSI) on GP7 and clock (sck) on GP6 spi = machine . SPI ( 0 ) print ( spi ) SPI ( 0 , baudrate = 992063 , polarity = 0 , phase = 0 , bits = 8 , sck = 6 , mosi = 7 , miso = 4 ) ### SPI Baudrate https : // raspberrypi . github . io / pico - sdk - doxygen / group__hardware__spi . html #ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display : ! []( img / oled - back - connections . png ) 1. CS - Chip Select - pin 4 2. DC - Data / Command - pin 5 3. RES - Reset - pin 6 4. SDA - Data - SPIO TX GP7 pin 10 5. SCL - Clock - Connect to SPIO SCK GP6 pin 9 6. VCC - Connect to the 3.3 V Out pin 36 7. GND - pin 38 or 3 any other GND pin ### Pico Pins","title":"Displaying SPI Defaults"},{"location":"11-oled-ssd1306-spi/#sample-code-sections","text":"28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res 1 2 3 4 5 6 7 8 9 10 11 12 * SCK is the clock - hook this to the oled SCL * MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 1. SPI0_SCK - pin 6 2. SPI0_MOSI - pin 7 3. SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4) ## Sample Nonworking SPI Code From the documentation: !!! From Raspberry Pi Pico Documentation **spi** is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. **dc** is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. **res** is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. **cs** is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. ```py import machine import utime import ssd1306 led = machine.Pin(25, machine.Pin.OUT) spi_sck=machine.Pin(6) spi_tx=machine.Pin(7) # spi_rx=machine.Pin(4) spi=machine.SPI(0,baudrate=100000,sck=spi_sck, mosi=spi_tx) CS = machine.Pin(8) DC = machine.Pin(9) RES = machine.Pin(10) oled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS) # flash all pixels on oled.fill(1) oled.show() utime.sleep(0.5) oled.fill(0) oled.text('CoderDojo Rocks!', 0, 0, 1) oled.show() # flash the LED to show end led.high() utime.sleep(0.5) led.low() print('Done')","title":"Sample code sections"},{"location":"11-oled-ssd1306-spi/#references","text":"robert-hh's SH1106 Driver MicroPython SSD1306 Class https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description","title":"References"},{"location":"11-oled-ssd1306-spi/#ssd1306","text":"https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1306/","title":"SSD1306"},{"location":"11-oled-ssd1306-spi/#ssd1307","text":"https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1307/","title":"SSD1307"},{"location":"11-pong/","text":"Pong Using a low-cost OLED device you can write a pong game. If you use a small 128X64 OLED the price can be around $12. Part list Part Name Price Link Description Raspberry Pi Pico $4 Microcenter With 264K RAM it has plenty of room for storing the framebuffer 1/2 Size Solderless Breadboard $2 link 400 tie breadboard 128X64 OLED $5 eBay You can also get larger 2.42\" displays for around $20 2 10K Potentiometers $1.5 each eBay You can purchase these in QTY 10 for less. Use the part number B10K to narrow your search. Clear Plastic Box $4 The Container Store Shallow Narrow Stackable Rectangle Clear with Lids 8-1/4\" x 3-1/2\" x 1-7/8\" h. The link is to the white lids. Raspberry Pi Pico for $4. OLED with I2C Interface. Note the pins are VCC, GND, SCL (clock), SDA (data). 1/2 size 400 connector solderless breadboard 10K potentiometer with pre-soldered connectors. You will need two of these. You can use a male-to-male header to connect it to the breadboard. Connections Connect the GND of the OLED to GND of the Pico Connect the VCC of the OLED to 3V3 OUT (physical pin 36) Connect the SDA (data) of the OLED to the Pico GP0 (physical pin 1 on the top left with USB up) Connect the SCL (clock) of the OLED to GP1 (physical pin 2) Connect the center tap of both potentiometers to ADC0 (GP26 - pin 31) and ADC1 (GP27 - pin 32) Connect the outer connectors of the potentiometers to VCC and GND Getting the Right Python Libraries To run this program, you will need a MicroPython display driver. Our display in this example is the popular SSD1306 driver chip. Your OLED might have a slightly different driver type. Here is the line that must be customized for your display: 1 from ssd1306 import SSD1306_I2C Testing the OLED This test will verify that your OLED connections are correct. 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show () Drawing the Border 1 2 3 4 5 def border(width, height): oled.hline(0, 0, width - 1, 1) # top edge oled.hline(0, height - 2, width - 1, 1) # bottom edge oled.vline(0, 0, height - 1, 1) # left edge oled.vline(width - 1, 0, height - 1, 1) # right edge YouTube Video","title":"OLED Pong"},{"location":"11-pong/#pong","text":"Using a low-cost OLED device you can write a pong game. If you use a small 128X64 OLED the price can be around $12.","title":"Pong"},{"location":"11-pong/#part-list","text":"Part Name Price Link Description Raspberry Pi Pico $4 Microcenter With 264K RAM it has plenty of room for storing the framebuffer 1/2 Size Solderless Breadboard $2 link 400 tie breadboard 128X64 OLED $5 eBay You can also get larger 2.42\" displays for around $20 2 10K Potentiometers $1.5 each eBay You can purchase these in QTY 10 for less. Use the part number B10K to narrow your search. Clear Plastic Box $4 The Container Store Shallow Narrow Stackable Rectangle Clear with Lids 8-1/4\" x 3-1/2\" x 1-7/8\" h. The link is to the white lids. Raspberry Pi Pico for $4. OLED with I2C Interface. Note the pins are VCC, GND, SCL (clock), SDA (data). 1/2 size 400 connector solderless breadboard 10K potentiometer with pre-soldered connectors. You will need two of these. You can use a male-to-male header to connect it to the breadboard.","title":"Part list"},{"location":"11-pong/#connections","text":"Connect the GND of the OLED to GND of the Pico Connect the VCC of the OLED to 3V3 OUT (physical pin 36) Connect the SDA (data) of the OLED to the Pico GP0 (physical pin 1 on the top left with USB up) Connect the SCL (clock) of the OLED to GP1 (physical pin 2) Connect the center tap of both potentiometers to ADC0 (GP26 - pin 31) and ADC1 (GP27 - pin 32) Connect the outer connectors of the potentiometers to VCC and GND","title":"Connections"},{"location":"11-pong/#getting-the-right-python-libraries","text":"To run this program, you will need a MicroPython display driver. Our display in this example is the popular SSD1306 driver chip. Your OLED might have a slightly different driver type. Here is the line that must be customized for your display: 1 from ssd1306 import SSD1306_I2C","title":"Getting the Right Python Libraries"},{"location":"11-pong/#testing-the-oled","text":"This test will verify that your OLED connections are correct. 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show ()","title":"Testing the OLED"},{"location":"11-pong/#drawing-the-border","text":"1 2 3 4 5 def border(width, height): oled.hline(0, 0, width - 1, 1) # top edge oled.hline(0, height - 2, width - 1, 1) # bottom edge oled.vline(0, 0, height - 1, 1) # left edge oled.vline(width - 1, 0, height - 1, 1) # right edge YouTube Video","title":"Drawing the Border"},{"location":"12-oled-pot/","text":"OLED Potentiometer Example In this lesson, we will use a potentiometer to change the value of an OLED display. We will use a small SSD1306 OLED with an I2C interface. A potentiometer has three wires. The two outside wires connect to GND and the 3.3 volt output. The center wire, called the \"tap\" wire will connect to the pin that converts an continuous analog voltage value into a digital number. Wikipedia Page on Potentiometer Circuit Diagram Sample Code Testing the POT Our first task is to find what pin to use for our first Analog to Digital concerter. GP26 is the same as ADC0. This is pin number 31 on the Pico. 1 2 3 4 5 6 import machine import utime pot = machine . ADC ( 26 ) while True : print ( pot . read_u16 ()) utime . sleep ( . 2 ) Sample 16 bit output A 16-bit integer can store 216 (or 65,536) distinct values. In an unsigned representation, these values are the integers between 0 and 65,535. So we are expecting numbers from 0 to 65,535. Sample results as we move the potentiometer from the minimum to the maximum values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 65535 52844 31047 7745 256 352 19140 41114 62239 65535 57277 33384 10114 352 288 19940 28086 Testing the OLED Getting the defaults 1 2 3 4 5 from machine import Pin , I2C # i2c=machine.I2C(0) i2c = machine . I2C ( 0 ) print ( \"Device found at decimal\" , i2c . scan ()) print ( i2c ) Results: This tells you the default pins and frequency that the I2C bus is running at. 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=9, sda=8) 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=1, sda=0) This tells us that the default pins are GP9 (row 12) for clock and GP8 (row 11) for data. 1 2 3 4 5 6 7 8 9 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show () Continuous Text Display on OLED 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 32 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) POT_PIN = machine . ADC ( 26 ) while True : oled . fill ( 0 ) oled . text ( POT_PIN . read_u16 ()) oled . show () utime . sleep ( . 2 ) Barchart and Text Display of Pot Value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import machine import utime import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) pot_pin = machine . ADC ( 26 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 half_height = int ( height / 2 ) # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a horizontal bar def draw_hbar ( inval , height , state ): oled . fill ( 0 ) # clear screen border ( width , height ) # draw a border oled . fill_rect ( 0 , 1 , inval , height , 1 ) # fill with 1 utime . sleep ( . 1 ) # wait a bit # continuous update while True : pot_val = int ( pot_pin . read_u16 ()) # the max value of the input is a 2^16 or 65536 pot_scaled = valmap ( pot_val , 0 , 65536 , 0 , 127 ) print ( pot_val , pot_scaled ) draw_hbar ( pot_scaled , half_height , 1 ) oled . text ( 'raw:' , 0 , half_height + 5 , 1 ) oled . text ( str ( pot_val ), 30 , half_height + 5 , 1 ) oled . text ( 'scaled:' , 0 , half_height + 15 , 1 ) oled . text ( str ( pot_scaled ), 60 , half_height + 15 , 1 ) oled . show () Gif of OLED","title":"OLED Pot"},{"location":"12-oled-pot/#oled-potentiometer-example","text":"In this lesson, we will use a potentiometer to change the value of an OLED display. We will use a small SSD1306 OLED with an I2C interface. A potentiometer has three wires. The two outside wires connect to GND and the 3.3 volt output. The center wire, called the \"tap\" wire will connect to the pin that converts an continuous analog voltage value into a digital number. Wikipedia Page on Potentiometer","title":"OLED Potentiometer Example"},{"location":"12-oled-pot/#circuit-diagram","text":"","title":"Circuit Diagram"},{"location":"12-oled-pot/#sample-code","text":"","title":"Sample Code"},{"location":"12-oled-pot/#testing-the-pot","text":"Our first task is to find what pin to use for our first Analog to Digital concerter. GP26 is the same as ADC0. This is pin number 31 on the Pico. 1 2 3 4 5 6 import machine import utime pot = machine . ADC ( 26 ) while True : print ( pot . read_u16 ()) utime . sleep ( . 2 )","title":"Testing the POT"},{"location":"12-oled-pot/#sample-16-bit-output","text":"A 16-bit integer can store 216 (or 65,536) distinct values. In an unsigned representation, these values are the integers between 0 and 65,535. So we are expecting numbers from 0 to 65,535. Sample results as we move the potentiometer from the minimum to the maximum values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 65535 52844 31047 7745 256 352 19140 41114 62239 65535 57277 33384 10114 352 288 19940 28086","title":"Sample 16 bit output"},{"location":"12-oled-pot/#testing-the-oled","text":"","title":"Testing the OLED"},{"location":"12-oled-pot/#getting-the-defaults","text":"1 2 3 4 5 from machine import Pin , I2C # i2c=machine.I2C(0) i2c = machine . I2C ( 0 ) print ( \"Device found at decimal\" , i2c . scan ()) print ( i2c ) Results: This tells you the default pins and frequency that the I2C bus is running at. 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=9, sda=8) 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=1, sda=0) This tells us that the default pins are GP9 (row 12) for clock and GP8 (row 11) for data. 1 2 3 4 5 6 7 8 9 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show ()","title":"Getting the defaults"},{"location":"12-oled-pot/#continuous-text-display-on-oled","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 32 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) POT_PIN = machine . ADC ( 26 ) while True : oled . fill ( 0 ) oled . text ( POT_PIN . read_u16 ()) oled . show () utime . sleep ( . 2 )","title":"Continuous Text Display on OLED"},{"location":"12-oled-pot/#barchart-and-text-display-of-pot-value","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import machine import utime import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) pot_pin = machine . ADC ( 26 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 half_height = int ( height / 2 ) # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a horizontal bar def draw_hbar ( inval , height , state ): oled . fill ( 0 ) # clear screen border ( width , height ) # draw a border oled . fill_rect ( 0 , 1 , inval , height , 1 ) # fill with 1 utime . sleep ( . 1 ) # wait a bit # continuous update while True : pot_val = int ( pot_pin . read_u16 ()) # the max value of the input is a 2^16 or 65536 pot_scaled = valmap ( pot_val , 0 , 65536 , 0 , 127 ) print ( pot_val , pot_scaled ) draw_hbar ( pot_scaled , half_height , 1 ) oled . text ( 'raw:' , 0 , half_height + 5 , 1 ) oled . text ( str ( pot_val ), 30 , half_height + 5 , 1 ) oled . text ( 'scaled:' , 0 , half_height + 15 , 1 ) oled . text ( str ( pot_scaled ), 60 , half_height + 15 , 1 ) oled . show ()","title":"Barchart and Text Display of Pot Value"},{"location":"12-oled-pot/#gif-of-oled","text":"","title":"Gif of OLED"},{"location":"12-oled-ssd1306-spi-v1/","text":"OLED SPI Demo This code was provide by Jim Tannenbaum (aka Jet) Image Code 1 2 3 4 5 6 7 8 9 10 11 12 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled.fill(0) oled . show () oled . text ( 'Hello Jet' , 0 , 0 , 1 ) oled . show ()","title":"OLED SSD1306 SPI V1"},{"location":"12-oled-ssd1306-spi-v1/#oled-spi-demo","text":"This code was provide by Jim Tannenbaum (aka Jet)","title":"OLED SPI Demo"},{"location":"12-oled-ssd1306-spi-v1/#image","text":"","title":"Image"},{"location":"12-oled-ssd1306-spi-v1/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled.fill(0) oled . show () oled . text ( 'Hello Jet' , 0 , 0 , 1 ) oled . show ()","title":"Code"},{"location":"27-ampy/","text":"","title":"Ampy"},{"location":"28-debugging-python/","text":"How to Debug Micropython Listing the Modules 1 help ( 'modules' ) Result: 1 2 3 4 5 6 7 8 9 10 __main__ gc uasyncio/funcs uos _boot machine uasyncio/lock urandom _onewire math uasyncio/stream ure _rp2 micropython ubinascii uselect _thread onewire ucollections ustruct _uasyncio rp2 uctypes usys builtins uasyncio/__init__ uhashlib utime ds18x20 uasyncio/core uio uzlib framebuf uasyncio/event ujson Plus any modules on the filesystem Micropython issues https://github.com/micropython/micropython/issues","title":"Debugging Python"},{"location":"28-debugging-python/#how-to-debug-micropython","text":"","title":"How to Debug Micropython"},{"location":"28-debugging-python/#listing-the-modules","text":"1 help ( 'modules' ) Result: 1 2 3 4 5 6 7 8 9 10 __main__ gc uasyncio/funcs uos _boot machine uasyncio/lock urandom _onewire math uasyncio/stream ure _rp2 micropython ubinascii uselect _thread onewire ucollections ustruct _uasyncio rp2 uctypes usys builtins uasyncio/__init__ uhashlib utime ds18x20 uasyncio/core uio uzlib framebuf uasyncio/event ujson Plus any modules on the filesystem","title":"Listing the Modules"},{"location":"28-debugging-python/#micropython-issues","text":"https://github.com/micropython/micropython/issues","title":"Micropython issues"},{"location":"29-debugging-spi/","text":"Debugging SPI In this lab we use a logic analyzer to debug the SPI protocol being used to drive a sample OLED device. We will be using the the 8 port Saleae Logic Analyser . The retail cost is about $399.00 although there are lower cost logic analyzer available. The SSD1306 SPI OLED Timing Diagram The OLED display is a read-only interface. It does not send any data back to the microcontroller, so there is no MOSI connection. The data is transmitted on the SDK line when the SCL line goes high. The CS line must be low for the OLED to be active. For details, see section 8.1.3 MCU Serial Interface on page 21 of the SSD1305 132 x 64 Dot Matrix OLED/PLED Segment/Common Driver with Controller . OLED SPI settings Our OLED device has seven wires. In addition to power and ground there a five data connections we will be observing on our logic analyzer. CS - Chip Select pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 (Data from the ) SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin Setting up a Logic Analyzer Setup SPI Analyser Configure SPI Channel Settings Saleae Logic Analyser SPI Logic Analyser Settings Check a Working Device The first thing we want to see is what the signals to a working SPI OLED should be. There are plenty of working drivers for the Arduino, so I hooked one up to the Logic analizer to see what they were. Viewing Data Clock and RES All five signals DC and CS signals have a larger period. DC on was 3.668 milliseconds Clock Period Our Clock (SCL) has 8 positive pulses with a width of .4167 microseconds. This means that the positve/negative combined width has a period of 2 * .4167 = .8333 microseconds. This can be converted into a frequency of 1.2 megahertz. References Video on how to use the Saleae Logic Analizer https://www.youtube.com/watch?v=Ak9R4yxQPhs","title":"Debugging SPI"},{"location":"29-debugging-spi/#debugging-spi","text":"In this lab we use a logic analyzer to debug the SPI protocol being used to drive a sample OLED device. We will be using the the 8 port Saleae Logic Analyser . The retail cost is about $399.00 although there are lower cost logic analyzer available.","title":"Debugging SPI"},{"location":"29-debugging-spi/#the-ssd1306-spi-oled-timing-diagram","text":"The OLED display is a read-only interface. It does not send any data back to the microcontroller, so there is no MOSI connection. The data is transmitted on the SDK line when the SCL line goes high. The CS line must be low for the OLED to be active. For details, see section 8.1.3 MCU Serial Interface on page 21 of the SSD1305 132 x 64 Dot Matrix OLED/PLED Segment/Common Driver with Controller .","title":"The SSD1306 SPI OLED Timing Diagram"},{"location":"29-debugging-spi/#oled-spi-settings","text":"Our OLED device has seven wires. In addition to power and ground there a five data connections we will be observing on our logic analyzer. CS - Chip Select pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 (Data from the ) SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin","title":"OLED SPI settings"},{"location":"29-debugging-spi/#setting-up-a-logic-analyzer","text":"","title":"Setting up a Logic Analyzer"},{"location":"29-debugging-spi/#setup-spi-analyser","text":"","title":"Setup SPI Analyser"},{"location":"29-debugging-spi/#configure-spi-channel-settings","text":"Saleae Logic Analyser SPI Logic Analyser Settings","title":"Configure SPI Channel Settings"},{"location":"29-debugging-spi/#check-a-working-device","text":"The first thing we want to see is what the signals to a working SPI OLED should be. There are plenty of working drivers for the Arduino, so I hooked one up to the Logic analizer to see what they were.","title":"Check a Working Device"},{"location":"29-debugging-spi/#viewing-data-clock-and-res","text":"All five signals DC and CS signals have a larger period. DC on was 3.668 milliseconds","title":"Viewing Data Clock and RES"},{"location":"29-debugging-spi/#clock-period","text":"Our Clock (SCL) has 8 positive pulses with a width of .4167 microseconds. This means that the positve/negative combined width has a period of 2 * .4167 = .8333 microseconds. This can be converted into a frequency of 1.2 megahertz.","title":"Clock Period"},{"location":"29-debugging-spi/#references","text":"Video on how to use the Saleae Logic Analizer https://www.youtube.com/watch?v=Ak9R4yxQPhs","title":"References"},{"location":"29-references/","text":"Micropython References http://micropython.org/ - home site of the micropython project https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Meet Raspberry Silicon: Raspberry Pi Pico now on sale at $4 - Raspberry Pi Pico announcement The journey to Raspberry Silicon - blog by Liam Fraser - Feb. 8th 2021. Nice story of how the Raspberry Pi Foundation created the custom silicon chip. TensorFlow Lite Micro for the Pico Pico Invaders Video 2.42\" OLED Display from DIY More","title":"References"},{"location":"29-references/#micropython-references","text":"http://micropython.org/ - home site of the micropython project https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Meet Raspberry Silicon: Raspberry Pi Pico now on sale at $4 - Raspberry Pi Pico announcement The journey to Raspberry Silicon - blog by Liam Fraser - Feb. 8th 2021. Nice story of how the Raspberry Pi Foundation created the custom silicon chip. TensorFlow Lite Micro for the Pico Pico Invaders Video 2.42\" OLED Display from DIY More","title":"Micropython References"},{"location":"29a-debugging-i2c/","text":"Debugging I2C Bus","title":"Debugging I2C"},{"location":"29a-debugging-i2c/#debugging-i2c-bus","text":"","title":"Debugging I2C Bus"},{"location":"30-colophon/","text":"Colophone We are mostly a group of unpaid volunteers without a large budget for distributed content management software. However, we still want to provide a great user experience for both our mentors and our students. So we use free open-source tools whenever we can. Here is how we built this site. Our content language is Markdown . We use Python Markdown to parse our content. We convert Markdown to HTML with mkdocs . Our user interface theme is Mkdocs Material . We use an extensive number of Material user interface components. Our software version control system is git Our site is hosted on GitHub page . We use standard code highlighting provided by the mkdocs codehilite extension. Our BY-NC-SA content license agreement is created by Creative Commons We wish to acknowledge the work of everyone that contributes to open-source projects. Without these systems this work would not be possible. If you would like to contribute lesson we welcome your contribution as a git pull request. You can read our CoderDojo Twin CitiesAuthoring Guide if you would like to help out.","title":"Colophon"},{"location":"30-colophon/#colophone","text":"We are mostly a group of unpaid volunteers without a large budget for distributed content management software. However, we still want to provide a great user experience for both our mentors and our students. So we use free open-source tools whenever we can. Here is how we built this site. Our content language is Markdown . We use Python Markdown to parse our content. We convert Markdown to HTML with mkdocs . Our user interface theme is Mkdocs Material . We use an extensive number of Material user interface components. Our software version control system is git Our site is hosted on GitHub page . We use standard code highlighting provided by the mkdocs codehilite extension. Our BY-NC-SA content license agreement is created by Creative Commons We wish to acknowledge the work of everyone that contributes to open-source projects. Without these systems this work would not be possible. If you would like to contribute lesson we welcome your contribution as a git pull request. You can read our CoderDojo Twin CitiesAuthoring Guide if you would like to help out.","title":"Colophone"},{"location":"40-gpt-outliner/","text":"GPT Outliner GPT Promt 1 2 3 4 5 Create an outline for a course on microcontroller programming with Micropython for 9th-grade students. The students should have an interest in computers and be able to use a computer keyboard including copy/cut and paste commands. 1. Introduction 2. Setting up your Python environment 3. Blink an LED GPT Response 1 2 3 4 5 6 7 8 9 10 4. Reading analog inputs 4. Servos 5. LED strips 7. Buttons 8. Sound 9. Temperature sensors 10. Light sensing 11. Accelerometers 12. Motion sensors 13. Gesture sensors","title":"Content Outliner"},{"location":"40-gpt-outliner/#gpt-outliner","text":"","title":"GPT Outliner"},{"location":"40-gpt-outliner/#gpt-promt","text":"1 2 3 4 5 Create an outline for a course on microcontroller programming with Micropython for 9th-grade students. The students should have an interest in computers and be able to use a computer keyboard including copy/cut and paste commands. 1. Introduction 2. Setting up your Python environment 3. Blink an LED","title":"GPT Promt"},{"location":"40-gpt-outliner/#gpt-response","text":"1 2 3 4 5 6 7 8 9 10 4. Reading analog inputs 4. Servos 5. LED strips 7. Buttons 8. Sound 9. Temperature sensors 10. Light sensing 11. Accelerometers 12. Motion sensors 13. Gesture sensors","title":"GPT Response"},{"location":"contact/","text":"Cybersecurity for Kids Contacts General Code Savvy Contact kidscode@codesavvy.org Contact for CoderDojo Twin Cities hello@coderdojotc.org Specific questions on this repository Dan McCreary","title":"Contact"},{"location":"contact/#cybersecurity-for-kids-contacts","text":"","title":"Cybersecurity for Kids Contacts"},{"location":"contact/#general-code-savvy-contact","text":"kidscode@codesavvy.org","title":"General Code Savvy Contact"},{"location":"contact/#contact-for-coderdojo-twin-cities","text":"hello@coderdojotc.org","title":"Contact for CoderDojo Twin Cities"},{"location":"contact/#specific-questions-on-this-repository","text":"Dan McCreary","title":"Specific questions on this repository"},{"location":"glossary/","text":"Micropython Glossary of Terms Ampy A micropython command line utility to interact with a CircuitPython or MicroPython board over a serial connection. Ampy is meant to be a simple command line tool to manipulate files and run code on a CircuitPython or MicroPython board over its serial connection. With ampy you can send files from your computer to the board's file system, download files from a board to your computer, and even send a Python script to a board to be executed. Note that ampy by design is meant to be simple and does not support advanced interaction like a shell or terminal to send input to a board. Check out other MicroPython tools like rshell or mpfshell for more advanced interaction with boards. Analog to Digital Converter A component that takes an analogue signal and changes it to a digital one. Every ADC has two parameters, its resolution , measured in digital bits, and its channels , or how many analogue signals it can accept and convert at once. Also know as: ADC BOOTSEL A button on the pico that when pressed during power up will allow you to mount the device as a USB device. Also known as: Boot Selection Castellated Edge Plated through holes or vias located in the edges of a printed circuit board that make it easier to solder onto another circuit board. The word \"Castellated\" means having grooves or slots on an edge and is derived from the turrets of a castle. ESP32 A series of low-cost, low-power system on a chip microcontrollers with integrated Wi-Fi and dual-mode Bluetooth. Typical costs for the ESP32 is Sample on eBay $5 Sample on Amazon $11 Sample on Sparkfun $21 ESP32 Quick Reference Framebuffer A region of your microcontroller RAM that stores a bitmap image of your display. For a 128X64 monochrome display this would be 128 * 64 = 8,192 bits or 1,024 bytes (1K). Color displays must store up to 8 bytes per color for each color (red, green and blue). Wikipedia page on Framebuffer I2C A communications protocol common in microcontroller-based systems, particularly for interfacing with sensors, memory devices and liquid crystal displays. I2C is similar to SPI, it's a synchronous protocol because it uses a clock line. Also Known as: Inter-integrated Circuit See also: SPI Micropython A set of Python libraries and tools developed specifically for microcontrollers. Micropython was originally developed by Damien George and first released in 2014. It includes many of the features of mainstream Python, while adding a range of new ones designed to take advantage of the facilities available on Raspberry Pi Pico and other microcontroller boards like the ESP32. See also: CircuitPython MPG Shell A simple micropython shell based file explorer for ESP8266 and WiPy Micropython based devices. The shell is a helper for up/downloading files to the ESP8266 (over serial line and Websockets) and WiPy (serial line and telnet). It basically offers commands to list and upload/download files on the flash FS of the device. GitHub Repo for MPFShell OLED Organic polymer light emitting diode. Raspberry Pi Foundation The company that builds the Raspberry Pi hardware and provides some software. Raspberry Pi Pico A microcontroller designed by the Raspberry Pi foundation for doing real-time control systems. The Pico was introduces in 2020 with a retail list price of $4. It was a key development because it used a custom chip that had 100 times the RAM of an Arduino Nano. Pico Pinout The Pico pinout has Pinout PDF RP2040 chip A custom chip created by the Raspberry Pi Foundation to power the Raspberry Pi Pico . rshell A simple micropython shell which runs on the host and uses MicroPython's raw-REPL to send python snippets to the pyboard in order to get filesystem information, and to copy files to and from MicroPython's filesystem. It also has the ability to invoke the regular REPL, so rshell can be used as a terminal emulator as well. Note: With rshell you can disable USB Mass Storage and still copy files into and out of your pyboard. RShell GitHub Repo SPI An interface bus commonly used to send data between microcontrollers and small peripherals such as sensors, displays and SD cards. SPI uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Also known as: Serial Peripheral Interface See also: I2C Thonny A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny runs on Mac, Windows and Linux. Thonny web site UF2 File The file that must be uploaded into the Raspberry Pi Pico folder to allow it to be used. The file name format looks like this: rp2-pico-20210205-unstable-v1.14-8-g1f800cac3.uf2 Unicorn MicroPython on Unicorn is completely open source Micropython emulator Github Repo: https://github.com/micropython/micropython-unicorn","title":"Glossary"},{"location":"glossary/#micropython-glossary-of-terms","text":"","title":"Micropython Glossary of Terms"},{"location":"glossary/#ampy","text":"A micropython command line utility to interact with a CircuitPython or MicroPython board over a serial connection. Ampy is meant to be a simple command line tool to manipulate files and run code on a CircuitPython or MicroPython board over its serial connection. With ampy you can send files from your computer to the board's file system, download files from a board to your computer, and even send a Python script to a board to be executed. Note that ampy by design is meant to be simple and does not support advanced interaction like a shell or terminal to send input to a board. Check out other MicroPython tools like rshell or mpfshell for more advanced interaction with boards.","title":"Ampy"},{"location":"glossary/#analog-to-digital-converter","text":"A component that takes an analogue signal and changes it to a digital one. Every ADC has two parameters, its resolution , measured in digital bits, and its channels , or how many analogue signals it can accept and convert at once. Also know as: ADC","title":"Analog to Digital Converter"},{"location":"glossary/#bootsel","text":"A button on the pico that when pressed during power up will allow you to mount the device as a USB device. Also known as: Boot Selection","title":"BOOTSEL"},{"location":"glossary/#castellated-edge","text":"Plated through holes or vias located in the edges of a printed circuit board that make it easier to solder onto another circuit board. The word \"Castellated\" means having grooves or slots on an edge and is derived from the turrets of a castle.","title":"Castellated Edge"},{"location":"glossary/#esp32","text":"A series of low-cost, low-power system on a chip microcontrollers with integrated Wi-Fi and dual-mode Bluetooth. Typical costs for the ESP32 is Sample on eBay $5 Sample on Amazon $11 Sample on Sparkfun $21 ESP32 Quick Reference","title":"ESP32"},{"location":"glossary/#framebuffer","text":"A region of your microcontroller RAM that stores a bitmap image of your display. For a 128X64 monochrome display this would be 128 * 64 = 8,192 bits or 1,024 bytes (1K). Color displays must store up to 8 bytes per color for each color (red, green and blue). Wikipedia page on Framebuffer","title":"Framebuffer"},{"location":"glossary/#i2c","text":"A communications protocol common in microcontroller-based systems, particularly for interfacing with sensors, memory devices and liquid crystal displays. I2C is similar to SPI, it's a synchronous protocol because it uses a clock line. Also Known as: Inter-integrated Circuit See also: SPI","title":"I2C"},{"location":"glossary/#micropython","text":"A set of Python libraries and tools developed specifically for microcontrollers. Micropython was originally developed by Damien George and first released in 2014. It includes many of the features of mainstream Python, while adding a range of new ones designed to take advantage of the facilities available on Raspberry Pi Pico and other microcontroller boards like the ESP32. See also: CircuitPython","title":"Micropython"},{"location":"glossary/#mpg-shell","text":"A simple micropython shell based file explorer for ESP8266 and WiPy Micropython based devices. The shell is a helper for up/downloading files to the ESP8266 (over serial line and Websockets) and WiPy (serial line and telnet). It basically offers commands to list and upload/download files on the flash FS of the device. GitHub Repo for MPFShell","title":"MPG Shell"},{"location":"glossary/#oled","text":"Organic polymer light emitting diode.","title":"OLED"},{"location":"glossary/#raspberry-pi-foundation","text":"The company that builds the Raspberry Pi hardware and provides some software.","title":"Raspberry Pi Foundation"},{"location":"glossary/#raspberry-pi-pico","text":"A microcontroller designed by the Raspberry Pi foundation for doing real-time control systems. The Pico was introduces in 2020 with a retail list price of $4. It was a key development because it used a custom chip that had 100 times the RAM of an Arduino Nano.","title":"Raspberry Pi Pico"},{"location":"glossary/#pico-pinout","text":"The Pico pinout has Pinout PDF","title":"Pico Pinout"},{"location":"glossary/#rp2040-chip","text":"A custom chip created by the Raspberry Pi Foundation to power the Raspberry Pi Pico .","title":"RP2040 chip"},{"location":"glossary/#rshell","text":"A simple micropython shell which runs on the host and uses MicroPython's raw-REPL to send python snippets to the pyboard in order to get filesystem information, and to copy files to and from MicroPython's filesystem. It also has the ability to invoke the regular REPL, so rshell can be used as a terminal emulator as well. Note: With rshell you can disable USB Mass Storage and still copy files into and out of your pyboard. RShell GitHub Repo","title":"rshell"},{"location":"glossary/#spi","text":"An interface bus commonly used to send data between microcontrollers and small peripherals such as sensors, displays and SD cards. SPI uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Also known as: Serial Peripheral Interface See also: I2C","title":"SPI"},{"location":"glossary/#thonny","text":"A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny runs on Mac, Windows and Linux. Thonny web site","title":"Thonny"},{"location":"glossary/#uf2-file","text":"The file that must be uploaded into the Raspberry Pi Pico folder to allow it to be used. The file name format looks like this: rp2-pico-20210205-unstable-v1.14-8-g1f800cac3.uf2","title":"UF2 File"},{"location":"glossary/#unicorn","text":"MicroPython on Unicorn is completely open source Micropython emulator Github Repo: https://github.com/micropython/micropython-unicorn","title":"Unicorn"},{"location":"circuit-python/01-intro/","text":"Introduction to CircuitPython A fork of MicroPython done by Adafruit Done for \"simplicity\" but does not support multiple cores They have lots of drivers The code is generally incompatble with MicroPython It might be useful for testing devices where the MicroPython drivers do not work Setting up a CircuitPython Environment 1 2 conda create -n circuitpython python = 3 conda activate circuitpython Installing the SSD1306 CircuitPython Library Per Directions Here 1 pip3 install adafruit-circuitpython-ssd1306 1 pip3 install adafruit-circuitpython-displayio-ssd1306 Note ERROR: Could not find a version that satisfies the requirement adafruit-circuitpython-displayio-ssd1306 ERROR: No matching distribution found for adafruit-circuitpython-displayio-ssd1306 1 Successfully installed Adafruit-Blinka-6.3.2 Adafruit-PlatformDetect-3.2.0 Adafruit-PureIO-1.1.8 adafruit-circuitpython-busdevice-5.0.6 adafruit-circuitpython-framebuf-1.4.6 adafruit-circuitpython-ssd1306-2.11.1 pyftdi-0.52.9 pyserial-3.5 pyusb-1.1.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Basic example of clearing and drawing pixels on a SSD1306 OLED display. # This example and library is meant to work with Adafruit CircuitPython API. # Author: Tony DiCola # License: Public Domain # Import all board pins. from board import SCL , SDA import busio # Import the SSD1306 module. import adafruit_ssd1306 # Create the I2C interface. i2c = busio . I2C ( SCL , SDA ) # Create the SSD1306 OLED class. # The first two parameters are the pixel width and pixel height. Change these # to the right size for your display! display = adafruit_ssd1306 . SSD1306_I2C ( 128 , 32 , i2c ) # Alternatively you can change the I2C address of the device with an addr parameter: #display = adafruit_ssd1306.SSD1306_I2C(128, 32, i2c, addr=0x31) # Clear the display. Always call show after changing pixels to make the display # update visible! display . fill ( 0 ) display . show () # Set a pixel in the origin 0,0 position. display . pixel ( 0 , 0 , 1 ) # Set a pixel in the middle 64, 16 position. display . pixel ( 64 , 16 , 1 ) # Set a pixel in the opposite 127, 31 position. display . pixel ( 127 , 31 , 1 ) display . show ()","title":"Introduction to CircuitPython"},{"location":"circuit-python/01-intro/#introduction-to-circuitpython","text":"A fork of MicroPython done by Adafruit Done for \"simplicity\" but does not support multiple cores They have lots of drivers The code is generally incompatble with MicroPython It might be useful for testing devices where the MicroPython drivers do not work","title":"Introduction to CircuitPython"},{"location":"circuit-python/01-intro/#setting-up-a-circuitpython-environment","text":"1 2 conda create -n circuitpython python = 3 conda activate circuitpython","title":"Setting up a CircuitPython Environment"},{"location":"circuit-python/01-intro/#installing-the-ssd1306-circuitpython-library","text":"Per Directions Here 1 pip3 install adafruit-circuitpython-ssd1306 1 pip3 install adafruit-circuitpython-displayio-ssd1306 Note ERROR: Could not find a version that satisfies the requirement adafruit-circuitpython-displayio-ssd1306 ERROR: No matching distribution found for adafruit-circuitpython-displayio-ssd1306 1 Successfully installed Adafruit-Blinka-6.3.2 Adafruit-PlatformDetect-3.2.0 Adafruit-PureIO-1.1.8 adafruit-circuitpython-busdevice-5.0.6 adafruit-circuitpython-framebuf-1.4.6 adafruit-circuitpython-ssd1306-2.11.1 pyftdi-0.52.9 pyserial-3.5 pyusb-1.1.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Basic example of clearing and drawing pixels on a SSD1306 OLED display. # This example and library is meant to work with Adafruit CircuitPython API. # Author: Tony DiCola # License: Public Domain # Import all board pins. from board import SCL , SDA import busio # Import the SSD1306 module. import adafruit_ssd1306 # Create the I2C interface. i2c = busio . I2C ( SCL , SDA ) # Create the SSD1306 OLED class. # The first two parameters are the pixel width and pixel height. Change these # to the right size for your display! display = adafruit_ssd1306 . SSD1306_I2C ( 128 , 32 , i2c ) # Alternatively you can change the I2C address of the device with an addr parameter: #display = adafruit_ssd1306.SSD1306_I2C(128, 32, i2c, addr=0x31) # Clear the display. Always call show after changing pixels to make the display # update visible! display . fill ( 0 ) display . show () # Set a pixel in the origin 0,0 position. display . pixel ( 0 , 0 , 1 ) # Set a pixel in the middle 64, 16 position. display . pixel ( 64 , 16 , 1 ) # Set a pixel in the opposite 127, 31 position. display . pixel ( 127 , 31 , 1 ) display . show ()","title":"Installing the SSD1306 CircuitPython Library"}]}