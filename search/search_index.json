{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoderDojo Twin Cities Micropython This website and GitHub repository is for sharing teaching resources to teach MicroPython to students in 5th to 12th grades (10-18 years old). The course assumes that either a mentor, teacher or students have access to at least one microcontroller such as the $4 Raspberry Pi Pico or the $10 ESP32. Students should also have access to some low-cost sensors (buttons, potentiometers, ultrasonic distance sensor) and displays such as LEDs or OLED displays. All the content on this website is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike . This means if your preserve the attribution and license you can use the content for free in your classrooms and modify and extend the curriculum to meet your needs. However, you can not charge your students additional feeds for the content or resell the content. If you are looking for a specific topic, please remember to use the search function in the upper right of the website. The website is best displayed on a wide screen to seen the left navigation bar on the left although the website also works on the small screens of mobile phones and tablets. Course Outline You can use the navigation area on the left side panel to navigate to different parts of the website. Here is a high-level overview of the main sections of the site. Part I: Introduction to MicroPython This part is a high-level overview of what MicroPython is and why is has become the most popular way to do physical computing, program microcontrollers and build robots. We also discuss the different types of microcontrollers available, their price and features and how to purchase them independently or in kits. Introduction - Overview of Micropython and why we love it. Boards - Description of popular development boards that support MicroPython (Pico and ESP32). How to choose the right microcontroller for your project. Raspberry Pi Pico - Details the Raspberry Pi Pico including features and pinouts. Part II: Getting Started This part will help you get started programming MicroPython on your microcontroller and learn how to hookup parts on a solderless breadboard. We discuss the need for a desktop Integrated Development Environment (IDE) and how to get starting writing simple programs Thonny IDE - Thonny is an IDE that supports MicroPython. We review the parts of the User interface. [Breadboards] Blink - Blink an LED on and off. This is the equivalent of the \"Hello World!\" program in micropython. Basic Foundation Introductory Lessons These ten lessons are the foundations for learning micropython. They include learning how to blink one or more LEDs, monitor to button presses, fade LEDs in and out using PWM signals, read analog values from potentiometers, read light sensors, turn motors and servos and display rainbow patterns on a NeoPixel strip. Button - see how a button can control the LED. Servo - Move a Servo. Part 3: Sensors Sensors Intro Displays Displays We cover simple displays that don't have complex drawing. For those we have a separate chapter. Part 4: Sound and Music Sound and Music Infro Part 5: OLED Displays OLED Displays Part 6: Robots Robots Part 7: Advanced Topics Advanced Topics Reference Material Glossary of Micropython Terms Contact Micropython References - links to other useful sites.","title":"MicroPython Home"},{"location":"#coderdojo-twin-cities-micropython","text":"This website and GitHub repository is for sharing teaching resources to teach MicroPython to students in 5th to 12th grades (10-18 years old). The course assumes that either a mentor, teacher or students have access to at least one microcontroller such as the $4 Raspberry Pi Pico or the $10 ESP32. Students should also have access to some low-cost sensors (buttons, potentiometers, ultrasonic distance sensor) and displays such as LEDs or OLED displays. All the content on this website is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike . This means if your preserve the attribution and license you can use the content for free in your classrooms and modify and extend the curriculum to meet your needs. However, you can not charge your students additional feeds for the content or resell the content. If you are looking for a specific topic, please remember to use the search function in the upper right of the website. The website is best displayed on a wide screen to seen the left navigation bar on the left although the website also works on the small screens of mobile phones and tablets.","title":"CoderDojo Twin Cities Micropython"},{"location":"#course-outline","text":"You can use the navigation area on the left side panel to navigate to different parts of the website. Here is a high-level overview of the main sections of the site.","title":"Course Outline"},{"location":"#part-i-introduction-to-micropython","text":"This part is a high-level overview of what MicroPython is and why is has become the most popular way to do physical computing, program microcontrollers and build robots. We also discuss the different types of microcontrollers available, their price and features and how to purchase them independently or in kits. Introduction - Overview of Micropython and why we love it. Boards - Description of popular development boards that support MicroPython (Pico and ESP32). How to choose the right microcontroller for your project. Raspberry Pi Pico - Details the Raspberry Pi Pico including features and pinouts.","title":"Part I: Introduction to MicroPython"},{"location":"#part-ii-getting-started","text":"This part will help you get started programming MicroPython on your microcontroller and learn how to hookup parts on a solderless breadboard. We discuss the need for a desktop Integrated Development Environment (IDE) and how to get starting writing simple programs Thonny IDE - Thonny is an IDE that supports MicroPython. We review the parts of the User interface. [Breadboards] Blink - Blink an LED on and off. This is the equivalent of the \"Hello World!\" program in micropython.","title":"Part II: Getting Started"},{"location":"#basic-foundation-introductory-lessons","text":"These ten lessons are the foundations for learning micropython. They include learning how to blink one or more LEDs, monitor to button presses, fade LEDs in and out using PWM signals, read analog values from potentiometers, read light sensors, turn motors and servos and display rainbow patterns on a NeoPixel strip. Button - see how a button can control the LED. Servo - Move a Servo.","title":"Basic Foundation Introductory Lessons"},{"location":"#part-3-sensors","text":"Sensors Intro","title":"Part 3: Sensors"},{"location":"#displays","text":"Displays We cover simple displays that don't have complex drawing. For those we have a separate chapter.","title":"Displays"},{"location":"#part-4-sound-and-music","text":"Sound and Music Infro","title":"Part 4: Sound and Music"},{"location":"#part-5-oled-displays","text":"OLED Displays","title":"Part 5: OLED Displays"},{"location":"#part-6-robots","text":"Robots","title":"Part 6: Robots"},{"location":"#part-7-advanced-topics","text":"Advanced Topics","title":"Part 7: Advanced Topics"},{"location":"#reference-material","text":"Glossary of Micropython Terms Contact Micropython References - links to other useful sites.","title":"Reference Material"},{"location":"advanced-labs/01-intro/","text":"Advanced Labs This section includes some advanced topics that might be useful for helping you create and debug MicroPython projects. Topics include: Writing Interrupt Handlers Monitoring the internal temperature of your RP2040 CPU Timing the speed of functions for performance optimization Setting up a Conda virtual Python development environment Using operating system functions such as listing files on the file system Scanning for I2C devices Using a framebuffer Using the minicom tool to move files to and from you PC from your microcontroller Reading files from a SD card Converting CircuitPython code and drivers to MicroPython","title":"Introduction"},{"location":"advanced-labs/01-intro/#advanced-labs","text":"This section includes some advanced topics that might be useful for helping you create and debug MicroPython projects. Topics include: Writing Interrupt Handlers Monitoring the internal temperature of your RP2040 CPU Timing the speed of functions for performance optimization Setting up a Conda virtual Python development environment Using operating system functions such as listing files on the file system Scanning for I2C devices Using a framebuffer Using the minicom tool to move files to and from you PC from your microcontroller Reading files from a SD card Converting CircuitPython code and drivers to MicroPython","title":"Advanced Labs"},{"location":"advanced-labs/02-interrupt-handlers/","text":"Interrupt Handlers in MicroPython What is an Interrupt Handler? An Interrupt Handler (also called an ISR for Interrupt Service Request) is a special Python function that is called when specific events occur such as a button being pressed. ISRs are the preferred way to detect external events, as opposed to polling methods that are inconsistent and inefficient. However, they are a bit tricky to setup and debug. So a good design should be as simple as possible and avoid using complex features unless you really know you need them. Polling vs. Interrupt Handlers So why are ISRs so important? Let's illustrate this is a story. Imagine you have 10 friends each with a button at their home. In the polling method you would need to drive to each of their houses and ask them \"Is the button get pressed\"? You would have to do this frequently in case the button was pressed and released too quickly. This is a slow and painful process and takes a lot of CPU cycles. An interrupt handler on the other hand has each friend tell you directly if their button has been pressed. The messages are quick and efficient. They don't use a lot of extra CPU power and the results get handled quickly. However, there are specific rules about what we can and can't do within an ISR function. They need to be quick and efficient. We can't wonder off and do crazy things like printing debugging lines within a good ISR. Our job is typically update a global value and finish ASAP. A good ISR should be as efficient as possible. Simple Button Press ISR Example This is our first ISR example. It has several parts: import statements - (pretty standard but we have to add the import micropython) global variables - we will update these to communicate the result of our ISR the callback function - this is the function will be automatically called on a pin event the button defintion - this is where we indicate what pin and the PULL_DOWN value the irq handler - this is where we associate the event with the callback function the main loop - here we only print the button press count if it has changed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Use an interrupt function count the number of times a button has been pressed from machine import Pin import micropython import time # global value button_pressed_count = 0 # Interrupt Service Routine for Button Pressed Events - with no debounce def button1_pressed ( change ): global button_pressed_count button_pressed_count += 1 # we define button1 as being connected to GP14 and to use the internal Pico PULL_DOWN resistor button1 = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) # here is how we associate the falling value on the input pin with the callback function button1 . irq ( handler = button1_pressed , trigger = Pin . IRQ_FALLING ) button_pressed_count_old = 0 while True : if button_pressed_count_old != button_pressed_count : print ( 'Button 1 value:' , button_pressed_count ) button_pressed_count_old = button_pressed_count Now if you run this program, you will see that it prints to the Terminal each time the button is pressed and it also tells us how many times the button has been pressed. example output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Button 1 value: 1 Button 1 value: 2 Button 1 value: 3 Button 1 value: 4 Button 1 value: 5 Button 1 value: 6 Button 1 value: 8 Button 1 value: 9 Button 1 value: 10 Button 1 value: 11 Button 1 value: 12 Button 1 value: 13 Button 1 value: 14 Button 1 value: 15 Button 1 value: 16 Button 1 value: 17 Button 1 value: 18 Button 1 value: 19 Button 1 value: 20 Button 1 value: 21 But if you are careful, you will note something slightly unexpected might happen. I the example above, I actually only pressed the button about 10 times. But the button value is 21! What could be going on here? Could there be a bug in the code? The answer is that buttons are not perfect on/off switches. They are essentially noisy on/off devices that may go through a transition of off/on/off/on each time we press the button. As a switch goes from open to closed, it moves from a stable state, through an unstable transition state and then it finally arrives at a new stable state. This is illustrated in the drawing below. We can reduce this \"noise\" with a small capacitor next to the button. The capacitor will quickly absorb the energy of the button transition and it will \"smooth\" out the spikes. This will give us a more consistent readout of the number of button presses and avoid accidental \"double presses\" that were not intended. However, we can also get a clean signal by using software. The key is when we first detect that a transition may be happening we \"stop listening\" for a short period of time until we are confident that the unstable transition state is over. This is typically around 20 milliseconds, but there may be a few stray signals left. Since we may not have to detect changes more frequently than 5 presses per second, we can go to sleep in our ISR for up to 200 milliseconds. This will give us a nice stable reading from the button. These are general rules but for our breadboard mounted momentary switches, the values are appropriate. Debounced Version of a Button Press Detection Now let's show you the code that does the hard work of debouncing a signal from a button or switch. In this example, our ISR is called button_pressed_handler(pin) . As soon as it is called, it checks the number of milliseconds since it was last called. If the time difference is under 200 milliseconds we are good to go and we update the button_presses global variable. If we are under the 200 millisecond window, we might be in that transition state and we don't do anything. 1 2 3 4 5 new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : button_presses += 1 last_time = new_time The net effect is that the presses variable will ONLY be incremented once, and not multiple times during the transition. Here is the full code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import utime from machine import Pin # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler button_presses = 0 # the count of times the button has been pressed last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # the lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail button_pin = machine . Pin ( 14 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # this function gets called every time the button is pressed def button_pressed_handler ( pin ): global button_presses , last_time new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : button_presses += 1 last_time = new_time # now we register the handler function when the button is pressed button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # This is for only printing when a new button press count value happens old_presses = 0 while True : # only print on change in the button_presses value if button_presses != old_presses : print ( button_presses ) builtin_led . toggle () old_presses = button_presses ISR with Deactivation Although there are benefits to the simplicity of the code above, some microcontrollers developers suggest that you simply deactivate the IRQ during the debounce sleep. This makes sense since there is two small calculation of the time differences (a subtraction and a compare operation) that do not need to be performed. The key lines we add are a deactivate of the IRQ, a sleep for 200 milliseconds and a re-enable of the IRQ after the sleep. Both approaches have worked for me and I will let you decide the tradeoffs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import machine , utime # the lower right coner has a wire that goes throuh count_input = machine . Pin ( 14 , machine . Pin . IN , machine . Pin . PULL_DOWN ) presses = 0 def count_handler ( pin ): global presses # disable the IRQ during our debounce check count_input . irq ( handler = None ) presses += 1 # debounce time - we ignore any activity diring this period utime . sleep_ms ( 200 ) # re-enable the IRQ count_input . irq ( trigger = machine . Pin . IRQ_FALLING , handler = count_handler ) count_input . irq ( trigger = machine . Pin . IRQ_FALLING , handler = count_handler ) old_presses = 0 while True : # only print on change if presses != old_presses : if presses > old_presses + 1 : print ( 'double counting in irq. Fixing...' ) presses = old_presses + 1 print ( presses ) old_presses = presses Debounce Without Disabling the IRQ References MicroPython Documentation on Interrupt Handlers A Guide to Debouncing by Jack G. Ganssle - this is an excellent reference if you want to know how long to set the debounce intervals for various types of switches. It has lots of transition plots and shows the incredible variation in transition states of switches. In the Summary of the final page, Jack suggest that most low-cost switch denouncers should use a debounce period of between 20 and 50 milliseconds if the users want a fast response.","title":"Interrupt Handlers"},{"location":"advanced-labs/02-interrupt-handlers/#interrupt-handlers-in-micropython","text":"","title":"Interrupt Handlers in MicroPython"},{"location":"advanced-labs/02-interrupt-handlers/#what-is-an-interrupt-handler","text":"An Interrupt Handler (also called an ISR for Interrupt Service Request) is a special Python function that is called when specific events occur such as a button being pressed. ISRs are the preferred way to detect external events, as opposed to polling methods that are inconsistent and inefficient. However, they are a bit tricky to setup and debug. So a good design should be as simple as possible and avoid using complex features unless you really know you need them.","title":"What is an Interrupt Handler?"},{"location":"advanced-labs/02-interrupt-handlers/#polling-vs-interrupt-handlers","text":"So why are ISRs so important? Let's illustrate this is a story. Imagine you have 10 friends each with a button at their home. In the polling method you would need to drive to each of their houses and ask them \"Is the button get pressed\"? You would have to do this frequently in case the button was pressed and released too quickly. This is a slow and painful process and takes a lot of CPU cycles. An interrupt handler on the other hand has each friend tell you directly if their button has been pressed. The messages are quick and efficient. They don't use a lot of extra CPU power and the results get handled quickly. However, there are specific rules about what we can and can't do within an ISR function. They need to be quick and efficient. We can't wonder off and do crazy things like printing debugging lines within a good ISR. Our job is typically update a global value and finish ASAP. A good ISR should be as efficient as possible.","title":"Polling vs. Interrupt Handlers"},{"location":"advanced-labs/02-interrupt-handlers/#simple-button-press-isr-example","text":"This is our first ISR example. It has several parts: import statements - (pretty standard but we have to add the import micropython) global variables - we will update these to communicate the result of our ISR the callback function - this is the function will be automatically called on a pin event the button defintion - this is where we indicate what pin and the PULL_DOWN value the irq handler - this is where we associate the event with the callback function the main loop - here we only print the button press count if it has changed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Use an interrupt function count the number of times a button has been pressed from machine import Pin import micropython import time # global value button_pressed_count = 0 # Interrupt Service Routine for Button Pressed Events - with no debounce def button1_pressed ( change ): global button_pressed_count button_pressed_count += 1 # we define button1 as being connected to GP14 and to use the internal Pico PULL_DOWN resistor button1 = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) # here is how we associate the falling value on the input pin with the callback function button1 . irq ( handler = button1_pressed , trigger = Pin . IRQ_FALLING ) button_pressed_count_old = 0 while True : if button_pressed_count_old != button_pressed_count : print ( 'Button 1 value:' , button_pressed_count ) button_pressed_count_old = button_pressed_count Now if you run this program, you will see that it prints to the Terminal each time the button is pressed and it also tells us how many times the button has been pressed. example output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Button 1 value: 1 Button 1 value: 2 Button 1 value: 3 Button 1 value: 4 Button 1 value: 5 Button 1 value: 6 Button 1 value: 8 Button 1 value: 9 Button 1 value: 10 Button 1 value: 11 Button 1 value: 12 Button 1 value: 13 Button 1 value: 14 Button 1 value: 15 Button 1 value: 16 Button 1 value: 17 Button 1 value: 18 Button 1 value: 19 Button 1 value: 20 Button 1 value: 21 But if you are careful, you will note something slightly unexpected might happen. I the example above, I actually only pressed the button about 10 times. But the button value is 21! What could be going on here? Could there be a bug in the code? The answer is that buttons are not perfect on/off switches. They are essentially noisy on/off devices that may go through a transition of off/on/off/on each time we press the button. As a switch goes from open to closed, it moves from a stable state, through an unstable transition state and then it finally arrives at a new stable state. This is illustrated in the drawing below. We can reduce this \"noise\" with a small capacitor next to the button. The capacitor will quickly absorb the energy of the button transition and it will \"smooth\" out the spikes. This will give us a more consistent readout of the number of button presses and avoid accidental \"double presses\" that were not intended. However, we can also get a clean signal by using software. The key is when we first detect that a transition may be happening we \"stop listening\" for a short period of time until we are confident that the unstable transition state is over. This is typically around 20 milliseconds, but there may be a few stray signals left. Since we may not have to detect changes more frequently than 5 presses per second, we can go to sleep in our ISR for up to 200 milliseconds. This will give us a nice stable reading from the button. These are general rules but for our breadboard mounted momentary switches, the values are appropriate.","title":"Simple Button Press ISR Example"},{"location":"advanced-labs/02-interrupt-handlers/#debounced-version-of-a-button-press-detection","text":"Now let's show you the code that does the hard work of debouncing a signal from a button or switch. In this example, our ISR is called button_pressed_handler(pin) . As soon as it is called, it checks the number of milliseconds since it was last called. If the time difference is under 200 milliseconds we are good to go and we update the button_presses global variable. If we are under the 200 millisecond window, we might be in that transition state and we don't do anything. 1 2 3 4 5 new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : button_presses += 1 last_time = new_time The net effect is that the presses variable will ONLY be incremented once, and not multiple times during the transition. Here is the full code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import utime from machine import Pin # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler button_presses = 0 # the count of times the button has been pressed last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # the lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail button_pin = machine . Pin ( 14 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # this function gets called every time the button is pressed def button_pressed_handler ( pin ): global button_presses , last_time new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : button_presses += 1 last_time = new_time # now we register the handler function when the button is pressed button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # This is for only printing when a new button press count value happens old_presses = 0 while True : # only print on change in the button_presses value if button_presses != old_presses : print ( button_presses ) builtin_led . toggle () old_presses = button_presses","title":"Debounced Version of a Button Press Detection"},{"location":"advanced-labs/02-interrupt-handlers/#isr-with-deactivation","text":"Although there are benefits to the simplicity of the code above, some microcontrollers developers suggest that you simply deactivate the IRQ during the debounce sleep. This makes sense since there is two small calculation of the time differences (a subtraction and a compare operation) that do not need to be performed. The key lines we add are a deactivate of the IRQ, a sleep for 200 milliseconds and a re-enable of the IRQ after the sleep. Both approaches have worked for me and I will let you decide the tradeoffs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import machine , utime # the lower right coner has a wire that goes throuh count_input = machine . Pin ( 14 , machine . Pin . IN , machine . Pin . PULL_DOWN ) presses = 0 def count_handler ( pin ): global presses # disable the IRQ during our debounce check count_input . irq ( handler = None ) presses += 1 # debounce time - we ignore any activity diring this period utime . sleep_ms ( 200 ) # re-enable the IRQ count_input . irq ( trigger = machine . Pin . IRQ_FALLING , handler = count_handler ) count_input . irq ( trigger = machine . Pin . IRQ_FALLING , handler = count_handler ) old_presses = 0 while True : # only print on change if presses != old_presses : if presses > old_presses + 1 : print ( 'double counting in irq. Fixing...' ) presses = old_presses + 1 print ( presses ) old_presses = presses","title":"ISR with Deactivation"},{"location":"advanced-labs/02-interrupt-handlers/#debounce-without-disabling-the-irq","text":"","title":"Debounce Without Disabling the IRQ"},{"location":"advanced-labs/02-interrupt-handlers/#references","text":"MicroPython Documentation on Interrupt Handlers A Guide to Debouncing by Jack G. Ganssle - this is an excellent reference if you want to know how long to set the debounce intervals for various types of switches. It has lots of transition plots and shows the incredible variation in transition states of switches. In the Summary of the final page, Jack suggest that most low-cost switch denouncers should use a debounce period of between 20 and 50 milliseconds if the users want a fast response.","title":"References"},{"location":"advanced-labs/03-internal-temperature/","text":"Using the Builtin Temperature Sensor The Raspberry Pi Pico has an internal temperature sensor that can be access using machine.ADC(4) . This might be useful to see if your RP2040 CPY is running \"hot\" and might benefit from a cooling fan. Reading the temperature 1 2 3 4 5 6 7 8 import machine import utime sensor_temp = machine . ADC ( 4 ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 print ( temperature ) print ( ' \\n ' ) Logging the Temperature 1 2 3 4 5 6 7 8 9 10 11 import machine import utime sensor_temp = machine . ADC ( machine . ADC . CORE_TEMP ) conversion_factor = 3.3 / ( 65535 ) file = open ( \"temps.txt\" , \"w\" ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 file . write ( str ( temperature )) file . flush () utime . sleep ( 10 )","title":"Internal Temperature"},{"location":"advanced-labs/03-internal-temperature/#using-the-builtin-temperature-sensor","text":"The Raspberry Pi Pico has an internal temperature sensor that can be access using machine.ADC(4) . This might be useful to see if your RP2040 CPY is running \"hot\" and might benefit from a cooling fan.","title":"Using the Builtin Temperature Sensor"},{"location":"advanced-labs/03-internal-temperature/#reading-the-temperature","text":"1 2 3 4 5 6 7 8 import machine import utime sensor_temp = machine . ADC ( 4 ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 print ( temperature ) print ( ' \\n ' )","title":"Reading the temperature"},{"location":"advanced-labs/03-internal-temperature/#logging-the-temperature","text":"1 2 3 4 5 6 7 8 9 10 11 import machine import utime sensor_temp = machine . ADC ( machine . ADC . CORE_TEMP ) conversion_factor = 3.3 / ( 65535 ) file = open ( \"temps.txt\" , \"w\" ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 file . write ( str ( temperature )) file . flush () utime . sleep ( 10 )","title":"Logging the Temperature"},{"location":"advanced-labs/03-timing-functions/","text":"Timing Functions We often need to calculate how much time has elapsed since an event occurred. To to this we can use the ticks functions in the MicroPython utime library. Microsecond Timer There are one million microseconds in a single second. The utime library allows us to count the number of microseconds that have elapsed since the processor was powered up. The following example times the sleep function and measures the difference in the number of clock ticks in microseconds between the two events. 1 2 3 4 5 6 7 8 9 10 11 12 import machine , utime start_time = utime . ticks_us () # sleep for 1 second utime . sleep ( 1 ) end_time = utime . ticks_us () while True : print ( \"Start Time:\" , start_time ) print ( \"End Time:\" , end_time ) print ( \"Delta Time:\" , end_time - start_time ) print ( \"\" ) results: 1 2 3 4 5 6 7 Start Time: 403122147 End Time: 404122241 Delta Time: 1000094 Start Time: 403122147 End Time: 404122241 Delta Time: 1000096 You will note that the difference between the start and end time should be one million microseconds. However, the run-time libraries on the pico have some variability, so you will see the actual time vary by a few microseconds. Most of the time you can use milliseconds to compare time intervals. Millisecond Timer 1 2 3 4 5 6 7 8 9 10 11 import machine , utime start_time = utime . ticks_ms () utime . sleep ( 1 ) end_time = utime . ticks_ms () while True : print ( \"Start Time:\" , start_time ) print ( \"End Time:\" , end_time ) print ( \"Delta Time:\" , end_time - start_time ) print ( \"\" ) results: 1 2 3 4 5 6 7 Start Time: 855845 End Time: 856845 Delta Time: 1000 Start Time: 858031 End Time: 859032 Delta Time: 1001 These results are almost always 1000 with an occasional 1001 value.","title":"Timing Functions"},{"location":"advanced-labs/03-timing-functions/#timing-functions","text":"We often need to calculate how much time has elapsed since an event occurred. To to this we can use the ticks functions in the MicroPython utime library.","title":"Timing Functions"},{"location":"advanced-labs/03-timing-functions/#microsecond-timer","text":"There are one million microseconds in a single second. The utime library allows us to count the number of microseconds that have elapsed since the processor was powered up. The following example times the sleep function and measures the difference in the number of clock ticks in microseconds between the two events. 1 2 3 4 5 6 7 8 9 10 11 12 import machine , utime start_time = utime . ticks_us () # sleep for 1 second utime . sleep ( 1 ) end_time = utime . ticks_us () while True : print ( \"Start Time:\" , start_time ) print ( \"End Time:\" , end_time ) print ( \"Delta Time:\" , end_time - start_time ) print ( \"\" ) results: 1 2 3 4 5 6 7 Start Time: 403122147 End Time: 404122241 Delta Time: 1000094 Start Time: 403122147 End Time: 404122241 Delta Time: 1000096 You will note that the difference between the start and end time should be one million microseconds. However, the run-time libraries on the pico have some variability, so you will see the actual time vary by a few microseconds. Most of the time you can use milliseconds to compare time intervals.","title":"Microsecond Timer"},{"location":"advanced-labs/03-timing-functions/#millisecond-timer","text":"1 2 3 4 5 6 7 8 9 10 11 import machine , utime start_time = utime . ticks_ms () utime . sleep ( 1 ) end_time = utime . ticks_ms () while True : print ( \"Start Time:\" , start_time ) print ( \"End Time:\" , end_time ) print ( \"Delta Time:\" , end_time - start_time ) print ( \"\" ) results: 1 2 3 4 5 6 7 Start Time: 855845 End Time: 856845 Delta Time: 1000 Start Time: 858031 End Time: 859032 Delta Time: 1001 These results are almost always 1000 with an occasional 1001 value.","title":"Millisecond Timer"},{"location":"advanced-labs/04-conda-env/","text":"Creating a Conda Environment for MicroPython Conda is a powerful tool for building consistent and stable Python environments. These environments include all the Python libraries that you need to be a productive MicroPython developer. Using Conda allows you to keep each of your Python projects cleanly separated. This may not be important on your 2nd or 3rd Python project, but as you do more Python projects you will benefit from isolated environments that each have their own versions of each Python libraries that will not conflict with each other. One other important fact to remember is that if you use a conda virtual environment you should never need to use sudo (root) to install Python libraries. This means your installation scripts are more secure and less likely to introduce security problems and accidentally remove libraries that other projects depend on. Getting Started To get started, it is best to go directly to the Conda web site and follow the installation instructions for you specific version of your operating system. There are many variations of installation not just for Windows, Mac and Linux, but each version my had different steps required. Once you can open a terminal and type in conda --version you have successfully installed Conda. For this document we have used conda: 1 conda --version which returns: 1 conda 4.10.1 Creating Your Conda Environment Our fist job is to create a desktop environment that allows us to run Python programs that support the MicroPython development process. 1 conda create -n micropython python = 3 1 conda activate micropython After this your prompt should now show that you are in the micropython environment. This process may take about five minutes, since all the most current libraries must be downloaded onto your desktop. Once this process finsihes you must remember to deactivate your current conda environment (if you have one and then activate your new micropython environment. References Raspberry Pi Pico Forum on MicroPython Site MicroPython Pico Forum MicroPython PyCopy (pycopy) MicroPython PyCopy","title":"Conda Environment Setup"},{"location":"advanced-labs/04-conda-env/#creating-a-conda-environment-for-micropython","text":"Conda is a powerful tool for building consistent and stable Python environments. These environments include all the Python libraries that you need to be a productive MicroPython developer. Using Conda allows you to keep each of your Python projects cleanly separated. This may not be important on your 2nd or 3rd Python project, but as you do more Python projects you will benefit from isolated environments that each have their own versions of each Python libraries that will not conflict with each other. One other important fact to remember is that if you use a conda virtual environment you should never need to use sudo (root) to install Python libraries. This means your installation scripts are more secure and less likely to introduce security problems and accidentally remove libraries that other projects depend on.","title":"Creating a Conda Environment for MicroPython"},{"location":"advanced-labs/04-conda-env/#getting-started","text":"To get started, it is best to go directly to the Conda web site and follow the installation instructions for you specific version of your operating system. There are many variations of installation not just for Windows, Mac and Linux, but each version my had different steps required. Once you can open a terminal and type in conda --version you have successfully installed Conda. For this document we have used conda: 1 conda --version which returns: 1 conda 4.10.1","title":"Getting Started"},{"location":"advanced-labs/04-conda-env/#creating-your-conda-environment","text":"Our fist job is to create a desktop environment that allows us to run Python programs that support the MicroPython development process. 1 conda create -n micropython python = 3 1 conda activate micropython After this your prompt should now show that you are in the micropython environment. This process may take about five minutes, since all the most current libraries must be downloaded onto your desktop. Once this process finsihes you must remember to deactivate your current conda environment (if you have one and then activate your new micropython environment.","title":"Creating Your Conda Environment"},{"location":"advanced-labs/04-conda-env/#references","text":"","title":"References"},{"location":"advanced-labs/04-conda-env/#raspberry-pi-pico-forum-on-micropython-site","text":"MicroPython Pico Forum","title":"Raspberry Pi Pico Forum on MicroPython Site"},{"location":"advanced-labs/04-conda-env/#micropython-pycopy-pycopy","text":"MicroPython PyCopy","title":"MicroPython PyCopy (pycopy)"},{"location":"advanced-labs/05-os-functions/","text":"Raspberry Pi Pico OS Functions In the Thonny tool, open the Terminal. At the REPL prompt type: help() which returns 1 help () returns 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 Welcome to MicroPython! For online help please visit https://micropython.org/help/. For access to the hardware use the 'machine' module. RP2 specific commands are in the 'rp2' module. Quick overview of some objects: machine.Pin(pin) -- get a pin, eg machine.Pin(0) machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p methods: init(..), value([v]), high(), low(), irq(handler) machine.ADC(pin) -- make an analog object from a pin methods: read_u16() machine.PWM(pin) -- make a PWM object from a pin methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d]) machine.I2C(id) -- create an I2C object (id=0,1) methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True) readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg) machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1) methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf) machine.Timer(freq, callback) -- create a software timer object eg: machine.Timer(freq=1, callback=lambda t:print(t)) Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Useful control commands: CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') followed by help(modules) 1 2 3 4 5 6 7 8 9 10 11 help ( 'modules' ) __main__ gc uasyncio / funcs uos _boot machine uasyncio / lock urandom _onewire math uasyncio / stream ure _rp2 micropython ubinascii uselect _thread onewire ucollections ustruct _uasyncio rp2 uctypes usys builtins uarray uerrno utime cmath uasyncio / __init__ uhashlib uzlib ds18x20 uasyncio / core uio framebuf uasyncio / event ujson OS Functions 1 2 import os print ( dir ( os )) returns 1 ['__class__', '__name__', 'remove', 'VfsFat', 'VfsLfs2', 'chdir', 'getcwd', 'ilistdir', 'listdir', 'mkdir', 'mount', 'rename', 'rmdir', 'stat', 'statvfs', 'umount', 'uname', 'urandom'] Real Time Clock 1 2 3 4 5 from machine import RTC rtc = RTC () rtc . datetime (( 2017 , 8 , 23 , 2 , 12 , 48 , 0 , 0 )) # set a specific date and time rtc . datetime () # get date and time See MicroPython Real Time Clock","title":"OS Functions"},{"location":"advanced-labs/05-os-functions/#raspberry-pi-pico-os-functions","text":"In the Thonny tool, open the Terminal. At the REPL prompt type: help() which returns 1 help () returns 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 Welcome to MicroPython! For online help please visit https://micropython.org/help/. For access to the hardware use the 'machine' module. RP2 specific commands are in the 'rp2' module. Quick overview of some objects: machine.Pin(pin) -- get a pin, eg machine.Pin(0) machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p methods: init(..), value([v]), high(), low(), irq(handler) machine.ADC(pin) -- make an analog object from a pin methods: read_u16() machine.PWM(pin) -- make a PWM object from a pin methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d]) machine.I2C(id) -- create an I2C object (id=0,1) methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True) readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg) machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1) methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf) machine.Timer(freq, callback) -- create a software timer object eg: machine.Timer(freq=1, callback=lambda t:print(t)) Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Useful control commands: CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') followed by help(modules) 1 2 3 4 5 6 7 8 9 10 11 help ( 'modules' ) __main__ gc uasyncio / funcs uos _boot machine uasyncio / lock urandom _onewire math uasyncio / stream ure _rp2 micropython ubinascii uselect _thread onewire ucollections ustruct _uasyncio rp2 uctypes usys builtins uarray uerrno utime cmath uasyncio / __init__ uhashlib uzlib ds18x20 uasyncio / core uio framebuf uasyncio / event ujson","title":"Raspberry Pi Pico OS Functions"},{"location":"advanced-labs/05-os-functions/#os-functions","text":"1 2 import os print ( dir ( os )) returns 1 ['__class__', '__name__', 'remove', 'VfsFat', 'VfsLfs2', 'chdir', 'getcwd', 'ilistdir', 'listdir', 'mkdir', 'mount', 'rename', 'rmdir', 'stat', 'statvfs', 'umount', 'uname', 'urandom']","title":"OS Functions"},{"location":"advanced-labs/05-os-functions/#real-time-clock","text":"1 2 3 4 5 from machine import RTC rtc = RTC () rtc . datetime (( 2017 , 8 , 23 , 2 , 12 , 48 , 0 , 0 )) # set a specific date and time rtc . datetime () # get date and time See MicroPython Real Time Clock","title":"Real Time Clock"},{"location":"advanced-labs/06-i2c/","text":"Raspberry Pi Pico I2C The Pico has two I2C hardware controllers. Each controller can talk to multiple IIC devices as long as all the devices communicating on each controller have distinct addresses. I2C0 SDA are on GPIOs 0, 4, 8, 12, 16 and 20 I2C0 SCL are on GPIOs 1, 5, 9, 13, 17 and 21 I2C1 SDA are on GIPOs 2, 6, 10, 14, 18 and 26 I2C1 SCL are on GIPOs 3, 7, 11, 15, 19 and 27 I2C Scanner for I2C 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import machine I2C_SDA_PIN = 0 I2C_SCL_PIN = 1 i2c = machine . I2C ( 0 , sda = machine . Pin ( I2C_SDA_PIN ), scl = machine . Pin ( I2C_SCL_PIN ), freq = 400000 ) print ( 'Scanning I2C bus.' ) devices = i2c . scan () # this returns a list of devices device_count = len ( devices ) if device_count == 0 : print ( 'No i2c device found.' ) else : print ( device_count , 'devices found.' ) for device in devices : print ( 'Decimal address:' , device , \", Hex address: \" , hex ( device )) I2C Scanner for Both I2C 0 and 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import machine I2C0_SDA_PIN = 0 I2C0_SCL_PIN = 1 I2C1_SDA_PIN = 2 I2C1_SCL_PIN = 3 i2c0 = machine . I2C ( 0 , sda = machine . Pin ( I2C0_SDA_PIN ), scl = machine . Pin ( I2C0_SCL_PIN ), freq = 400000 ) i2c1 = machine . I2C ( 1 , sda = machine . Pin ( I2C1_SDA_PIN ), scl = machine . Pin ( I2C1_SCL_PIN ), freq = 400000 ) print ( 'Scanning I2C bus 0.' ) devices = i2c0 . scan () # this returns a list of devices device_count = len ( devices ) if device_count == 0 : print ( 'No i2c device found on bus 0.' ) else : print ( device_count , 'devices found.' ) for device in devices : print ( 'Decimal address:' , device , \", Hex address: \" , hex ( device )) print ( 'Scanning I2C bus 1.' ) devices = i2c1 . scan () # this returns a list of devices device_count = len ( devices ) if device_count == 0 : print ( 'No i2c device found on bus 1.' ) else : print ( device_count , 'devices found.' ) for device in devices : print ( 'Decimal address:' , device , \", Hex address: \" , hex ( device )) Results for both a OLED display on I2C 0 and a time-of-flight sensor on I2C 1 1 2 3 4 5 6 Scanning I2C bus 0. 1 devices found. Decimal address: 60 , Hex address: 0x3c Scanning I2C bus 1. 1 devices found. Decimal address: 41 , Hex address: 0x29 References Article on Hackster.io","title":"I2C Scanner"},{"location":"advanced-labs/06-i2c/#raspberry-pi-pico-i2c","text":"The Pico has two I2C hardware controllers. Each controller can talk to multiple IIC devices as long as all the devices communicating on each controller have distinct addresses. I2C0 SDA are on GPIOs 0, 4, 8, 12, 16 and 20 I2C0 SCL are on GPIOs 1, 5, 9, 13, 17 and 21 I2C1 SDA are on GIPOs 2, 6, 10, 14, 18 and 26 I2C1 SCL are on GIPOs 3, 7, 11, 15, 19 and 27","title":"Raspberry Pi Pico I2C"},{"location":"advanced-labs/06-i2c/#i2c-scanner-for-i2c-0","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import machine I2C_SDA_PIN = 0 I2C_SCL_PIN = 1 i2c = machine . I2C ( 0 , sda = machine . Pin ( I2C_SDA_PIN ), scl = machine . Pin ( I2C_SCL_PIN ), freq = 400000 ) print ( 'Scanning I2C bus.' ) devices = i2c . scan () # this returns a list of devices device_count = len ( devices ) if device_count == 0 : print ( 'No i2c device found.' ) else : print ( device_count , 'devices found.' ) for device in devices : print ( 'Decimal address:' , device , \", Hex address: \" , hex ( device ))","title":"I2C Scanner for I2C 0"},{"location":"advanced-labs/06-i2c/#i2c-scanner-for-both-i2c-0-and-1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import machine I2C0_SDA_PIN = 0 I2C0_SCL_PIN = 1 I2C1_SDA_PIN = 2 I2C1_SCL_PIN = 3 i2c0 = machine . I2C ( 0 , sda = machine . Pin ( I2C0_SDA_PIN ), scl = machine . Pin ( I2C0_SCL_PIN ), freq = 400000 ) i2c1 = machine . I2C ( 1 , sda = machine . Pin ( I2C1_SDA_PIN ), scl = machine . Pin ( I2C1_SCL_PIN ), freq = 400000 ) print ( 'Scanning I2C bus 0.' ) devices = i2c0 . scan () # this returns a list of devices device_count = len ( devices ) if device_count == 0 : print ( 'No i2c device found on bus 0.' ) else : print ( device_count , 'devices found.' ) for device in devices : print ( 'Decimal address:' , device , \", Hex address: \" , hex ( device )) print ( 'Scanning I2C bus 1.' ) devices = i2c1 . scan () # this returns a list of devices device_count = len ( devices ) if device_count == 0 : print ( 'No i2c device found on bus 1.' ) else : print ( device_count , 'devices found.' ) for device in devices : print ( 'Decimal address:' , device , \", Hex address: \" , hex ( device )) Results for both a OLED display on I2C 0 and a time-of-flight sensor on I2C 1 1 2 3 4 5 6 Scanning I2C bus 0. 1 devices found. Decimal address: 60 , Hex address: 0x3c Scanning I2C bus 1. 1 devices found. Decimal address: 41 , Hex address: 0x29","title":"I2C Scanner for Both I2C 0 and 1"},{"location":"advanced-labs/06-i2c/#references","text":"Article on Hackster.io","title":"References"},{"location":"advanced-labs/07-framebuffer/","text":"Framebuffers in MicroPython References MicroPython.org docs on framebuf","title":"Frame Buffer"},{"location":"advanced-labs/07-framebuffer/#framebuffers-in-micropython","text":"","title":"Framebuffers in MicroPython"},{"location":"advanced-labs/07-framebuffer/#references","text":"MicroPython.org docs on framebuf","title":"References"},{"location":"advanced-labs/08-minicom/","text":"Minicom Installation Installation on a Mac 1 brew install minicom Installation on Linux (Raspberry Pi OS) 1 sudo apt install minicom Verification of Installation 1 which minicom 1 /usr/local/bin/minicom 1 minicom --version 1 minicom version 2.8 (compiled Jan 4 2021) 1 minicom --help returns: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Usage: minicom [OPTION]... [configuration] A terminal program for Linux and other unix-like systems. -b, --baudrate : set baudrate (ignore the value from config) -D, --device : set device name (ignore the value from config) -s, --setup : enter setup mode -o, --noinit : do not initialize modem & lockfiles at startup -m, --metakey : use meta or alt key for commands -M, --metakey8 : use 8bit meta key for commands -l, --ansi : literal; assume screen uses non IBM-PC character set -L, --iso : don't assume screen uses ISO8859 -w, --wrap : Linewrap on -H, --displayhex : display output in hex -z, --statline : try to use terminal's status line -7, --7bit : force 7bit mode -8, --8bit : force 8bit mode -c, --color=on/off : ANSI style color usage on or off -a, --attrib=on/off : use reverse or highlight attributes on or off -t, --term=TERM : override TERM environment variable -S, --script=SCRIPT : run SCRIPT at startup -d, --dial=ENTRY : dial ENTRY from the dialing directory -p, --ptty=TTYP : connect to pseudo terminal -C, --capturefile=FILE : start capturing to FILE --capturefile-buffer-mode=MODE : set buffering mode of capture file -F, --statlinefmt : format of status line -R, --remotecharset : character set of communication partner -v, --version : output version information and exit -h, --help : show help configuration : configuration file to use These options can also be specified in the MINICOM environment variable. This variable is currently unset. The configuration directory for the access file and the configurations is compiled to /usr/local/Cellar/minicom/2.8/etc. Report bugs to <minicom-devel@lists.alioth.debian.org>. References","title":"Minicom"},{"location":"advanced-labs/08-minicom/#minicom","text":"","title":"Minicom"},{"location":"advanced-labs/08-minicom/#installation","text":"","title":"Installation"},{"location":"advanced-labs/08-minicom/#installation-on-a-mac","text":"1 brew install minicom","title":"Installation on a Mac"},{"location":"advanced-labs/08-minicom/#installation-on-linux-raspberry-pi-os","text":"1 sudo apt install minicom","title":"Installation on Linux (Raspberry Pi OS)"},{"location":"advanced-labs/08-minicom/#verification-of-installation","text":"1 which minicom 1 /usr/local/bin/minicom 1 minicom --version 1 minicom version 2.8 (compiled Jan 4 2021) 1 minicom --help returns: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Usage: minicom [OPTION]... [configuration] A terminal program for Linux and other unix-like systems. -b, --baudrate : set baudrate (ignore the value from config) -D, --device : set device name (ignore the value from config) -s, --setup : enter setup mode -o, --noinit : do not initialize modem & lockfiles at startup -m, --metakey : use meta or alt key for commands -M, --metakey8 : use 8bit meta key for commands -l, --ansi : literal; assume screen uses non IBM-PC character set -L, --iso : don't assume screen uses ISO8859 -w, --wrap : Linewrap on -H, --displayhex : display output in hex -z, --statline : try to use terminal's status line -7, --7bit : force 7bit mode -8, --8bit : force 8bit mode -c, --color=on/off : ANSI style color usage on or off -a, --attrib=on/off : use reverse or highlight attributes on or off -t, --term=TERM : override TERM environment variable -S, --script=SCRIPT : run SCRIPT at startup -d, --dial=ENTRY : dial ENTRY from the dialing directory -p, --ptty=TTYP : connect to pseudo terminal -C, --capturefile=FILE : start capturing to FILE --capturefile-buffer-mode=MODE : set buffering mode of capture file -F, --statlinefmt : format of status line -R, --remotecharset : character set of communication partner -v, --version : output version information and exit -h, --help : show help configuration : configuration file to use These options can also be specified in the MINICOM environment variable. This variable is currently unset. The configuration directory for the access file and the configurations is compiled to /usr/local/Cellar/minicom/2.8/etc. Report bugs to <minicom-devel@lists.alioth.debian.org>.","title":"Verification of Installation"},{"location":"advanced-labs/08-minicom/#references","text":"","title":"References"},{"location":"advanced-labs/09-micro-sd-card-reader/","text":"Micro SD Card Reader Secure Digital (SD) is a non-volatile memory card format for use in portable devices such as cameras, MP3 players and portable devices. On Microcontrollers SD cards are usually access through an SPI interface although there are also devices that use I2C interfaces. Maker Pi Pico Connections GPIO Pin SD Mode SPI Mode GP10 CLK SCK GP11 CMD SDI GP12 DAT0 SD0 GP13 DAT1 X GP14 DAT2 X GP15 CD/DAT3 CSn Maker Pi Pico Example Code Pin Definitions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # SD Mode Definitions SDCARD_CLK = 10 SDCARD_CMD = 11 SDCARD_DAT0 = 12 SDCARD_DAT1 = 13 SDCARD_DAT2 = 14 SDCARD_CD_DAT3 = 15 # SPI Mode Definitions SDCARD_SCK = 10 SDCARD_SDI = 11 SDCARD_SD0 = 12 SDCARD_X1 = 13 SDCARD_X2 = 14 SDCARD_CS = 15 Sample Code for SPI Mode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import machine , os , sdcard # Assign chip select (CS) pin (and start it high) cs = machine . Pin ( 15 , machine . Pin . OUT ) # Intialize SPI peripheral (start with 1 MHz) spi = machine . SPI ( 1 , baudrate = 1000000 , polarity = 0 , phase = 0 , bits = 8 , firstbit = machine . SPI . MSB , sck = machine . Pin ( 10 ), mosi = machine . Pin ( 11 ), miso = machine . Pin ( 12 )) # Initialize SD card sd = sdcard . SDCard ( spi , cs ) # OR this simpler initialization code should works on Maker Pi Pico too... #sd = sdcard.SDCard(machine.SPI(1), machine.Pin(15)) os . mount ( sd , '/sd' ) # check the content os . listdir ( '/sd' ) # try some standard file operations file = open ( '/sd/test.txt' , 'w' ) file . write ( 'Testing SD card on Maker Pi Pico' ) file . close () file = open ( '/sd/test.txt' , 'r' ) data = file . read () print ( data ) file . close () Results: 1 Testing SD card on Maker Pi Pico References MicroPython sdcard.py driver - note there is no documentation on use with the RP2040 although there is example code for the pyboard and the ESP8266 MicroPython.org Documentation Raspberry Pi Pico Forum YouTube Video by Shawn Hymel Cytron Maker Pi Pico Datasheet SparkFun microSD Transflash Breakout - $4.75 - pins are labeled CD, DO, GND, SCK, VCC, DI and CS","title":"SD Card Reader"},{"location":"advanced-labs/09-micro-sd-card-reader/#micro-sd-card-reader","text":"Secure Digital (SD) is a non-volatile memory card format for use in portable devices such as cameras, MP3 players and portable devices. On Microcontrollers SD cards are usually access through an SPI interface although there are also devices that use I2C interfaces.","title":"Micro SD Card Reader"},{"location":"advanced-labs/09-micro-sd-card-reader/#maker-pi-pico-connections","text":"GPIO Pin SD Mode SPI Mode GP10 CLK SCK GP11 CMD SDI GP12 DAT0 SD0 GP13 DAT1 X GP14 DAT2 X GP15 CD/DAT3 CSn","title":"Maker Pi Pico Connections"},{"location":"advanced-labs/09-micro-sd-card-reader/#maker-pi-pico-example-code","text":"","title":"Maker Pi Pico Example Code"},{"location":"advanced-labs/09-micro-sd-card-reader/#pin-definitions","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # SD Mode Definitions SDCARD_CLK = 10 SDCARD_CMD = 11 SDCARD_DAT0 = 12 SDCARD_DAT1 = 13 SDCARD_DAT2 = 14 SDCARD_CD_DAT3 = 15 # SPI Mode Definitions SDCARD_SCK = 10 SDCARD_SDI = 11 SDCARD_SD0 = 12 SDCARD_X1 = 13 SDCARD_X2 = 14 SDCARD_CS = 15","title":"Pin Definitions"},{"location":"advanced-labs/09-micro-sd-card-reader/#sample-code-for-spi-mode","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import machine , os , sdcard # Assign chip select (CS) pin (and start it high) cs = machine . Pin ( 15 , machine . Pin . OUT ) # Intialize SPI peripheral (start with 1 MHz) spi = machine . SPI ( 1 , baudrate = 1000000 , polarity = 0 , phase = 0 , bits = 8 , firstbit = machine . SPI . MSB , sck = machine . Pin ( 10 ), mosi = machine . Pin ( 11 ), miso = machine . Pin ( 12 )) # Initialize SD card sd = sdcard . SDCard ( spi , cs ) # OR this simpler initialization code should works on Maker Pi Pico too... #sd = sdcard.SDCard(machine.SPI(1), machine.Pin(15)) os . mount ( sd , '/sd' ) # check the content os . listdir ( '/sd' ) # try some standard file operations file = open ( '/sd/test.txt' , 'w' ) file . write ( 'Testing SD card on Maker Pi Pico' ) file . close () file = open ( '/sd/test.txt' , 'r' ) data = file . read () print ( data ) file . close () Results: 1 Testing SD card on Maker Pi Pico","title":"Sample Code for SPI Mode"},{"location":"advanced-labs/09-micro-sd-card-reader/#references","text":"MicroPython sdcard.py driver - note there is no documentation on use with the RP2040 although there is example code for the pyboard and the ESP8266 MicroPython.org Documentation Raspberry Pi Pico Forum YouTube Video by Shawn Hymel Cytron Maker Pi Pico Datasheet SparkFun microSD Transflash Breakout - $4.75 - pins are labeled CD, DO, GND, SCK, VCC, DI and CS","title":"References"},{"location":"advanced-labs/10-converting-circuitpython-to-micropython/","text":"Converting CircuitPython to MicroPython MicroPython was created in by Australian programmer Damian George in May of 2014. Although Adafruit originally supported MicroPython, in July 2017 Adafruit created a fork of MicroPython and called it CircuitPython . We can only speculate why this decisive action was taken, but the result is it divided the community into two incompatible branches and it doubled the amount of work needed to be done to introduce a new device to the Python community. Unfortunately, the consequence is that many programs written in CircuitPython are difficult to port to MicroPython. Today, according to Google Trends , MicroPython is still four more popular than CircuitPython when we look at worldwide web search comparisons. However, in the US, the popularity is more equal. Although the claim was that CircuitPython was done for \"simplicity\" there is little evidence that CircuitPython programs are smaller or easier to maintain than MicroPython. The one thing is clear, CircuitPython has lots of drivers for unusual hardware devices. If you find a driver you need in MicroPython you will need to convert it to MicroPython. This is usually done manually on a line-by-line basis. Setting up a CircuitPython Virtual Environment Because MicroPython and CircuitPython are incompatible, it is important that you don't intermix your Python libraries. Here is how we setup a virtual environment for CircuitPython using Conda . 1 2 conda create -n circuitpython python = 3 conda activate circuitpython Installing the SSD1306 CircuitPython Library Per Directions Here 1 pip3 install adafruit-circuitpython-ssd1306 1 pip3 install adafruit-circuitpython-displayio-ssd1306 Note ERROR: Could not find a version that satisfies the requirement adafruit-circuitpython-displayio-ssd1306 ERROR: No matching distribution found for adafruit-circuitpython-displayio-ssd1306 1 Successfully installed Adafruit-Blinka-6.3.2 Adafruit-PlatformDetect-3.2.0 Adafruit-PureIO-1.1.8 adafruit-circuitpython-busdevice-5.0.6 adafruit-circuitpython-framebuf-1.4.6 adafruit-circuitpython-ssd1306-2.11.1 pyftdi-0.52.9 pyserial-3.5 pyusb-1.1.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Basic example of clearing and drawing pixels on a SSD1306 OLED display. # This example and library is meant to work with Adafruit CircuitPython API. # Author: Tony DiCola # License: Public Domain # Import all board pins. from board import SCL , SDA import busio # Import the SSD1306 module. import adafruit_ssd1306 # Create the I2C interface. i2c = busio . I2C ( SCL , SDA ) # Create the SSD1306 OLED class. # The first two parameters are the pixel width and pixel height. Change these # to the right size for your display! display = adafruit_ssd1306 . SSD1306_I2C ( 128 , 32 , i2c ) # Alternatively you can change the I2C address of the device with an addr parameter: #display = adafruit_ssd1306.SSD1306_I2C(128, 32, i2c, addr=0x31) # Clear the display. Always call show after changing pixels to make the display # update visible! display . fill ( 0 ) display . show () # Set a pixel in the origin 0,0 position. display . pixel ( 0 , 0 , 1 ) # Set a pixel in the middle 64, 16 position. display . pixel ( 64 , 16 , 1 ) # Set a pixel in the opposite 127, 31 position. display . pixel ( 127 , 31 , 1 ) display . show () Trend analysis As of March 2021, MicroPython is about two to four times more popular than CircuitPython. Google Worldwide Search Trends","title":"Converting CircuitPython"},{"location":"advanced-labs/10-converting-circuitpython-to-micropython/#converting-circuitpython-to-micropython","text":"MicroPython was created in by Australian programmer Damian George in May of 2014. Although Adafruit originally supported MicroPython, in July 2017 Adafruit created a fork of MicroPython and called it CircuitPython . We can only speculate why this decisive action was taken, but the result is it divided the community into two incompatible branches and it doubled the amount of work needed to be done to introduce a new device to the Python community. Unfortunately, the consequence is that many programs written in CircuitPython are difficult to port to MicroPython. Today, according to Google Trends , MicroPython is still four more popular than CircuitPython when we look at worldwide web search comparisons. However, in the US, the popularity is more equal. Although the claim was that CircuitPython was done for \"simplicity\" there is little evidence that CircuitPython programs are smaller or easier to maintain than MicroPython. The one thing is clear, CircuitPython has lots of drivers for unusual hardware devices. If you find a driver you need in MicroPython you will need to convert it to MicroPython. This is usually done manually on a line-by-line basis.","title":"Converting CircuitPython to MicroPython"},{"location":"advanced-labs/10-converting-circuitpython-to-micropython/#setting-up-a-circuitpython-virtual-environment","text":"Because MicroPython and CircuitPython are incompatible, it is important that you don't intermix your Python libraries. Here is how we setup a virtual environment for CircuitPython using Conda . 1 2 conda create -n circuitpython python = 3 conda activate circuitpython","title":"Setting up a CircuitPython Virtual Environment"},{"location":"advanced-labs/10-converting-circuitpython-to-micropython/#installing-the-ssd1306-circuitpython-library","text":"Per Directions Here 1 pip3 install adafruit-circuitpython-ssd1306 1 pip3 install adafruit-circuitpython-displayio-ssd1306 Note ERROR: Could not find a version that satisfies the requirement adafruit-circuitpython-displayio-ssd1306 ERROR: No matching distribution found for adafruit-circuitpython-displayio-ssd1306 1 Successfully installed Adafruit-Blinka-6.3.2 Adafruit-PlatformDetect-3.2.0 Adafruit-PureIO-1.1.8 adafruit-circuitpython-busdevice-5.0.6 adafruit-circuitpython-framebuf-1.4.6 adafruit-circuitpython-ssd1306-2.11.1 pyftdi-0.52.9 pyserial-3.5 pyusb-1.1.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Basic example of clearing and drawing pixels on a SSD1306 OLED display. # This example and library is meant to work with Adafruit CircuitPython API. # Author: Tony DiCola # License: Public Domain # Import all board pins. from board import SCL , SDA import busio # Import the SSD1306 module. import adafruit_ssd1306 # Create the I2C interface. i2c = busio . I2C ( SCL , SDA ) # Create the SSD1306 OLED class. # The first two parameters are the pixel width and pixel height. Change these # to the right size for your display! display = adafruit_ssd1306 . SSD1306_I2C ( 128 , 32 , i2c ) # Alternatively you can change the I2C address of the device with an addr parameter: #display = adafruit_ssd1306.SSD1306_I2C(128, 32, i2c, addr=0x31) # Clear the display. Always call show after changing pixels to make the display # update visible! display . fill ( 0 ) display . show () # Set a pixel in the origin 0,0 position. display . pixel ( 0 , 0 , 1 ) # Set a pixel in the middle 64, 16 position. display . pixel ( 64 , 16 , 1 ) # Set a pixel in the opposite 127, 31 position. display . pixel ( 127 , 31 , 1 ) display . show ()","title":"Installing the SSD1306 CircuitPython Library"},{"location":"advanced-labs/10-converting-circuitpython-to-micropython/#trend-analysis","text":"As of March 2021, MicroPython is about two to four times more popular than CircuitPython. Google Worldwide Search Trends","title":"Trend analysis"},{"location":"advanced-labs/11-rshell/","text":"Using rshell on the Raspberry Pi Pico Using an IDE such as Thonny you can copy one file at a time to the Raspberry Pi Pico by creating a new file and doing a copy/paste of the code into that new file. However, this process becomes slow and tedious if you want to copy a large number of files. To do this we will use the \"remote shell\" program from the command line. In our classes we often want to copy a dozen or more files to a new robot for student to try out. Rshell was written by David Hyland. The source code and installations are documented on Dave's GitHub repository here: https://github.com/dhylands/rshell . Dave added support for the Raspberry Pi Pico in release 0.0.30 in March of 2021. Rshell's primary use is to to get filesystem information on the pico (ls), and to copy files to and from MicroPython's filesystem. It can also be used as a terminal to run interactive RPEL commands. Conda Setup If you are new to Python and you don't have any previous virtual environments set up you can skip this step. Experienced Python developers have many different environments that they want to keep separated due to library incompatibility issues. Here is how to create a new Python Conda environment that keeps your rshell libraries separated. 1 2 3 conda create -n pico python = 3 conda deactivate conda activate pico Your prompt should now indicate you are in the pico environment. Install rshell in your pico environment We will now use the standard pip installer tool to install the rshell command. 1 python -m pip install rshell You can check that rshell has been correctly installed in your command PATH by running the UNIX which command. 1 which rshell Running shell Rshell communicates with the Pico through the USB port. When you plug in the Pico you should see a new file created in the UNIX /dev directory. It typically begins with the letters /dev/cu.modem . One way to test this is to unlpug the pico and run the following command: 1 ls /dev/cu.usbmodem* With the pico unplugged, there should be no files that match the ls wildcard pattern. However, after you plug in the pico the following should be returned: 1 /dev/cu.usbmodem14101 This is the port you will use to connect to the pico. We will use the -p for port option to startup rshell. 1 rshell -p /dev/cu.usbmodem14101 1 2 3 4 5 6 7 8 9 10 Using buffer-size of 128 Connecting to /dev/cu.usbmodem14101 (buffer-size 128)... Trying to connect to REPL connected Retrieving sysname ... rp2 Testing if ubinascii.unhexlify exists ... Y Retrieving root directories ... /LCD_SPI.py/ /lcd-spi-test.py/ /lcd-test.py/ /lcd.py/ Setting time ... Oct 28, 2021 20:30:56 Evaluating board_name ... pyboard Retrieving time epoch ... Jan 01, 1970 Welcome to rshell. Use Control-D (or the exit command) to exit rshell. Boards The boards command will list the boards rshell is connected to: boards pyboard @ /dev/cu.usbmodem14101 connected Epoch: 1970 Dirs: /pyboard/hello.py /pyboard/main.py Listing Files We can see that the board is called \"pyboard\" and you can use that as a path to list the files on the board. 1 2 ls /pyboard hello.py main.py Giving Your Board a Name rshell will look for a program called board.py when it connects to the board. If this file contains a board name it will use that as the board name the next time it connects to the board. You can use the \"echo\" command to generate the file. In the example below, we will call our board \"pico\" 1 echo 'name=\"pico\"' > /pyboard/board.py After you use the CONTROL-C and reconnect you will see the following: 1 pico @ /dev/cu.usbmodem14101 connected Epoch: 1970 Dirs: /pico/hello.py /pico/main.py Remember you must disconnect from rshell and reconnect before the boards.py function is used. For the remainder of this lesson we will assume you have renamed your board \"pico\". You can then type cd /pico followed by a ls to see the files on your pico. Entering REPL You can enter the REPL loop using the repl command and use the same commands that you used in the Thonny shell. 1 2 repl print('Hello World!') returns 1 Hello World! Getting Help on rshell commands You can type the help command to see all the rshell commands: 1 2 3 4 5 6 7 8 help Documented commands (type help <topic>): ======================================== args cat connect date edit filesize help mkdir rm shell boards cd cp echo exit filetype ls repl rsync Use Control-D (or the exit command) to exit rshell. Running Backup If you want to copy all the python files from the pico to a backup directory you can use the following command: 1 2 cd /pico cp *.py /Users/dan/backup You will need to create the /Users/dan/backup directory before you do this. You can also use the tilde ~ character to stand in for your home directory like this: 1 cp *.py /Users/dan/backup Copying '/pico/hello.py' to '/Users/dan/backup/hello.py' ... Copying '/pico/main.py' to '/Users/dan/backup/main.py' ... Installing files If you have a directory called ~/build that contains many files you want to install on the pico file system you can use the following command: 1 cp ~/build/* /pico If you have done a clone to the CoderDojoTC micropython repository and put it in your home directory under ~/micropython then following command will copy the python files from the Maker Pi RP2040 kit to your pico: 1 2 3 4 mkdir /pico/lib cp ~/micropython/src/drivers/*.py /pico/lib cp ~/micropython/src/kits/maker-pi-rp2040/*.py /pico cp ~Documents/ws/micropython/src/kits/maker-pi-rp2040-robots/*.py /pico/lib Note that the drivers will be placed in the /lob directory. Direct Command Execution You do not need to use an interactive session to run a command with rshell. You can just add the command you would like to run to the end of the rshell command like this: 1 rshell -p /dev/cu.usbmodem14101 ls /pico returns: 1 hello.py main.py","title":"Rshell"},{"location":"advanced-labs/11-rshell/#using-rshell-on-the-raspberry-pi-pico","text":"Using an IDE such as Thonny you can copy one file at a time to the Raspberry Pi Pico by creating a new file and doing a copy/paste of the code into that new file. However, this process becomes slow and tedious if you want to copy a large number of files. To do this we will use the \"remote shell\" program from the command line. In our classes we often want to copy a dozen or more files to a new robot for student to try out. Rshell was written by David Hyland. The source code and installations are documented on Dave's GitHub repository here: https://github.com/dhylands/rshell . Dave added support for the Raspberry Pi Pico in release 0.0.30 in March of 2021. Rshell's primary use is to to get filesystem information on the pico (ls), and to copy files to and from MicroPython's filesystem. It can also be used as a terminal to run interactive RPEL commands.","title":"Using rshell on the Raspberry Pi Pico"},{"location":"advanced-labs/11-rshell/#conda-setup","text":"If you are new to Python and you don't have any previous virtual environments set up you can skip this step. Experienced Python developers have many different environments that they want to keep separated due to library incompatibility issues. Here is how to create a new Python Conda environment that keeps your rshell libraries separated. 1 2 3 conda create -n pico python = 3 conda deactivate conda activate pico Your prompt should now indicate you are in the pico environment.","title":"Conda Setup"},{"location":"advanced-labs/11-rshell/#install-rshell-in-your-pico-environment","text":"We will now use the standard pip installer tool to install the rshell command. 1 python -m pip install rshell You can check that rshell has been correctly installed in your command PATH by running the UNIX which command. 1 which rshell","title":"Install rshell in your pico environment"},{"location":"advanced-labs/11-rshell/#running-shell","text":"Rshell communicates with the Pico through the USB port. When you plug in the Pico you should see a new file created in the UNIX /dev directory. It typically begins with the letters /dev/cu.modem . One way to test this is to unlpug the pico and run the following command: 1 ls /dev/cu.usbmodem* With the pico unplugged, there should be no files that match the ls wildcard pattern. However, after you plug in the pico the following should be returned: 1 /dev/cu.usbmodem14101 This is the port you will use to connect to the pico. We will use the -p for port option to startup rshell. 1 rshell -p /dev/cu.usbmodem14101 1 2 3 4 5 6 7 8 9 10 Using buffer-size of 128 Connecting to /dev/cu.usbmodem14101 (buffer-size 128)... Trying to connect to REPL connected Retrieving sysname ... rp2 Testing if ubinascii.unhexlify exists ... Y Retrieving root directories ... /LCD_SPI.py/ /lcd-spi-test.py/ /lcd-test.py/ /lcd.py/ Setting time ... Oct 28, 2021 20:30:56 Evaluating board_name ... pyboard Retrieving time epoch ... Jan 01, 1970 Welcome to rshell. Use Control-D (or the exit command) to exit rshell.","title":"Running shell"},{"location":"advanced-labs/11-rshell/#boards","text":"The boards command will list the boards rshell is connected to: boards pyboard @ /dev/cu.usbmodem14101 connected Epoch: 1970 Dirs: /pyboard/hello.py /pyboard/main.py","title":"Boards"},{"location":"advanced-labs/11-rshell/#listing-files","text":"We can see that the board is called \"pyboard\" and you can use that as a path to list the files on the board. 1 2 ls /pyboard hello.py main.py","title":"Listing Files"},{"location":"advanced-labs/11-rshell/#giving-your-board-a-name","text":"rshell will look for a program called board.py when it connects to the board. If this file contains a board name it will use that as the board name the next time it connects to the board. You can use the \"echo\" command to generate the file. In the example below, we will call our board \"pico\" 1 echo 'name=\"pico\"' > /pyboard/board.py After you use the CONTROL-C and reconnect you will see the following: 1 pico @ /dev/cu.usbmodem14101 connected Epoch: 1970 Dirs: /pico/hello.py /pico/main.py Remember you must disconnect from rshell and reconnect before the boards.py function is used. For the remainder of this lesson we will assume you have renamed your board \"pico\". You can then type cd /pico followed by a ls to see the files on your pico.","title":"Giving Your Board a Name"},{"location":"advanced-labs/11-rshell/#entering-repl","text":"You can enter the REPL loop using the repl command and use the same commands that you used in the Thonny shell. 1 2 repl print('Hello World!') returns 1 Hello World!","title":"Entering REPL"},{"location":"advanced-labs/11-rshell/#getting-help-on-rshell-commands","text":"You can type the help command to see all the rshell commands: 1 2 3 4 5 6 7 8 help Documented commands (type help <topic>): ======================================== args cat connect date edit filesize help mkdir rm shell boards cd cp echo exit filetype ls repl rsync Use Control-D (or the exit command) to exit rshell.","title":"Getting Help on rshell commands"},{"location":"advanced-labs/11-rshell/#running-backup","text":"If you want to copy all the python files from the pico to a backup directory you can use the following command: 1 2 cd /pico cp *.py /Users/dan/backup You will need to create the /Users/dan/backup directory before you do this. You can also use the tilde ~ character to stand in for your home directory like this: 1 cp *.py /Users/dan/backup Copying '/pico/hello.py' to '/Users/dan/backup/hello.py' ... Copying '/pico/main.py' to '/Users/dan/backup/main.py' ...","title":"Running Backup"},{"location":"advanced-labs/11-rshell/#installing-files","text":"If you have a directory called ~/build that contains many files you want to install on the pico file system you can use the following command: 1 cp ~/build/* /pico If you have done a clone to the CoderDojoTC micropython repository and put it in your home directory under ~/micropython then following command will copy the python files from the Maker Pi RP2040 kit to your pico: 1 2 3 4 mkdir /pico/lib cp ~/micropython/src/drivers/*.py /pico/lib cp ~/micropython/src/kits/maker-pi-rp2040/*.py /pico cp ~Documents/ws/micropython/src/kits/maker-pi-rp2040-robots/*.py /pico/lib Note that the drivers will be placed in the /lob directory.","title":"Installing files"},{"location":"advanced-labs/11-rshell/#direct-command-execution","text":"You do not need to use an interactive session to run a command with rshell. You can just add the command you would like to run to the end of the rshell command like this: 1 rshell -p /dev/cu.usbmodem14101 ls /pico returns: 1 hello.py main.py","title":"Direct Command Execution"},{"location":"concept-cards/01-intro/","text":"MicroPython Concept Cards Concept Cards Beginning concepts Physical Computing Sensors Switches and Buttons Sensing Light [Sensing Distance] Ping Distance Sensors Time of Flight Distance Sensors Motors DC Motors Servos Stepper Motors Batteries and Power AA Batteries LiPo Batteries Intermediate Concepts Interrupts Advanced Concepts MultiCore Programming","title":"MicroPython Concept Cards"},{"location":"concept-cards/01-intro/#micropython-concept-cards","text":"Concept Cards","title":"MicroPython Concept Cards"},{"location":"concept-cards/01-intro/#beginning-concepts","text":"","title":"Beginning concepts"},{"location":"concept-cards/01-intro/#physical-computing","text":"","title":"Physical Computing"},{"location":"concept-cards/01-intro/#sensors","text":"","title":"Sensors"},{"location":"concept-cards/01-intro/#switches-and-buttons","text":"","title":"Switches and Buttons"},{"location":"concept-cards/01-intro/#sensing-light","text":"","title":"Sensing Light"},{"location":"concept-cards/01-intro/#sensing-distance","text":"","title":"[Sensing Distance]"},{"location":"concept-cards/01-intro/#ping-distance-sensors","text":"","title":"Ping Distance Sensors"},{"location":"concept-cards/01-intro/#time-of-flight-distance-sensors","text":"","title":"Time of Flight Distance Sensors"},{"location":"concept-cards/01-intro/#motors","text":"","title":"Motors"},{"location":"concept-cards/01-intro/#dc-motors","text":"","title":"DC Motors"},{"location":"concept-cards/01-intro/#servos","text":"","title":"Servos"},{"location":"concept-cards/01-intro/#stepper-motors","text":"","title":"Stepper Motors"},{"location":"concept-cards/01-intro/#batteries-and-power","text":"","title":"Batteries and Power"},{"location":"concept-cards/01-intro/#aa-batteries","text":"","title":"AA Batteries"},{"location":"concept-cards/01-intro/#lipo-batteries","text":"","title":"LiPo Batteries"},{"location":"concept-cards/01-intro/#intermediate-concepts","text":"","title":"Intermediate Concepts"},{"location":"concept-cards/01-intro/#interrupts","text":"","title":"Interrupts"},{"location":"concept-cards/01-intro/#advanced-concepts","text":"","title":"Advanced Concepts"},{"location":"concept-cards/01-intro/#multicore-programming","text":"","title":"MultiCore Programming"},{"location":"debugging/28-debugging-python/","text":"How to Debug Micropython Listing the Modules 1 help ( 'modules' ) Result: 1 2 3 4 5 6 7 8 9 10 __main__ gc uasyncio/funcs uos _boot machine uasyncio/lock urandom _onewire math uasyncio/stream ure _rp2 micropython ubinascii uselect _thread onewire ucollections ustruct _uasyncio rp2 uctypes usys builtins uasyncio/__init__ uhashlib utime ds18x20 uasyncio/core uio uzlib framebuf uasyncio/event ujson Plus any modules on the filesystem Micropython issues https://github.com/micropython/micropython/issues","title":"Debugging Python"},{"location":"debugging/28-debugging-python/#how-to-debug-micropython","text":"","title":"How to Debug Micropython"},{"location":"debugging/28-debugging-python/#listing-the-modules","text":"1 help ( 'modules' ) Result: 1 2 3 4 5 6 7 8 9 10 __main__ gc uasyncio/funcs uos _boot machine uasyncio/lock urandom _onewire math uasyncio/stream ure _rp2 micropython ubinascii uselect _thread onewire ucollections ustruct _uasyncio rp2 uctypes usys builtins uasyncio/__init__ uhashlib utime ds18x20 uasyncio/core uio uzlib framebuf uasyncio/event ujson Plus any modules on the filesystem","title":"Listing the Modules"},{"location":"debugging/28-debugging-python/#micropython-issues","text":"https://github.com/micropython/micropython/issues","title":"Micropython issues"},{"location":"debugging/29-debugging-spi/","text":"Debugging SPI In this lab we use a logic analyzer to debug the SPI protocol being used to drive a sample OLED device. We will be using the the 8 port Saleae Logic Analyser . The retail cost is about $399.00 although there are lower cost logic analyzer available. The SSD1306 SPI OLED Timing Diagram The OLED display is a read-only interface. It does not send any data back to the microcontroller, so there is no MOSI connection. The data is transmitted on the SDK line when the SCL line goes high. The CS line must be low for the OLED to be active. For details, see section 8.1.3 MCU Serial Interface on page 21 of the SSD1305 132 x 64 Dot Matrix OLED/PLED Segment/Common Driver with Controller . OLED SPI settings Our OLED device has seven wires. In addition to power and ground there a five data connections we will be observing on our logic analyzer. CS - Chip Select pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 (Data from the ) SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin Setting up a Logic Analyzer Setup SPI Analyser Configure SPI Channel Settings Saleae Logic Analyser SPI Logic Analyser Settings Check a Working Device The first thing we want to see is what the signals to a working SPI OLED should be. There are plenty of working drivers for the Arduino, so I hooked one up to the Logic analizer to see what they were. Viewing Data Clock and RES All five signals DC and CS signals have a larger period. DC on was 3.668 milliseconds Clock Period Our Clock (SCL) has 8 positive pulses with a width of .4167 microseconds. This means that the positve/negative combined width has a period of 2 * .4167 = .8333 microseconds. This can be converted into a frequency of 1.2 megahertz. References Video on how to use the Saleae Logic Analyzer https://www.youtube.com/watch?v=Ak9R4yxQPhs","title":"Debugging SPI"},{"location":"debugging/29-debugging-spi/#debugging-spi","text":"In this lab we use a logic analyzer to debug the SPI protocol being used to drive a sample OLED device. We will be using the the 8 port Saleae Logic Analyser . The retail cost is about $399.00 although there are lower cost logic analyzer available.","title":"Debugging SPI"},{"location":"debugging/29-debugging-spi/#the-ssd1306-spi-oled-timing-diagram","text":"The OLED display is a read-only interface. It does not send any data back to the microcontroller, so there is no MOSI connection. The data is transmitted on the SDK line when the SCL line goes high. The CS line must be low for the OLED to be active. For details, see section 8.1.3 MCU Serial Interface on page 21 of the SSD1305 132 x 64 Dot Matrix OLED/PLED Segment/Common Driver with Controller .","title":"The SSD1306 SPI OLED Timing Diagram"},{"location":"debugging/29-debugging-spi/#oled-spi-settings","text":"Our OLED device has seven wires. In addition to power and ground there a five data connections we will be observing on our logic analyzer. CS - Chip Select pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 (Data from the ) SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin","title":"OLED SPI settings"},{"location":"debugging/29-debugging-spi/#setting-up-a-logic-analyzer","text":"","title":"Setting up a Logic Analyzer"},{"location":"debugging/29-debugging-spi/#setup-spi-analyser","text":"","title":"Setup SPI Analyser"},{"location":"debugging/29-debugging-spi/#configure-spi-channel-settings","text":"Saleae Logic Analyser SPI Logic Analyser Settings","title":"Configure SPI Channel Settings"},{"location":"debugging/29-debugging-spi/#check-a-working-device","text":"The first thing we want to see is what the signals to a working SPI OLED should be. There are plenty of working drivers for the Arduino, so I hooked one up to the Logic analizer to see what they were.","title":"Check a Working Device"},{"location":"debugging/29-debugging-spi/#viewing-data-clock-and-res","text":"All five signals DC and CS signals have a larger period. DC on was 3.668 milliseconds","title":"Viewing Data Clock and RES"},{"location":"debugging/29-debugging-spi/#clock-period","text":"Our Clock (SCL) has 8 positive pulses with a width of .4167 microseconds. This means that the positve/negative combined width has a period of 2 * .4167 = .8333 microseconds. This can be converted into a frequency of 1.2 megahertz.","title":"Clock Period"},{"location":"debugging/29-debugging-spi/#references","text":"Video on how to use the Saleae Logic Analyzer https://www.youtube.com/watch?v=Ak9R4yxQPhs","title":"References"},{"location":"debugging/29a-debugging-i2c/","text":"Debugging I2C Bus","title":"Debugging I2C"},{"location":"debugging/29a-debugging-i2c/#debugging-i2c-bus","text":"","title":"Debugging I2C Bus"},{"location":"displays/01-intro/","text":"Displays We cover small displays but not OLEDs. There is a separate chapter for OLED displays.","title":"Introduction"},{"location":"displays/01-intro/#displays","text":"We cover small displays but not OLEDs. There is a separate chapter for OLED displays.","title":"Displays"},{"location":"displays/03-10-bar-leds/","text":"10 bar LED display Goals for the Lesson Our goal is to learn how to use python lists to turn on and off a row of 10 LEDs. Connect each of the LEDs through a 330 ohm resistor. We will create a list that has each of the GPIO pins for output. 1 pin_ids = [ 12 , 13 , 14 , 15 , 20 , 19 , 18 , 17 , 16 ] For each pin on this list, we will create a new list that contains the pin object that we can turn on or off. 1 2 3 4 5 6 7 8 from machine import Pin from utime import sleep pin_ids = [ 12 , 13 , 14 , 15 , 20 , 19 , 18 , 17 , 16 ] pins = [] pin_ids for i in pin_ids : pins . append ( machine . Pin ( pin_ids [ i ], machine . Pin . OUT )) We will use this same preamble code in all our examples. Code to Blink all 10 LEDs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from machine import Pin from utime import sleep pin_ids = [ 12 , 13 , 14 , 15 , 20 , 19 , 18 , 17 , 16 ] pins = [] pin_ids for i in pin_ids : pins . append ( machine . Pin ( pin_ids [ i ], machine . Pin . OUT )) delay = . 5 while True : # turn all the pins on for pin in pins : pins . on () sleep ( delay ) # wait # turn all the pins off for pin in pins : pins [ i ] . off () sleep ( delay ) Sample Running Lights Example The \"running lights\" pattern gives the impression that there is a red object that is moving up and down a row. We do this by successively turning on adjacently LEDs and then turning them off. This give the illusion of motion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from machine import Pin from utime import sleep pin_ids = [ 12 , 13 , 14 , 15 , 20 , 19 , 18 , 17 , 16 ] pins = [] for i in range ( 0 , 9 ): pins . append ( machine . Pin ( pin_ids [ i ], machine . Pin . OUT )) delay = . 1 while True : for i in range ( 0 , 9 ): pins [ i ] . on () sleep ( delay ) pins [ i ] . off () for i in range ( 8 , 1 , - 1 ): pins [ i ] . on () sleep ( delay ) pins [ i ] . off () swipe The swipe pattern turns each LED on but keeps it on until the direction is reversed. Adding a Binary Counter Patterns We can also create another patten that will demonstrate binary counting. In this pattern, the least significant bit flickers on and off. For each cycle the adjacent pixel toggles once. The happens for each adjacent pixel. The most significant bit will only change every 1024 cycles of the least significant bit.","title":"10 bar LED display"},{"location":"displays/03-10-bar-leds/#10-bar-led-display","text":"","title":"10 bar LED display"},{"location":"displays/03-10-bar-leds/#goals-for-the-lesson","text":"Our goal is to learn how to use python lists to turn on and off a row of 10 LEDs. Connect each of the LEDs through a 330 ohm resistor. We will create a list that has each of the GPIO pins for output. 1 pin_ids = [ 12 , 13 , 14 , 15 , 20 , 19 , 18 , 17 , 16 ] For each pin on this list, we will create a new list that contains the pin object that we can turn on or off. 1 2 3 4 5 6 7 8 from machine import Pin from utime import sleep pin_ids = [ 12 , 13 , 14 , 15 , 20 , 19 , 18 , 17 , 16 ] pins = [] pin_ids for i in pin_ids : pins . append ( machine . Pin ( pin_ids [ i ], machine . Pin . OUT )) We will use this same preamble code in all our examples.","title":"Goals for the Lesson"},{"location":"displays/03-10-bar-leds/#code-to-blink-all-10-leds","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from machine import Pin from utime import sleep pin_ids = [ 12 , 13 , 14 , 15 , 20 , 19 , 18 , 17 , 16 ] pins = [] pin_ids for i in pin_ids : pins . append ( machine . Pin ( pin_ids [ i ], machine . Pin . OUT )) delay = . 5 while True : # turn all the pins on for pin in pins : pins . on () sleep ( delay ) # wait # turn all the pins off for pin in pins : pins [ i ] . off () sleep ( delay )","title":"Code to Blink all 10 LEDs"},{"location":"displays/03-10-bar-leds/#sample-running-lights-example","text":"The \"running lights\" pattern gives the impression that there is a red object that is moving up and down a row. We do this by successively turning on adjacently LEDs and then turning them off. This give the illusion of motion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from machine import Pin from utime import sleep pin_ids = [ 12 , 13 , 14 , 15 , 20 , 19 , 18 , 17 , 16 ] pins = [] for i in range ( 0 , 9 ): pins . append ( machine . Pin ( pin_ids [ i ], machine . Pin . OUT )) delay = . 1 while True : for i in range ( 0 , 9 ): pins [ i ] . on () sleep ( delay ) pins [ i ] . off () for i in range ( 8 , 1 , - 1 ): pins [ i ] . on () sleep ( delay ) pins [ i ] . off ()","title":"Sample Running Lights Example"},{"location":"displays/03-10-bar-leds/#swipe","text":"The swipe pattern turns each LED on but keeps it on until the direction is reversed.","title":"swipe"},{"location":"displays/03-10-bar-leds/#adding-a-binary-counter-patterns","text":"We can also create another patten that will demonstrate binary counting. In this pattern, the least significant bit flickers on and off. For each cycle the adjacent pixel toggles once. The happens for each adjacent pixel. The most significant bit will only change every 1024 cycles of the least significant bit.","title":"Adding a Binary Counter Patterns"},{"location":"displays/10-character-lcd-display/","text":"Character LCD Display This lesson is for using the LCM1602 I2C LCD interface. It is a popular It has four wires: GND - connect to any GND pin VCC - connect to 3V3(out) pin unless you have a 3.3 to 5v voltage converter SDA - connect to GP0 SCL - connect to GP1 The photo above shows the use of a 3.3 to 5v voltage converter. This allows us to use the full 5v to the LCD backlight so we get bright contrast. You can connect the VCC to the 3V3(out) pin but the display will be harder to read. I2C Address Scanner Test Our first task is to make sure that the 1602 chip's I2C circuits are working. We use the following I2C scanner code to do this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import machine I2C_SDA_PIN = 0 I2C_SCL_PIN = 1 i2c = machine . I2C ( 0 , sda = machine . Pin ( I2C_SDA_PIN ), scl = machine . Pin ( I2C_SCL_PIN ), freq = 400000 ) print ( 'Scanning I2C bus.' ) devices = i2c . scan () # this returns a list of devices device_count = len ( devices ) if device_count == 0 : print ( 'No i2c device found.' ) else : print ( device_count , 'devices found.' ) for device in devices : print ( 'Decimal address:' , device , \", Hex address: \" , hex ( device )) Scanner Result 1 2 3 Scanning I2C bus. 1 devices found. Decimal address: 39 , Hex address: 0x27 Testing the LCD 1 2 3 4 5 6 7 8 9 10 11 from machine import I2C from lcd_api import LcdApi from pico_i2c_lcd import I2cLcd I2C_ADDR = 0x27 I2C_NUM_ROWS = 2 I2C_NUM_COLS = 16 i2c = I2C ( 0 , sda = machine . Pin ( 0 ), scl = machine . Pin ( 1 ), freq = 400000 ) lcd = I2cLcd ( i2c , I2C_ADDR , I2C_NUM_ROWS , I2C_NUM_COLS ) lcd . putstr ( \"CoderDojo Rocks!\" ) Putting the Device Through Display Option Tests Now that we know how to display text on the device, we can learn how other functions work: lcd.move_to(x,y) lcd.display_on() and lcd.display_off() lcd.show_cursor() and lcd.hide_cursor() lcd.blink_cursor_on() and lcd.blink_cursor_off() lcd.backlight_on() and lcd.backlight_off() lcd.clear() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import utime import machine from machine import I2C from lcd_api import LcdApi from pico_i2c_lcd import I2cLcd I2C_ADDR = 0x27 I2C_NUM_ROWS = 2 I2C_NUM_COLS = 16 def test_main (): #Test function for verifying basic functionality print ( \"Running test_main\" ) i2c = I2C ( 0 , sda = machine . Pin ( 0 ), scl = machine . Pin ( 1 ), freq = 400000 ) lcd = I2cLcd ( i2c , I2C_ADDR , I2C_NUM_ROWS , I2C_NUM_COLS ) lcd . putstr ( \"CoderDojo Rocks!\" ) utime . sleep ( 10 ) lcd . clear () count = 0 while True : lcd . clear () time = utime . localtime () lcd . putstr ( \" {year:>04d} / {month:>02d} / {day:>02d} {HH:>02d} : {MM:>02d} : {SS:>02d} \" . format ( year = time [ 0 ], month = time [ 1 ], day = time [ 2 ], HH = time [ 3 ], MM = time [ 4 ], SS = time [ 5 ])) if count % 10 == 0 : print ( \"Turning cursor on\" ) lcd . show_cursor () if count % 10 == 1 : print ( \"Turning cursor off\" ) lcd . hide_cursor () if count % 10 == 2 : print ( \"Turning blink cursor on\" ) lcd . blink_cursor_on () if count % 10 == 3 : print ( \"Turning blink cursor off\" ) lcd . blink_cursor_off () if count % 10 == 4 : print ( \"Turning backlight off\" ) lcd . backlight_off () if count % 10 == 5 : print ( \"Turning backlight on\" ) lcd . backlight_on () if count % 10 == 6 : print ( \"Turning display off\" ) lcd . display_off () if count % 10 == 7 : print ( \"Turning display on\" ) lcd . display_on () if count % 10 == 8 : print ( \"Filling display\" ) lcd . clear () string = \"\" for x in range ( 32 , 32 + I2C_NUM_ROWS * I2C_NUM_COLS ): string += chr ( x ) lcd . putstr ( string ) count += 1 utime . sleep ( 2 ) #if __name__ == \"__main__\": test_main () References MFitzp article on OLED displays Adafruit SSD1306 Driver Adafruit LCD Guide","title":"Character LCD"},{"location":"displays/10-character-lcd-display/#character-lcd-display","text":"This lesson is for using the LCM1602 I2C LCD interface. It is a popular It has four wires: GND - connect to any GND pin VCC - connect to 3V3(out) pin unless you have a 3.3 to 5v voltage converter SDA - connect to GP0 SCL - connect to GP1 The photo above shows the use of a 3.3 to 5v voltage converter. This allows us to use the full 5v to the LCD backlight so we get bright contrast. You can connect the VCC to the 3V3(out) pin but the display will be harder to read.","title":"Character LCD Display"},{"location":"displays/10-character-lcd-display/#i2c-address-scanner-test","text":"Our first task is to make sure that the 1602 chip's I2C circuits are working. We use the following I2C scanner code to do this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import machine I2C_SDA_PIN = 0 I2C_SCL_PIN = 1 i2c = machine . I2C ( 0 , sda = machine . Pin ( I2C_SDA_PIN ), scl = machine . Pin ( I2C_SCL_PIN ), freq = 400000 ) print ( 'Scanning I2C bus.' ) devices = i2c . scan () # this returns a list of devices device_count = len ( devices ) if device_count == 0 : print ( 'No i2c device found.' ) else : print ( device_count , 'devices found.' ) for device in devices : print ( 'Decimal address:' , device , \", Hex address: \" , hex ( device ))","title":"I2C Address Scanner Test"},{"location":"displays/10-character-lcd-display/#scanner-result","text":"1 2 3 Scanning I2C bus. 1 devices found. Decimal address: 39 , Hex address: 0x27","title":"Scanner Result"},{"location":"displays/10-character-lcd-display/#testing-the-lcd","text":"1 2 3 4 5 6 7 8 9 10 11 from machine import I2C from lcd_api import LcdApi from pico_i2c_lcd import I2cLcd I2C_ADDR = 0x27 I2C_NUM_ROWS = 2 I2C_NUM_COLS = 16 i2c = I2C ( 0 , sda = machine . Pin ( 0 ), scl = machine . Pin ( 1 ), freq = 400000 ) lcd = I2cLcd ( i2c , I2C_ADDR , I2C_NUM_ROWS , I2C_NUM_COLS ) lcd . putstr ( \"CoderDojo Rocks!\" )","title":"Testing the LCD"},{"location":"displays/10-character-lcd-display/#putting-the-device-through-display-option-tests","text":"Now that we know how to display text on the device, we can learn how other functions work: lcd.move_to(x,y) lcd.display_on() and lcd.display_off() lcd.show_cursor() and lcd.hide_cursor() lcd.blink_cursor_on() and lcd.blink_cursor_off() lcd.backlight_on() and lcd.backlight_off() lcd.clear() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import utime import machine from machine import I2C from lcd_api import LcdApi from pico_i2c_lcd import I2cLcd I2C_ADDR = 0x27 I2C_NUM_ROWS = 2 I2C_NUM_COLS = 16 def test_main (): #Test function for verifying basic functionality print ( \"Running test_main\" ) i2c = I2C ( 0 , sda = machine . Pin ( 0 ), scl = machine . Pin ( 1 ), freq = 400000 ) lcd = I2cLcd ( i2c , I2C_ADDR , I2C_NUM_ROWS , I2C_NUM_COLS ) lcd . putstr ( \"CoderDojo Rocks!\" ) utime . sleep ( 10 ) lcd . clear () count = 0 while True : lcd . clear () time = utime . localtime () lcd . putstr ( \" {year:>04d} / {month:>02d} / {day:>02d} {HH:>02d} : {MM:>02d} : {SS:>02d} \" . format ( year = time [ 0 ], month = time [ 1 ], day = time [ 2 ], HH = time [ 3 ], MM = time [ 4 ], SS = time [ 5 ])) if count % 10 == 0 : print ( \"Turning cursor on\" ) lcd . show_cursor () if count % 10 == 1 : print ( \"Turning cursor off\" ) lcd . hide_cursor () if count % 10 == 2 : print ( \"Turning blink cursor on\" ) lcd . blink_cursor_on () if count % 10 == 3 : print ( \"Turning blink cursor off\" ) lcd . blink_cursor_off () if count % 10 == 4 : print ( \"Turning backlight off\" ) lcd . backlight_off () if count % 10 == 5 : print ( \"Turning backlight on\" ) lcd . backlight_on () if count % 10 == 6 : print ( \"Turning display off\" ) lcd . display_off () if count % 10 == 7 : print ( \"Turning display on\" ) lcd . display_on () if count % 10 == 8 : print ( \"Filling display\" ) lcd . clear () string = \"\" for x in range ( 32 , 32 + I2C_NUM_ROWS * I2C_NUM_COLS ): string += chr ( x ) lcd . putstr ( string ) count += 1 utime . sleep ( 2 ) #if __name__ == \"__main__\": test_main ()","title":"Putting the Device Through Display Option Tests"},{"location":"displays/10-character-lcd-display/#references","text":"MFitzp article on OLED displays Adafruit SSD1306 Driver Adafruit LCD Guide","title":"References"},{"location":"displays/11-lcd-waveshare/","text":"Waveshare LCD Specification Description: 1.8 inch TFT LCD Display Module For Raspberry Pi Pico List price: $10 US + shipping 65K RGB Colors Resolution: 160\u00d7128 Pixels Interface: SPI Driver: ST7735S Driver Onboard Female Pin Header For Direct Attaching To Raspberry Pi Pico Pixel size: 0.219 \u00d7 0.219 mm Dimensions 52.0 \u00d7 34.5 mm Operating voltage: 2.6~5.5V 18 bits per pixel (6 bits per color) References Waveshare spec Waveshare wiki Demo Code ST7735S Datasheet","title":"LCD Waveshare"},{"location":"displays/11-lcd-waveshare/#waveshare-lcd","text":"","title":"Waveshare LCD"},{"location":"displays/11-lcd-waveshare/#specification","text":"Description: 1.8 inch TFT LCD Display Module For Raspberry Pi Pico List price: $10 US + shipping 65K RGB Colors Resolution: 160\u00d7128 Pixels Interface: SPI Driver: ST7735S Driver Onboard Female Pin Header For Direct Attaching To Raspberry Pi Pico Pixel size: 0.219 \u00d7 0.219 mm Dimensions 52.0 \u00d7 34.5 mm Operating voltage: 2.6~5.5V 18 bits per pixel (6 bits per color)","title":"Specification"},{"location":"displays/11-lcd-waveshare/#references","text":"Waveshare spec Waveshare wiki Demo Code ST7735S Datasheet","title":"References"},{"location":"displays/12-e-paper-display/","text":"Raspberry Pi E-Paper Displays with Specifications 2.9inch capacitive touch ePaper module, 296\u00d7128 resolution 5-points touch support, user-defined wakeup gesture No backlight, keeps displaying last content for a long time even when power down Ultra low power consumption, basically power is only required for refreshing SPI / I2C interface, requires minimal IO pins Comes with development resources and manual (Raspberry Pi Pico C/C++ and MicroPython examples) Resources Waveshare Product Page Waveshare Wiki [Sample MicroPython Driver](https://github.com/waveshare/Pico_ePaper_Code/blob/main/python/0Pico-ePaper-5.65f.py","title":"E-Paper"},{"location":"displays/12-e-paper-display/#raspberry-pi-e-paper-displays-with","text":"","title":"Raspberry Pi E-Paper Displays with"},{"location":"displays/12-e-paper-display/#specifications","text":"2.9inch capacitive touch ePaper module, 296\u00d7128 resolution 5-points touch support, user-defined wakeup gesture No backlight, keeps displaying last content for a long time even when power down Ultra low power consumption, basically power is only required for refreshing SPI / I2C interface, requires minimal IO pins Comes with development resources and manual (Raspberry Pi Pico C/C++ and MicroPython examples)","title":"Specifications"},{"location":"displays/12-e-paper-display/#resources","text":"Waveshare Product Page Waveshare Wiki [Sample MicroPython Driver](https://github.com/waveshare/Pico_ePaper_Code/blob/main/python/0Pico-ePaper-5.65f.py","title":"Resources"},{"location":"displays/14-lcd-st7789V/","text":"MicroPython ST7789V LCD Display The Sitronix ST7789 is a driver chip for small color IPS LCD displays that supports SPI interfaces. This example uses a 2-inch color LDC display manufactured by Waveshare with a retail price of approximately $13 or $14.75 on Amazon Prime . Specifications Resolution: 240(V) x 320(H) RGB 18 bit color (6 bits for R, G and B) 1,382,400 bits of display memory Interface: 4-wire SPI (kind of) Operating voltage: 3.3V Note: The ST7789 uses a SPI interfaces but not a true standard SPI protocol. The device only uses MOSI (DIN) to send data from master to slave for LCD display. Only four wires are needed to connect from the Pico to the device. Device Interface Interface VCC Power (3.3V input) GND Ground DIN SPI data input CLK SPI clock input CS Chip selection, low active DC Data/Command selection (high for data, low for command) RST Reset, low active BL Backlight - tie to GND to turn the backlight on Although the device has eight wires, your Pico only needs a few of them to be controlled by the GIPO ports. Uploading the ST7789V Python Firmware The firmware contains pre-compiled objects for various devices with the st7789 C driver and frozen python font files. The library for the driver is delivered as a single firmware.uf2 file available here: https://github.com/russhughes/st7789_mpy/tree/master/firmware/RP2 To load this file you will need to hold down the BOTSEL button on the Pico and drag this file into the RP2 folder that is mounted. MicroPython Initialization I used the following SPI Device ID 1 pinout on the lower left corner of the Pico: Pin GP Number Label on LCD 14 (GP10) BL 15 (GP11) RST 16 (GP12) DC 17 (GP13) CS 18 (GND) GND 19 (GP14) CLK 20 (GP15) DIN Sample Device Initialize 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from machine import Pin , SPI import st7789 BACKLIGHT_PIN = 10 RESET_PIN = 11 DC_PIN = 12 CS_PIN = 13 CLK_PIN = 14 DIN_PIN = 15 # lower left corner import vga1_bold_16x32 as font spi = SPI ( 1 , baudrate = 31250000 , sck = Pin ( CLK_PIN ), mosi = Pin ( DIN_PIN )) tft = st7789 . ST7789 ( spi , 240 , 320 , reset = Pin ( RESET_PIN , Pin . OUT ), cs = Pin ( CS_PIN , Pin . OUT ), dc = Pin ( DC_PIN , Pin . OUT ), backlight = Pin ( BACKLIGHT_PIN , Pin . OUT ), rotation = 3 ) tft . init () # draw white letters on a back background at 10 over and 20 down tft . text ( font , \"Hello World!\" , 10 , 20 , st7789 . color565 ( 255 , 255 , 255 ), st7789 . color565 ( 0 , 0 , 0 )) Sample Hello World In Four Colors 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from machine import Pin , SPI import st7789 BACKLIGHT_PIN = 10 RESET_PIN = 11 DC_PIN = 12 CS_PIN = 13 CLK_PIN = 14 DIN_PIN = 15 # lower left corner import vga1_bold_16x32 as font spi = SPI ( 1 , baudrate = 31250000 , sck = Pin ( CLK_PIN ), mosi = Pin ( DIN_PIN )) tft = st7789 . ST7789 ( spi , 240 , 320 , reset = Pin ( RESET_PIN , Pin . OUT ), cs = Pin ( CS_PIN , Pin . OUT ), dc = Pin ( DC_PIN , Pin . OUT ), backlight = Pin ( BACKLIGHT_PIN , Pin . OUT ), rotation = 3 ) tft . init () tft . text ( font , \"Hello World!\" , 10 , 0 , st7789 . color565 ( 255 , 255 , 255 ), st7789 . color565 ( 0 , 0 , 0 )) tft . text ( font , \"Hello World!\" , 10 , 50 , st7789 . color565 ( 255 , 0 , 0 ), st7789 . color565 ( 0 , 0 , 0 )) tft . text ( font , \"Hello World!\" , 10 , 100 , st7789 . color565 ( 0 , 255 , 0 ), st7789 . color565 ( 0 , 0 , 0 )) tft . text ( font , \"Hello World!\" , 10 , 150 , st7789 . color565 ( 0 , 0 , 255 ), st7789 . color565 ( 0 , 0 , 0 )) Driver Implementation Notes The ST7789V supports RGB444, RGB565 and RGB666 three formats. The Waveshare LCD uses RGB565. For most LCD controllers, the communication method of the controller can be configured, they are usually using 8080 parallel interface, 3-line SPI, 4-line SPI, and other communication methods. This LCD uses a 4-line SPI interface for reducing GPIO and fast speed.LCD RESX: Reset, should be pull-down when power on, set to 1 other time. CSX: Slave chip select. The chip is enabled only CS is set Low D/CX: Data/Command selection; DC=0, write command; DC=1, write data SDA: Data transmitted. (RGB data) SCL: SPI clock Timing Diagram You can see what data needs to be changing from the timing diagram below: The SPI communication protocol of the data transmission uses control bits: clock phase (CPHA) and clock polarity (CPOL) CPOL defines the level while the synchronization clock is idle. If CPOL=0, then it is LOW. CPHA defines at whish clock\u2019s tick the data transmission starts. CPHL=0 \u2013 at the first one, otherwise at the second one This combination of two bits provides 4 modes of SPI data transmission. The commonly used is SPI0 mode, i.e. GPHL=0 and CPOL=0. According to the figure above, data transmitting begins at the first falling edge, 8bit data are transmitted at one clock cycle. It is SPI0. MSB. References ST7789C Datasheet (PDF) Waveshare Wiki Waveshare Pico Dispaly","title":"Color LCD ST7789V"},{"location":"displays/14-lcd-st7789V/#micropython-st7789v-lcd-display","text":"The Sitronix ST7789 is a driver chip for small color IPS LCD displays that supports SPI interfaces. This example uses a 2-inch color LDC display manufactured by Waveshare with a retail price of approximately $13 or $14.75 on Amazon Prime .","title":"MicroPython ST7789V LCD Display"},{"location":"displays/14-lcd-st7789V/#specifications","text":"Resolution: 240(V) x 320(H) RGB 18 bit color (6 bits for R, G and B) 1,382,400 bits of display memory Interface: 4-wire SPI (kind of) Operating voltage: 3.3V Note: The ST7789 uses a SPI interfaces but not a true standard SPI protocol. The device only uses MOSI (DIN) to send data from master to slave for LCD display. Only four wires are needed to connect from the Pico to the device.","title":"Specifications"},{"location":"displays/14-lcd-st7789V/#device-interface","text":"","title":"Device Interface"},{"location":"displays/14-lcd-st7789V/#interface","text":"VCC Power (3.3V input) GND Ground DIN SPI data input CLK SPI clock input CS Chip selection, low active DC Data/Command selection (high for data, low for command) RST Reset, low active BL Backlight - tie to GND to turn the backlight on Although the device has eight wires, your Pico only needs a few of them to be controlled by the GIPO ports.","title":"Interface"},{"location":"displays/14-lcd-st7789V/#uploading-the-st7789v-python-firmware","text":"The firmware contains pre-compiled objects for various devices with the st7789 C driver and frozen python font files. The library for the driver is delivered as a single firmware.uf2 file available here: https://github.com/russhughes/st7789_mpy/tree/master/firmware/RP2 To load this file you will need to hold down the BOTSEL button on the Pico and drag this file into the RP2 folder that is mounted.","title":"Uploading the ST7789V Python Firmware"},{"location":"displays/14-lcd-st7789V/#micropython-initialization","text":"I used the following SPI Device ID 1 pinout on the lower left corner of the Pico: Pin GP Number Label on LCD 14 (GP10) BL 15 (GP11) RST 16 (GP12) DC 17 (GP13) CS 18 (GND) GND 19 (GP14) CLK 20 (GP15) DIN","title":"MicroPython Initialization"},{"location":"displays/14-lcd-st7789V/#sample-device-initialize","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from machine import Pin , SPI import st7789 BACKLIGHT_PIN = 10 RESET_PIN = 11 DC_PIN = 12 CS_PIN = 13 CLK_PIN = 14 DIN_PIN = 15 # lower left corner import vga1_bold_16x32 as font spi = SPI ( 1 , baudrate = 31250000 , sck = Pin ( CLK_PIN ), mosi = Pin ( DIN_PIN )) tft = st7789 . ST7789 ( spi , 240 , 320 , reset = Pin ( RESET_PIN , Pin . OUT ), cs = Pin ( CS_PIN , Pin . OUT ), dc = Pin ( DC_PIN , Pin . OUT ), backlight = Pin ( BACKLIGHT_PIN , Pin . OUT ), rotation = 3 ) tft . init () # draw white letters on a back background at 10 over and 20 down tft . text ( font , \"Hello World!\" , 10 , 20 , st7789 . color565 ( 255 , 255 , 255 ), st7789 . color565 ( 0 , 0 , 0 ))","title":"Sample Device Initialize"},{"location":"displays/14-lcd-st7789V/#sample-hello-world-in-four-colors","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from machine import Pin , SPI import st7789 BACKLIGHT_PIN = 10 RESET_PIN = 11 DC_PIN = 12 CS_PIN = 13 CLK_PIN = 14 DIN_PIN = 15 # lower left corner import vga1_bold_16x32 as font spi = SPI ( 1 , baudrate = 31250000 , sck = Pin ( CLK_PIN ), mosi = Pin ( DIN_PIN )) tft = st7789 . ST7789 ( spi , 240 , 320 , reset = Pin ( RESET_PIN , Pin . OUT ), cs = Pin ( CS_PIN , Pin . OUT ), dc = Pin ( DC_PIN , Pin . OUT ), backlight = Pin ( BACKLIGHT_PIN , Pin . OUT ), rotation = 3 ) tft . init () tft . text ( font , \"Hello World!\" , 10 , 0 , st7789 . color565 ( 255 , 255 , 255 ), st7789 . color565 ( 0 , 0 , 0 )) tft . text ( font , \"Hello World!\" , 10 , 50 , st7789 . color565 ( 255 , 0 , 0 ), st7789 . color565 ( 0 , 0 , 0 )) tft . text ( font , \"Hello World!\" , 10 , 100 , st7789 . color565 ( 0 , 255 , 0 ), st7789 . color565 ( 0 , 0 , 0 )) tft . text ( font , \"Hello World!\" , 10 , 150 , st7789 . color565 ( 0 , 0 , 255 ), st7789 . color565 ( 0 , 0 , 0 ))","title":"Sample Hello World In Four Colors"},{"location":"displays/14-lcd-st7789V/#driver-implementation-notes","text":"The ST7789V supports RGB444, RGB565 and RGB666 three formats. The Waveshare LCD uses RGB565. For most LCD controllers, the communication method of the controller can be configured, they are usually using 8080 parallel interface, 3-line SPI, 4-line SPI, and other communication methods. This LCD uses a 4-line SPI interface for reducing GPIO and fast speed.LCD RESX: Reset, should be pull-down when power on, set to 1 other time. CSX: Slave chip select. The chip is enabled only CS is set Low D/CX: Data/Command selection; DC=0, write command; DC=1, write data SDA: Data transmitted. (RGB data) SCL: SPI clock","title":"Driver Implementation Notes"},{"location":"displays/14-lcd-st7789V/#timing-diagram","text":"You can see what data needs to be changing from the timing diagram below: The SPI communication protocol of the data transmission uses control bits: clock phase (CPHA) and clock polarity (CPOL) CPOL defines the level while the synchronization clock is idle. If CPOL=0, then it is LOW. CPHA defines at whish clock\u2019s tick the data transmission starts. CPHL=0 \u2013 at the first one, otherwise at the second one This combination of two bits provides 4 modes of SPI data transmission. The commonly used is SPI0 mode, i.e. GPHL=0 and CPOL=0. According to the figure above, data transmitting begins at the first falling edge, 8bit data are transmitted at one clock cycle. It is SPI0. MSB.","title":"Timing Diagram"},{"location":"displays/14-lcd-st7789V/#references","text":"ST7789C Datasheet (PDF) Waveshare Wiki Waveshare Pico Dispaly","title":"References"},{"location":"displays/15-cu1609c-led/","text":"CU1609C LED Display Note: This is a work-in-progress. We have not found a MicroPython driver for this display. The UC1609 is a graphic LED driver chip with an SPI interface. Because it is low cost ($4) and 2 inches across it is ideal for low-cost robot displays. 192X62 LCD display for $4 USB device Connections Pin Name Description 1 K Backlight Cathode Connect to GND rail 2 A Backlight Anode Connect via 200 ohm to 3.2v rail to limit backlight current to 3 milliamps. The current for backlight is limited to 20 milliamps. 3 GND Ground Connect to GND rail 4 VDD Power Supply connect to +3.3v rail 5 SCK Serial clock input. Connect to SPI CLK 6 SDA Serial data input. Connect to SPI Data SCL 7 RST Connect to 3.3v rail. 8 CD It determines whether the access is related to data or command. Connect to GPIO 9 CS Chip select input. Connect to GND when LCD is use. Connection Notes When RST=L, all control registers are re-initialized by their default sates. Since UC1609c has built-in Power-on Reset, the RST pin is not required for proper chip operation. An RC filter has been included on-chip. There is no need for external RC noise filter. When RST is not used, connect the pin to High. CS determines whether the access is related to data or command. When CS=\u201cH\u201d : Display data. When CS=\u201cL\u201d : Command. Hello World 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin , SPI SPI_CLK = 2 # SPI clock SPI_SDA = 3 CD = 5 # command or data # RST is tied to 3.3v # CS is tied to GND # SPI(0, baudrate=992063, polarity=0, phase=0, bits=8, sck=2, mosi=3, miso=4) spi = SPI ( 0 , baudrate = 31250000 , sck = Pin ( SPI_CLK ), mosi = Pin ( SPI_SDA )) print ( spi ) Similar Drivers There are two similar drivers. One is for the LCD160CR LCD160CR Display Driver The other is the Arduino C version by Gavin Lyones that has been around for a long time. Gavin Lyons GitHub Repo supporting the UC1609 Our goal is to port Gavin's C code to use the same function as the LCD160CR driver. References BuyDisplay Product 2 inch Blue 192x64 Graphic LCD Display Module,UC1609,SPI for $3.48 ERM19264-4 SeriesGraphic Display Module Datasheet Gavin Lyons GitHub Repo supporting the UC1609 EBay Product 2 inch White 192x64 Graphic LCD Display Module,UC1609,SPI MicroPython Pyboard LCD Class List of LCD Graphic Displays","title":"Graphic LCD"},{"location":"displays/15-cu1609c-led/#cu1609c-led-display","text":"Note: This is a work-in-progress. We have not found a MicroPython driver for this display. The UC1609 is a graphic LED driver chip with an SPI interface. Because it is low cost ($4) and 2 inches across it is ideal for low-cost robot displays. 192X62 LCD display for $4 USB device","title":"CU1609C LED Display"},{"location":"displays/15-cu1609c-led/#connections","text":"Pin Name Description 1 K Backlight Cathode Connect to GND rail 2 A Backlight Anode Connect via 200 ohm to 3.2v rail to limit backlight current to 3 milliamps. The current for backlight is limited to 20 milliamps. 3 GND Ground Connect to GND rail 4 VDD Power Supply connect to +3.3v rail 5 SCK Serial clock input. Connect to SPI CLK 6 SDA Serial data input. Connect to SPI Data SCL 7 RST Connect to 3.3v rail. 8 CD It determines whether the access is related to data or command. Connect to GPIO 9 CS Chip select input. Connect to GND when LCD is use.","title":"Connections"},{"location":"displays/15-cu1609c-led/#connection-notes","text":"When RST=L, all control registers are re-initialized by their default sates. Since UC1609c has built-in Power-on Reset, the RST pin is not required for proper chip operation. An RC filter has been included on-chip. There is no need for external RC noise filter. When RST is not used, connect the pin to High. CS determines whether the access is related to data or command. When CS=\u201cH\u201d : Display data. When CS=\u201cL\u201d : Command.","title":"Connection Notes"},{"location":"displays/15-cu1609c-led/#hello-world","text":"1 2 3 4 5 6 7 8 9 10 11 from machine import Pin , SPI SPI_CLK = 2 # SPI clock SPI_SDA = 3 CD = 5 # command or data # RST is tied to 3.3v # CS is tied to GND # SPI(0, baudrate=992063, polarity=0, phase=0, bits=8, sck=2, mosi=3, miso=4) spi = SPI ( 0 , baudrate = 31250000 , sck = Pin ( SPI_CLK ), mosi = Pin ( SPI_SDA )) print ( spi )","title":"Hello World"},{"location":"displays/15-cu1609c-led/#similar-drivers","text":"There are two similar drivers. One is for the LCD160CR LCD160CR Display Driver The other is the Arduino C version by Gavin Lyones that has been around for a long time. Gavin Lyons GitHub Repo supporting the UC1609 Our goal is to port Gavin's C code to use the same function as the LCD160CR driver.","title":"Similar Drivers"},{"location":"displays/15-cu1609c-led/#references","text":"BuyDisplay Product 2 inch Blue 192x64 Graphic LCD Display Module,UC1609,SPI for $3.48 ERM19264-4 SeriesGraphic Display Module Datasheet Gavin Lyons GitHub Repo supporting the UC1609 EBay Product 2 inch White 192x64 Graphic LCD Display Module,UC1609,SPI MicroPython Pyboard LCD Class List of LCD Graphic Displays","title":"References"},{"location":"displays/16-tft-LI9341/","text":"LI9341 TDF Display This is a $18 240X320 color display that is easy to setup. Sample SPI Driver Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # test of printing multiple fonts to the ILI9341 on an M5Stack using H/W SP # MIT License; Copyright (c) 2017 Jeffrey N. Magee from ili934xnew import ILI9341 , color565 from machine import Pin , SPI import m5stack import tt14 import glcdfont import tt14 import tt24 import tt32 fonts = [ glcdfont , tt14 , tt24 , tt32 ] text = 'Now is the time for all good men to come to the aid of the party.' power = Pin ( m5stack . TFT_LED_PIN , Pin . OUT ) power . value ( 1 ) spi = SPI ( 2 , baudrate = 40000000 , miso = Pin ( m5stack . TFT_MISO_PIN ), mosi = Pin ( m5stack . TFT_MOSI_PIN ), sck = Pin ( m5stack . TFT_CLK_PIN )) display = ILI9341 ( spi , cs = Pin ( m5stack . TFT_CS_PIN ), dc = Pin ( m5stack . TFT_DC_PIN ), rst = Pin ( m5stack . TFT_RST_PIN ), w = 320 , h = 240 , r = 3 ) display . erase () display . set_pos ( 0 , 0 ) for ff in fonts : display . set_font ( ff ) display . print ( text ) References https://github.com/jeffmer/micropython-ili9341 HiLetgo ILI9341 2.8\" SPI TFT LCD Display Touch Panel 240X320 with PCB 5V/3.3V STM32 Jeff Mer MicroPytho Driver for the LIL9341 Display","title":"LI9341 TDF Display"},{"location":"displays/16-tft-LI9341/#li9341-tdf-display","text":"This is a $18 240X320 color display that is easy to setup.","title":"LI9341 TDF Display"},{"location":"displays/16-tft-LI9341/#sample-spi-driver-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # test of printing multiple fonts to the ILI9341 on an M5Stack using H/W SP # MIT License; Copyright (c) 2017 Jeffrey N. Magee from ili934xnew import ILI9341 , color565 from machine import Pin , SPI import m5stack import tt14 import glcdfont import tt14 import tt24 import tt32 fonts = [ glcdfont , tt14 , tt24 , tt32 ] text = 'Now is the time for all good men to come to the aid of the party.' power = Pin ( m5stack . TFT_LED_PIN , Pin . OUT ) power . value ( 1 ) spi = SPI ( 2 , baudrate = 40000000 , miso = Pin ( m5stack . TFT_MISO_PIN ), mosi = Pin ( m5stack . TFT_MOSI_PIN ), sck = Pin ( m5stack . TFT_CLK_PIN )) display = ILI9341 ( spi , cs = Pin ( m5stack . TFT_CS_PIN ), dc = Pin ( m5stack . TFT_DC_PIN ), rst = Pin ( m5stack . TFT_RST_PIN ), w = 320 , h = 240 , r = 3 ) display . erase () display . set_pos ( 0 , 0 ) for ff in fonts : display . set_font ( ff ) display . print ( text )","title":"Sample SPI Driver Code"},{"location":"displays/16-tft-LI9341/#references","text":"https://github.com/jeffmer/micropython-ili9341 HiLetgo ILI9341 2.8\" SPI TFT LCD Display Touch Panel 240X320 with PCB 5V/3.3V STM32 Jeff Mer MicroPytho Driver for the LIL9341 Display","title":"References"},{"location":"displays/17-ssd1352/","text":"OLED SSD1351 MicroPython Driver https://github.com/rdagger/micropython-ssd1351","title":"OLED SSD1351 MicroPython Driver"},{"location":"displays/17-ssd1352/#oled-ssd1351-micropython-driver","text":"https://github.com/rdagger/micropython-ssd1351","title":"OLED SSD1351 MicroPython Driver"},{"location":"displays/seven-segment/","text":"Sample Seven Segment Display Lab 4 Digit Seven Segment Display Make sure to put a current limiting resistor in series with each LED. A 330 ohm resistor is a generally safe value for 5 volt circuits and you can use a 220 ohm resistor for 3.3 volt circuits. This code was provided by Jaison Miller from his GitHub Repo . ```py from machine import Pin, PWM, Timer import utime Constants - where the pins are currently plugged into, etc. number_bitmaps = { 0: 0b00111111, 1: 0b00000110, 2: 0b01011011, 3: 0b01001111, 4: 0b01100110, 5: 0b01101101, 6: 0b01111101, 7: 0b00000111, 8: 0b01111111, 9: 0b01100111 } segment_masks = { 'a': 0b00000001, 'b': 0b00000010, 'c': 0b00000100, 'd': 0b00001000, 'e': 0b00010000, 'f': 0b00100000, 'g': 0b01000000 } pin_segments = { 'a': 10, 'b': 11, 'c': 12, 'd': 17, 'e': 16, 'f': 13, 'g': 14} pin_others = { 'decimal': 22, 'colon': 6, 'dash': 8 } pin_digits = { 1: 18, 2: 19, 3: 20, 4: 21 } pin_control_others = { 'colon': 27, 'dash': 7 } initial setup of the pins, alternatives include using PWM to set the brightness if not using PWM then make sure to use appropriate resistors to avoid blowing the LEDs in the display (like I have) segment_maps = {} for segment, pin in pin_segments.items(): segment_maps[segment] = Pin(pin, Pin.OUT) other_pin_maps = {} for feature, pin in pin_others.items(): other_pin_maps[feature] = Pin(pin, Pin.OUT) digit_maps = {} for digit, pin in pin_digits.items(): digit_maps[digit] = Pin(pin, Pin.OUT) other_maps = {} for feature, pin in pin_control_others.items(): other_maps[feature] = Pin(pin, Pin.OUT) def render_digit_display(show_digit=1, number=8, decimal=False): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # turn everything off for segment, mask in segment_masks.items(): segment_maps[segment].value(1) other_pin_maps['decimal'].value(1) # turn on the digit required to be displayed for digit, digit_pin in digit_maps.items(): if show_digit == digit: digit_pin.value(1) # print(\"\\n\\nDigit: {} - Pin: {} - Number: {}\\n\".format(digit, pin, number)) else: digit_pin.value(0) utime.sleep(0.001) display_number_bitmap = number_bitmaps[number] # check every for segment, mask in segment_masks.items(): # print(\"segment: {}\\nmask: {}\".format(segment, mask)) if display_number_bitmap & mask == mask: # print(\"segment OFF: {}\".format(segment)) segment_maps[segment].value(0) else: segment_maps[segment].value(1) # show decimal if decimal: other_pin_maps['decimal'].value(0) else: other_pin_maps['decimal'].value(1) utime.sleep(0.001) def render_feature_display(show_colon=False, show_dash=False): if show_colon: other_pin_maps['colon'].value(0) other_maps['colon'].value(1) else: other_pin_maps['colon'].value(0) other_maps['colon'].value(0) 1 2 3 4 5 6 if show_dash: other_pin_maps['dash'].value(0) other_maps['dash'].value(1) else: other_pin_maps['dash'].value(0) other_maps['dash'].value(0) while True: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lt_year, lt_month, lt_mday, lt_hour, lt_minute, lt_second, lt_weekday, lt_yearday = utime.localtime() # testing out all the features of the display digit_1_decimal = (lt_second % 4 == 0) digit_2_decimal = (lt_second % 4 == 1) digit_3_decimal = (lt_second % 4 == 2) digit_4_decimal = (lt_second % 4 == 3) render_digit_display(1, lt_minute // 10, digit_1_decimal) render_digit_display(2, lt_minute % 10, digit_2_decimal) render_digit_display(3, lt_second // 10, digit_3_decimal) render_digit_display(4, lt_second % 10, digit_4_decimal) if (lt_second % 2 == 0): render_feature_display(True, False) else: render_feature_display(False, True) ```","title":"7 Segment Display"},{"location":"displays/seven-segment/#sample-seven-segment-display-lab","text":"","title":"Sample Seven Segment Display Lab"},{"location":"displays/seven-segment/#4-digit-seven-segment-display","text":"Make sure to put a current limiting resistor in series with each LED. A 330 ohm resistor is a generally safe value for 5 volt circuits and you can use a 220 ohm resistor for 3.3 volt circuits. This code was provided by Jaison Miller from his GitHub Repo . ```py from machine import Pin, PWM, Timer import utime","title":"4 Digit Seven Segment Display"},{"location":"displays/seven-segment/#constants-where-the-pins-are-currently-plugged-into-etc","text":"number_bitmaps = { 0: 0b00111111, 1: 0b00000110, 2: 0b01011011, 3: 0b01001111, 4: 0b01100110, 5: 0b01101101, 6: 0b01111101, 7: 0b00000111, 8: 0b01111111, 9: 0b01100111 } segment_masks = { 'a': 0b00000001, 'b': 0b00000010, 'c': 0b00000100, 'd': 0b00001000, 'e': 0b00010000, 'f': 0b00100000, 'g': 0b01000000 } pin_segments = { 'a': 10, 'b': 11, 'c': 12, 'd': 17, 'e': 16, 'f': 13, 'g': 14} pin_others = { 'decimal': 22, 'colon': 6, 'dash': 8 } pin_digits = { 1: 18, 2: 19, 3: 20, 4: 21 } pin_control_others = { 'colon': 27, 'dash': 7 }","title":"Constants - where the pins are currently plugged into, etc."},{"location":"displays/seven-segment/#initial-setup-of-the-pins-alternatives-include-using-pwm-to-set-the-brightness","text":"","title":"initial setup of the pins, alternatives include using PWM to set the brightness"},{"location":"displays/seven-segment/#if-not-using-pwm-then-make-sure-to-use-appropriate-resistors-to-avoid-blowing-the-leds-in-the-display-like-i-have","text":"segment_maps = {} for segment, pin in pin_segments.items(): segment_maps[segment] = Pin(pin, Pin.OUT) other_pin_maps = {} for feature, pin in pin_others.items(): other_pin_maps[feature] = Pin(pin, Pin.OUT) digit_maps = {} for digit, pin in pin_digits.items(): digit_maps[digit] = Pin(pin, Pin.OUT) other_maps = {} for feature, pin in pin_control_others.items(): other_maps[feature] = Pin(pin, Pin.OUT) def render_digit_display(show_digit=1, number=8, decimal=False): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # turn everything off for segment, mask in segment_masks.items(): segment_maps[segment].value(1) other_pin_maps['decimal'].value(1) # turn on the digit required to be displayed for digit, digit_pin in digit_maps.items(): if show_digit == digit: digit_pin.value(1) # print(\"\\n\\nDigit: {} - Pin: {} - Number: {}\\n\".format(digit, pin, number)) else: digit_pin.value(0) utime.sleep(0.001) display_number_bitmap = number_bitmaps[number] # check every for segment, mask in segment_masks.items(): # print(\"segment: {}\\nmask: {}\".format(segment, mask)) if display_number_bitmap & mask == mask: # print(\"segment OFF: {}\".format(segment)) segment_maps[segment].value(0) else: segment_maps[segment].value(1) # show decimal if decimal: other_pin_maps['decimal'].value(0) else: other_pin_maps['decimal'].value(1) utime.sleep(0.001) def render_feature_display(show_colon=False, show_dash=False): if show_colon: other_pin_maps['colon'].value(0) other_maps['colon'].value(1) else: other_pin_maps['colon'].value(0) other_maps['colon'].value(0) 1 2 3 4 5 6 if show_dash: other_pin_maps['dash'].value(0) other_maps['dash'].value(1) else: other_pin_maps['dash'].value(0) other_maps['dash'].value(0) while True: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lt_year, lt_month, lt_mday, lt_hour, lt_minute, lt_second, lt_weekday, lt_yearday = utime.localtime() # testing out all the features of the display digit_1_decimal = (lt_second % 4 == 0) digit_2_decimal = (lt_second % 4 == 1) digit_3_decimal = (lt_second % 4 == 2) digit_4_decimal = (lt_second % 4 == 3) render_digit_display(1, lt_minute // 10, digit_1_decimal) render_digit_display(2, lt_minute % 10, digit_2_decimal) render_digit_display(3, lt_second // 10, digit_3_decimal) render_digit_display(4, lt_second % 10, digit_4_decimal) if (lt_second % 2 == 0): render_feature_display(True, False) else: render_feature_display(False, True) ```","title":"if not using PWM then make sure to use appropriate resistors to avoid blowing the LEDs in the display (like I have)"},{"location":"getting-started/01-intro/","text":"Welcome to the CoderDojo course on MicroPython This course is about MicroPython , a variation of the popular Python programming language that is used to program microcontrollers . Intended Audience Junior High or High School Students Age 10-16 Preferred Skills Familiarity with basic text editing functions such as select, copy and paste Understand how to save files to disk Basic understanding of Python programming language ( We strongly suggest you take the Introduction to Python Programming CoderDojo Course if you are not familiar with Python. ) User should be familiar with the the following Python concepts: imports libraries variables loops conditionals lists functions function parameters Course Outline What is a Microcontroller? What is Micropython? Raspberry Pi Pico Getting Started: Setting up MicroPython environment using Thonny or VS Code Introduction to MicroPython - Getting Started Sensors: getting information about the world around us Displays: showing information to users Sound and Music: playing tones, sounds and music OLED Displays: drawing on displays Robots: making robots move around with motors Advanced Topics License of Content Our intent is to allow teachers and mentors around the world to integrate MicroPython into their courses without any fees. We want you to be able to use this content freely with a few conditions: please give us attribution and please don't resell our content for profit. Note that we use the same Creative Commons licensing as the Raspberry Pi Foundation and the CoderDojo Foundation: Creative Commons Attribution NonCommercial ShareAlike This means you are free to reuse and remix this content for non-commercial educational purposes as long as you keep the attribution and preserve the license agreement.","title":"Introduction"},{"location":"getting-started/01-intro/#welcome-to-the-coderdojo-course-on-micropython","text":"This course is about MicroPython , a variation of the popular Python programming language that is used to program microcontrollers .","title":"Welcome to the CoderDojo course on MicroPython"},{"location":"getting-started/01-intro/#intended-audience","text":"Junior High or High School Students Age 10-16","title":"Intended Audience"},{"location":"getting-started/01-intro/#preferred-skills","text":"Familiarity with basic text editing functions such as select, copy and paste Understand how to save files to disk Basic understanding of Python programming language ( We strongly suggest you take the Introduction to Python Programming CoderDojo Course if you are not familiar with Python. ) User should be familiar with the the following Python concepts: imports libraries variables loops conditionals lists functions function parameters","title":"Preferred Skills"},{"location":"getting-started/01-intro/#course-outline","text":"What is a Microcontroller? What is Micropython? Raspberry Pi Pico Getting Started: Setting up MicroPython environment using Thonny or VS Code Introduction to MicroPython - Getting Started Sensors: getting information about the world around us Displays: showing information to users Sound and Music: playing tones, sounds and music OLED Displays: drawing on displays Robots: making robots move around with motors Advanced Topics","title":"Course Outline"},{"location":"getting-started/01-intro/#license-of-content","text":"Our intent is to allow teachers and mentors around the world to integrate MicroPython into their courses without any fees. We want you to be able to use this content freely with a few conditions: please give us attribution and please don't resell our content for profit. Note that we use the same Creative Commons licensing as the Raspberry Pi Foundation and the CoderDojo Foundation: Creative Commons Attribution NonCommercial ShareAlike This means you are free to reuse and remix this content for non-commercial educational purposes as long as you keep the attribution and preserve the license agreement.","title":"License of Content"},{"location":"getting-started/01a-microcontrollers/","text":"Microcontrollers This lesson is an overview of microcontrollers and their role in teaching physical computing . A microcontroller is a small low-cost computer used to control physical devices such as LED, servos and motors. Microcontroller boards typically cost around $4 to $6 and are an ideal way to learn about computer science because you can use them to build fun projects. For example you can control a row of LEDs, move a robot and sense the world around us with a variety of light, sound and motion sensors. In the past, microcontrollers were difficult for younger students to program. They were also too expensive for every student to purchase and take home. A typical Arduino kit could easily cost over $20 and required you to learn C to program it. Today, microcontrollers such as the Raspberry Pi Pico and the ESP32 cost as little as two dollars. And these devices are designed to be programmed in Python, the most popular programming language for students. What is Physical Computing? Physical Computing is a field of study that can sense and respond to the world around us. Unlike programming a cell phone or a laptop computer, our focus is reading sensor values and quickly responding to changes. Physical Computing is widely used to teach principals of computer science because students can create their own projects and express creativity such a controlling the patterns of lights or creating complex sounds. How Microcontrollers are Used Microcontrollers do three things: They read sensor values of the world around them They transform this data into useful representations They send outputs to devices that control the world such as LEDs and motors as well as displays Here is a general diagram to think about when you are designing microcontroller systems: Here is a specific example instance of what inputs and outputs might do. Programming a Microcontroller In this class, we will use the MicroPython to program our Microcontroller. Our programs will usually have the following structure: Imports : Specify the Python libraries used in the code ( More Information on Python libraries are available here ) Setup : Setup/ Initialize variables and sensors Main loop : Continuously monitor sensor inputs and take actions The following is an example code in Micropython: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Import Section import machine import time # Setup Section led = machine . Pin ( 16 , machine . Pin . OUT ) # Main Loop while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) Almost all our programs will start with the import machine line. This tells the system that we need to gather all the libraries that understand our physical machine. If you couldn't understand the example program - don't worry! We will be going through it in detail as we work on our labs.","title":"Microcontrollers"},{"location":"getting-started/01a-microcontrollers/#microcontrollers","text":"This lesson is an overview of microcontrollers and their role in teaching physical computing . A microcontroller is a small low-cost computer used to control physical devices such as LED, servos and motors. Microcontroller boards typically cost around $4 to $6 and are an ideal way to learn about computer science because you can use them to build fun projects. For example you can control a row of LEDs, move a robot and sense the world around us with a variety of light, sound and motion sensors. In the past, microcontrollers were difficult for younger students to program. They were also too expensive for every student to purchase and take home. A typical Arduino kit could easily cost over $20 and required you to learn C to program it. Today, microcontrollers such as the Raspberry Pi Pico and the ESP32 cost as little as two dollars. And these devices are designed to be programmed in Python, the most popular programming language for students.","title":"Microcontrollers"},{"location":"getting-started/01a-microcontrollers/#what-is-physical-computing","text":"Physical Computing is a field of study that can sense and respond to the world around us. Unlike programming a cell phone or a laptop computer, our focus is reading sensor values and quickly responding to changes. Physical Computing is widely used to teach principals of computer science because students can create their own projects and express creativity such a controlling the patterns of lights or creating complex sounds.","title":"What is Physical Computing?"},{"location":"getting-started/01a-microcontrollers/#how-microcontrollers-are-used","text":"Microcontrollers do three things: They read sensor values of the world around them They transform this data into useful representations They send outputs to devices that control the world such as LEDs and motors as well as displays Here is a general diagram to think about when you are designing microcontroller systems: Here is a specific example instance of what inputs and outputs might do.","title":"How Microcontrollers are Used"},{"location":"getting-started/01a-microcontrollers/#programming-a-microcontroller","text":"In this class, we will use the MicroPython to program our Microcontroller. Our programs will usually have the following structure: Imports : Specify the Python libraries used in the code ( More Information on Python libraries are available here ) Setup : Setup/ Initialize variables and sensors Main loop : Continuously monitor sensor inputs and take actions The following is an example code in Micropython: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Import Section import machine import time # Setup Section led = machine . Pin ( 16 , machine . Pin . OUT ) # Main Loop while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) Almost all our programs will start with the import machine line. This tells the system that we need to gather all the libraries that understand our physical machine. If you couldn't understand the example program - don't worry! We will be going through it in detail as we work on our labs.","title":"Programming a Microcontroller"},{"location":"getting-started/01b-libraries/","text":"What is MicroPython? MicroPython is an implementation of the Python 3 programming language that includes a small subset of the Python standard library and is optimized to run on microcontrollers. ( From micropython.org ) MicroPython was originally created by the Australian programmer and physicist Damien George. It is written in C . MicroPython is now an OpenSource project and the source code is available in GitHub . Micropython Libraries When you start up your IDE, it may have a list of python modules built in. You can list the current modules you have installed by running the help('modules') command. 1 help ( 'modules' ) MicroPython Builtin Functions MicroPython is designed to run quickly in a small memory system. So it has trimmed down many of the standard Python libraries to fit the needs of microcontrollers. Most of these libraries start with the letter \"u\" so that you are aware they are designed to run on microcontrollers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cmath \u2013 mathematical functions for complex numbers gc \u2013 control the garbage collector math \u2013 mathematical functions uarray \u2013 arrays of numeric data uasyncio \u2014 asynchronous I/O scheduler ubinascii \u2013 binary/ASCII conversions ucollections \u2013 collection and container types uerrno \u2013 system error codes uhashlib \u2013 hashing algorithms uheapq \u2013 heap queue algorithm uio \u2013 input/output streams ujson \u2013 JSON encoding and decoding uos \u2013 basic \u201coperating system\u201d services ure \u2013 simple regular expressions uselect \u2013 wait for events on a set of streams usocket \u2013 socket module ussl \u2013 SSL/TLS module ustruct \u2013 pack and unpack primitive data types usys \u2013 system specific functions utime \u2013 time related functions uzlib \u2013 zlib decompression _thread \u2013 multithreading support MicroPython Specific Libraries 1 2 3 4 5 6 7 8 btree \u2013 simple BTree database framebuf \u2014 frame buffer manipulation machine \u2014 functions related to the hardware micropython \u2013 access and control MicroPython internals network \u2014 network configuration ubluetooth \u2014 low-level Bluetooth ucryptolib \u2013 cryptographic ciphers uctypes \u2013 access binary data in a structured way Adding a module When you are using python and you attempt to use a module that python can't find you will get an error. You must then use the python pip installer tool to add the new library. Getting MicroPython Libraries from PyPi Filter Only MicroPython Libraries Full List of modules 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 ESP-test audioop filecmp random __future__ base64 fileinput re _abc bcrypt fnmatch readline _ast bdb formatter reedsolo _asyncio binascii fractions reprlib _bisect binhex ftplib resource _blake2 bisect functools rlcompleter _bootlocale bitstring gc runpy _bz2 blink-builtin-led genericpath sched _cffi_backend brain_argparse getopt secrets _codecs brain_attrs getpass select _codecs_cn brain_builtin_inference gettext selectors _codecs_hk brain_collections glob send2trash _codecs_iso2022 brain_crypt grp serial _codecs_jp brain_curses gzip setuptools _codecs_kr brain_dataclasses hashlib sh1106 _codecs_tw brain_dateutil heapq sh1106-test _collections brain_fstrings hmac shelve _collections_abc brain_functools html shlex _compat_pickle brain_gi http shutil _compression brain_hashlib i2c-display signal _contextvars brain_http i2c-scanner site _crypt brain_io i2c_lcd six _csv brain_mechanize i2clcd smtpd _ctypes brain_multiprocessing imaplib smtplib _ctypes_test brain_namedtuple_enum imghdr sndhdr _curses brain_nose imp socket _curses_panel brain_numpy_core_fromnumeric importlib socketserver _datetime brain_numpy_core_function_base inspect spi-debug _dbm brain_numpy_core_multiarray io sqlite3 _decimal brain_numpy_core_numeric ipaddress sre_compile _dummy_thread brain_numpy_core_numerictypes isort sre_constants _elementtree brain_numpy_core_umath itertools sre_parse _functools brain_numpy_ndarray jedi ssl _hashlib brain_numpy_random_mtrand json stat _heapq brain_numpy_utils keyword statistics _imp brain_pkg_resources lazy_object_proxy string _io brain_pytest led-strip stringprep _json brain_qt lib2to3 struct _locale brain_random linecache subprocess _lsprof brain_re list-modules sunau _lzma brain_six locale symbol _markupbase brain_ssl logging symtable _md5 brain_subprocess lzma sys _multibytecodec brain_threading macpath sysconfig _multiprocessing brain_typing mailbox syslog _opcode brain_uuid mailcap tabnanny _operator builtins marshal tarfile _osx_support bz2 math telnetlib _pickle cProfile mccabe tempfile _posixsubprocess calendar mimetypes termios _py_abc certifi mmap test _pydecimal cffi modulefinder textwrap _pyio cgi multiprocessing this _queue cgitb mypy thonny _random chunk mypy_extensions threading _scproxy clonevirtualenv mypyc time _sha1 cmath nacl timeit _sha256 cmd netrc tkinter _sha3 code nis token _sha512 codecs nntplib tokenize _signal codeop ntpath toml _sitebuiltins collections nturl2path trace _socket colorsys numbers traceback _sqlite3 compileall opcode tracemalloc _sre concurrent operator tty _ssl configparser optparse turtle _stat contextlib os turtledemo _string contextvars paramiko typed_ast _strptime copy parser types _struct copyreg parso typing _symtable crypt pathlib typing_extensions _sysconfigdata_m_darwin_darwin cryptography pdb unicodedata _testbuffer csv pickle unittest _testcapi ctypes pickletools urllib _testimportmultiple curses pip uu _testmultiphase dataclasses pipenv uuid _thread datetime pipes venv _threading_local dbm pkg_resources virtualenv _tkinter decimal pkgutil virtualenv_support _tracemalloc difflib platform warnings _uuid dir-example plistlib wave _warnings dis poplib weakref _weakref distutils posix webbrowser _weakrefset doctest posixpath websockets _xxtestfuzz docutils pprint wheel abc dummy_threading profile wrapt aifc easy_install pstats wsgiref antigravity ecdsa pty xdrlib argparse email ptyprocess xml array encodings pwd xmlrpc array-test ensurepip py_compile xxlimited ast enum pyclbr xxsubtype astroid errno pycparser zipapp asttokens espefuse pydoc zipfile asynchat espressif pydoc_data zipimport asyncio espsecure pyexpat zlib asyncore esptool pylint at faulthandler queue atexit fcntl quopri","title":"MicroPython Libraries"},{"location":"getting-started/01b-libraries/#what-is-micropython","text":"MicroPython is an implementation of the Python 3 programming language that includes a small subset of the Python standard library and is optimized to run on microcontrollers. ( From micropython.org ) MicroPython was originally created by the Australian programmer and physicist Damien George. It is written in C . MicroPython is now an OpenSource project and the source code is available in GitHub .","title":"What is MicroPython?"},{"location":"getting-started/01b-libraries/#micropython-libraries","text":"When you start up your IDE, it may have a list of python modules built in. You can list the current modules you have installed by running the help('modules') command. 1 help ( 'modules' )","title":"Micropython Libraries"},{"location":"getting-started/01b-libraries/#micropython-builtin-functions","text":"MicroPython is designed to run quickly in a small memory system. So it has trimmed down many of the standard Python libraries to fit the needs of microcontrollers. Most of these libraries start with the letter \"u\" so that you are aware they are designed to run on microcontrollers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cmath \u2013 mathematical functions for complex numbers gc \u2013 control the garbage collector math \u2013 mathematical functions uarray \u2013 arrays of numeric data uasyncio \u2014 asynchronous I/O scheduler ubinascii \u2013 binary/ASCII conversions ucollections \u2013 collection and container types uerrno \u2013 system error codes uhashlib \u2013 hashing algorithms uheapq \u2013 heap queue algorithm uio \u2013 input/output streams ujson \u2013 JSON encoding and decoding uos \u2013 basic \u201coperating system\u201d services ure \u2013 simple regular expressions uselect \u2013 wait for events on a set of streams usocket \u2013 socket module ussl \u2013 SSL/TLS module ustruct \u2013 pack and unpack primitive data types usys \u2013 system specific functions utime \u2013 time related functions uzlib \u2013 zlib decompression _thread \u2013 multithreading support","title":"MicroPython Builtin Functions"},{"location":"getting-started/01b-libraries/#micropython-specific-libraries","text":"1 2 3 4 5 6 7 8 btree \u2013 simple BTree database framebuf \u2014 frame buffer manipulation machine \u2014 functions related to the hardware micropython \u2013 access and control MicroPython internals network \u2014 network configuration ubluetooth \u2014 low-level Bluetooth ucryptolib \u2013 cryptographic ciphers uctypes \u2013 access binary data in a structured way","title":"MicroPython Specific Libraries"},{"location":"getting-started/01b-libraries/#adding-a-module","text":"When you are using python and you attempt to use a module that python can't find you will get an error. You must then use the python pip installer tool to add the new library.","title":"Adding a module"},{"location":"getting-started/01b-libraries/#getting-micropython-libraries-from-pypi","text":"Filter Only MicroPython Libraries","title":"Getting MicroPython Libraries from PyPi"},{"location":"getting-started/01b-libraries/#full-list-of-modules","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 ESP-test audioop filecmp random __future__ base64 fileinput re _abc bcrypt fnmatch readline _ast bdb formatter reedsolo _asyncio binascii fractions reprlib _bisect binhex ftplib resource _blake2 bisect functools rlcompleter _bootlocale bitstring gc runpy _bz2 blink-builtin-led genericpath sched _cffi_backend brain_argparse getopt secrets _codecs brain_attrs getpass select _codecs_cn brain_builtin_inference gettext selectors _codecs_hk brain_collections glob send2trash _codecs_iso2022 brain_crypt grp serial _codecs_jp brain_curses gzip setuptools _codecs_kr brain_dataclasses hashlib sh1106 _codecs_tw brain_dateutil heapq sh1106-test _collections brain_fstrings hmac shelve _collections_abc brain_functools html shlex _compat_pickle brain_gi http shutil _compression brain_hashlib i2c-display signal _contextvars brain_http i2c-scanner site _crypt brain_io i2c_lcd six _csv brain_mechanize i2clcd smtpd _ctypes brain_multiprocessing imaplib smtplib _ctypes_test brain_namedtuple_enum imghdr sndhdr _curses brain_nose imp socket _curses_panel brain_numpy_core_fromnumeric importlib socketserver _datetime brain_numpy_core_function_base inspect spi-debug _dbm brain_numpy_core_multiarray io sqlite3 _decimal brain_numpy_core_numeric ipaddress sre_compile _dummy_thread brain_numpy_core_numerictypes isort sre_constants _elementtree brain_numpy_core_umath itertools sre_parse _functools brain_numpy_ndarray jedi ssl _hashlib brain_numpy_random_mtrand json stat _heapq brain_numpy_utils keyword statistics _imp brain_pkg_resources lazy_object_proxy string _io brain_pytest led-strip stringprep _json brain_qt lib2to3 struct _locale brain_random linecache subprocess _lsprof brain_re list-modules sunau _lzma brain_six locale symbol _markupbase brain_ssl logging symtable _md5 brain_subprocess lzma sys _multibytecodec brain_threading macpath sysconfig _multiprocessing brain_typing mailbox syslog _opcode brain_uuid mailcap tabnanny _operator builtins marshal tarfile _osx_support bz2 math telnetlib _pickle cProfile mccabe tempfile _posixsubprocess calendar mimetypes termios _py_abc certifi mmap test _pydecimal cffi modulefinder textwrap _pyio cgi multiprocessing this _queue cgitb mypy thonny _random chunk mypy_extensions threading _scproxy clonevirtualenv mypyc time _sha1 cmath nacl timeit _sha256 cmd netrc tkinter _sha3 code nis token _sha512 codecs nntplib tokenize _signal codeop ntpath toml _sitebuiltins collections nturl2path trace _socket colorsys numbers traceback _sqlite3 compileall opcode tracemalloc _sre concurrent operator tty _ssl configparser optparse turtle _stat contextlib os turtledemo _string contextvars paramiko typed_ast _strptime copy parser types _struct copyreg parso typing _symtable crypt pathlib typing_extensions _sysconfigdata_m_darwin_darwin cryptography pdb unicodedata _testbuffer csv pickle unittest _testcapi ctypes pickletools urllib _testimportmultiple curses pip uu _testmultiphase dataclasses pipenv uuid _thread datetime pipes venv _threading_local dbm pkg_resources virtualenv _tkinter decimal pkgutil virtualenv_support _tracemalloc difflib platform warnings _uuid dir-example plistlib wave _warnings dis poplib weakref _weakref distutils posix webbrowser _weakrefset doctest posixpath websockets _xxtestfuzz docutils pprint wheel abc dummy_threading profile wrapt aifc easy_install pstats wsgiref antigravity ecdsa pty xdrlib argparse email ptyprocess xml array encodings pwd xmlrpc array-test ensurepip py_compile xxlimited ast enum pyclbr xxsubtype astroid errno pycparser zipapp asttokens espefuse pydoc zipfile asynchat espressif pydoc_data zipimport asyncio espsecure pyexpat zlib asyncore esptool pylint at faulthandler queue atexit fcntl quopri","title":"Full List of modules"},{"location":"getting-started/02-boards/","text":"Micropython Boards Technically, any computer that has at least 16K of RAM can run MicroPython as long as someone has ported the MicroPython runtime to use that instruction set. Raspberry Pi Pico Most of these lessons use a low-cost ($4 retail list price) Raspberry Pi Pico (../glossary.md#pico). The microcontroller was designed by the Raspberry Pi Foundation specifically to provide a low-cost way for student to learn how to program MicroPython. The Raspberry Pi Foundation has also worked with the Thonny developers to create a simple clean kid-friendly interface that is ideal for beginning students. ESP32 The ESP32 is similar to the Raspberry Pi Pico but ESP32 also has both WiFi and bluetooth. Cables You will need a USB cable to program your microcontroller. These cables are frequently sold at high margin rates at retail stores. If you plan ahead, you can usually find these cables on eBay for about 50% less. Classroom purchases make this a good option. Getting Machine Statistics 1 2 import machine help(machine)","title":"Boards"},{"location":"getting-started/02-boards/#micropython-boards","text":"Technically, any computer that has at least 16K of RAM can run MicroPython as long as someone has ported the MicroPython runtime to use that instruction set.","title":"Micropython Boards"},{"location":"getting-started/02-boards/#raspberry-pi-pico","text":"Most of these lessons use a low-cost ($4 retail list price) Raspberry Pi Pico (../glossary.md#pico). The microcontroller was designed by the Raspberry Pi Foundation specifically to provide a low-cost way for student to learn how to program MicroPython. The Raspberry Pi Foundation has also worked with the Thonny developers to create a simple clean kid-friendly interface that is ideal for beginning students.","title":"Raspberry Pi Pico"},{"location":"getting-started/02-boards/#esp32","text":"The ESP32 is similar to the Raspberry Pi Pico but ESP32 also has both WiFi and bluetooth.","title":"ESP32"},{"location":"getting-started/02-boards/#cables","text":"You will need a USB cable to program your microcontroller. These cables are frequently sold at high margin rates at retail stores. If you plan ahead, you can usually find these cables on eBay for about 50% less. Classroom purchases make this a good option.","title":"Cables"},{"location":"getting-started/02-boards/#getting-machine-statistics","text":"1 2 import machine help(machine)","title":"Getting Machine Statistics"},{"location":"getting-started/02-breadboards/","text":"Breadboards We use standard solderless mini breadboards in our labs. The breadboards have holes that are spaced 1/10th of an inch apart which is a standard for most electronics in the US. Our breadboards are usually 1/2 size with 400-ties. They have a central trough and power rails on the left and right edges. Breadboard Regions and Connections Learning how a breadboard works is critical for building your projects. In the figure above you will see that there are two types of regions of the breadboard The side regions are called the power distribution rails. They are similar to power lines that reach across our projects. The central region is call the row connector region. In this area the horizontal rows are all connected inside the breadboard. Within any row, columns a, b, c, d and e are all electrically connected. Within any row, columns f, h, i, j, and k are also electrically connected. However, there is a gap between columns e and f called the center gap or component slot that parts are usually placed over. Components like buttons and chips usually have their pins straddle the component slot. Pico Placement on Breadboard For most of our labs we place the Pico so that pin 1 of the Pico is in row 1 of the breadboard as in the image below. This means that the GND connections to the Pico are always in rows 3, 8, 13 and 18 on both sides of the breadboard. One of the ground pins is usually hooked up to the vertical blue power rails on the sides of the breadboard. Pico Placement Annotations GND are the ground connections. There are VBUS is the 5V power from the USB and is high only when the USB is connected. This is nominally 5V (or 0V if the USB is not connected or not powered). VSYS (also know and Voltage System Input) is the main system input voltage. When the Pico is disconnected from the USB you apply power to the Voltage System Input. The input can vary in the allowed range 1.8V to 5.5V, and is used by the on-board SMPS to generate the 3.3V for the RP2040 and its GPIO connections. When the input voltage is less than 3.3 volts the Pico uses an internal DC voltage Boost converter to get the correct voltage to the processor. 3V3_EN connects to the on-board SMPS enable pin, and is pulled high (to VSYS) via a 100K resistor. To disable the 3.3V (which also de-powers the RP2040), short this pin low. In effect by making the 3V3_EN LOW you are turning off the Pico. Breadboard Connections","title":"Solderless Breadboards"},{"location":"getting-started/02-breadboards/#breadboards","text":"We use standard solderless mini breadboards in our labs. The breadboards have holes that are spaced 1/10th of an inch apart which is a standard for most electronics in the US. Our breadboards are usually 1/2 size with 400-ties. They have a central trough and power rails on the left and right edges.","title":"Breadboards"},{"location":"getting-started/02-breadboards/#breadboard-regions-and-connections","text":"Learning how a breadboard works is critical for building your projects. In the figure above you will see that there are two types of regions of the breadboard The side regions are called the power distribution rails. They are similar to power lines that reach across our projects. The central region is call the row connector region. In this area the horizontal rows are all connected inside the breadboard. Within any row, columns a, b, c, d and e are all electrically connected. Within any row, columns f, h, i, j, and k are also electrically connected. However, there is a gap between columns e and f called the center gap or component slot that parts are usually placed over. Components like buttons and chips usually have their pins straddle the component slot.","title":"Breadboard Regions and Connections"},{"location":"getting-started/02-breadboards/#pico-placement-on-breadboard","text":"For most of our labs we place the Pico so that pin 1 of the Pico is in row 1 of the breadboard as in the image below. This means that the GND connections to the Pico are always in rows 3, 8, 13 and 18 on both sides of the breadboard. One of the ground pins is usually hooked up to the vertical blue power rails on the sides of the breadboard.","title":"Pico Placement on Breadboard"},{"location":"getting-started/02-breadboards/#pico-placement-annotations","text":"GND are the ground connections. There are VBUS is the 5V power from the USB and is high only when the USB is connected. This is nominally 5V (or 0V if the USB is not connected or not powered). VSYS (also know and Voltage System Input) is the main system input voltage. When the Pico is disconnected from the USB you apply power to the Voltage System Input. The input can vary in the allowed range 1.8V to 5.5V, and is used by the on-board SMPS to generate the 3.3V for the RP2040 and its GPIO connections. When the input voltage is less than 3.3 volts the Pico uses an internal DC voltage Boost converter to get the correct voltage to the processor. 3V3_EN connects to the on-board SMPS enable pin, and is pulled high (to VSYS) via a 100K resistor. To disable the 3.3V (which also de-powers the RP2040), short this pin low. In effect by making the 3V3_EN LOW you are turning off the Pico.","title":"Pico Placement Annotations"},{"location":"getting-started/02-breadboards/#breadboard-connections","text":"","title":"Breadboard Connections"},{"location":"getting-started/02-esp32/","text":"ESP32 TTGO The ESP32 is a low-cost (under $10) microcontroller with both built-in WiFi and Bluetooth. This lab demonstrates using a version of the ESP32 that includes an integrated display. Step 1: Install the USB to UART Bridge VCP Drivers Follow the directions here: https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers Test this by running the ``ls -l /dev/cu*``` and verify you see: /dev/cu.SLAB_USBtoUART If you don't see this try to reboot. Mac: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/establish-serial-connection.html https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/raw/master/MicroPython_BUILD/firmware/MicroPython_LoBo_esp32_all.zip Step 2: Create a Python Conda Environment for ESP32 This is so we don't mess up other Python projects on your system. 1 2 conda create -n esp32 python = 3 conda activate esp32 Step #3: Install the esptool 1 2 3 4 5 6 7 $ pip3 install esptool Collecting esptool Downloading esptool-3.0.tar.gz ( 149 kB ) | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 149 kB 2 .9 MB/s ... Installing collected packages: pycparser, six, cffi, reedsolo, pyserial, ecdsa, cryptography, bitstring, esptool Successfully installed bitstring-3.1.7 cffi-1.14.5 cryptography-3.4.6 ecdsa-0.16.1 esptool-3.0 pycparser-2.20 pyserial-3.5 reedsolo-1.5.4 six-1.15.0 Step 4: Erase the Old Firmware 1 esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash Step 5: Download the New Firmware Get the ESP32_All prebuilt binary: https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/wiki/firmwares Step 6: Reflash the new ESP32 Firmware 1 2 cd esp32_all/ ../flash.sh -p /dev/cu.SLAB_USBtoUART this will run... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash esptool.py v3.0 Serial port /dev/cu.SLAB_USBtoUART Connecting........_ Detecting chip type... ESP32 Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 24 :62:ab:ca:62:84 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 2 .5s Hard resetting via RTS pin... Configure Thonny You must configure Thonny to use the ESP32. Set the Serial Port First, you must tell Thonny how to find the right port. Set the Interpreter Next, yo must tell Thonny to use the ESP32 interpreter. Run a test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import machine , display , time , math , network , utime tft = display . TFT () tft . init ( tft . ST7789 , bgr = False , rot = tft . LANDSCAPE , miso = 17 , backl_pin = 4 , backl_on = 1 , mosi = 19 , clk = 18 , cs = 5 , dc = 16 ) tft . setwin ( 40 , 52 , 320 , 240 ) for i in range ( 0 , 241 ): color = 0xFFFFFF - tft . hsb2rgb ( i / 241 * 360 , 1 , 1 ) tft . line ( i , 0 , i , 135 , color ) tft . set_fg ( 0x000000 ) tft . ellipse ( 120 , 67 , 120 , 67 ) tft . line ( 0 , 0 , 240 , 135 ) text = \"CoderDojo Rocks!\" tft . text ( 120 - int ( tft . textWidth ( text ) / 2 ), 67 - int ( tft . fontSize ()[ 1 ] / 2 ), text , 0xFFFFFF ) You should see the following on the ESP32 display: References https://www.instructables.com/TTGO-color-Display-With-Micropython-TTGO-T-display/","title":"ESP32"},{"location":"getting-started/02-esp32/#esp32-ttgo","text":"The ESP32 is a low-cost (under $10) microcontroller with both built-in WiFi and Bluetooth. This lab demonstrates using a version of the ESP32 that includes an integrated display.","title":"ESP32 TTGO"},{"location":"getting-started/02-esp32/#step-1-install-the-usb-to-uart-bridge-vcp-drivers","text":"Follow the directions here: https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers Test this by running the ``ls -l /dev/cu*``` and verify you see: /dev/cu.SLAB_USBtoUART If you don't see this try to reboot. Mac: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/establish-serial-connection.html https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/raw/master/MicroPython_BUILD/firmware/MicroPython_LoBo_esp32_all.zip","title":"Step 1: Install the USB to UART Bridge VCP Drivers"},{"location":"getting-started/02-esp32/#step-2-create-a-python-conda-environment-for-esp32","text":"This is so we don't mess up other Python projects on your system. 1 2 conda create -n esp32 python = 3 conda activate esp32","title":"Step 2: Create a Python Conda Environment for ESP32"},{"location":"getting-started/02-esp32/#step-3-install-the-esptool","text":"1 2 3 4 5 6 7 $ pip3 install esptool Collecting esptool Downloading esptool-3.0.tar.gz ( 149 kB ) | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 149 kB 2 .9 MB/s ... Installing collected packages: pycparser, six, cffi, reedsolo, pyserial, ecdsa, cryptography, bitstring, esptool Successfully installed bitstring-3.1.7 cffi-1.14.5 cryptography-3.4.6 ecdsa-0.16.1 esptool-3.0 pycparser-2.20 pyserial-3.5 reedsolo-1.5.4 six-1.15.0","title":"Step #3: Install the esptool"},{"location":"getting-started/02-esp32/#step-4-erase-the-old-firmware","text":"1 esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash","title":"Step 4: Erase the Old Firmware"},{"location":"getting-started/02-esp32/#step-5-download-the-new-firmware","text":"Get the ESP32_All prebuilt binary: https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/wiki/firmwares","title":"Step 5: Download the New Firmware"},{"location":"getting-started/02-esp32/#step-6-reflash-the-new-esp32-firmware","text":"1 2 cd esp32_all/ ../flash.sh -p /dev/cu.SLAB_USBtoUART this will run... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash esptool.py v3.0 Serial port /dev/cu.SLAB_USBtoUART Connecting........_ Detecting chip type... ESP32 Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 24 :62:ab:ca:62:84 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 2 .5s Hard resetting via RTS pin...","title":"Step 6: Reflash the new ESP32 Firmware"},{"location":"getting-started/02-esp32/#configure-thonny","text":"You must configure Thonny to use the ESP32.","title":"Configure Thonny"},{"location":"getting-started/02-esp32/#set-the-serial-port","text":"First, you must tell Thonny how to find the right port.","title":"Set the Serial Port"},{"location":"getting-started/02-esp32/#set-the-interpreter","text":"Next, yo must tell Thonny to use the ESP32 interpreter.","title":"Set the Interpreter"},{"location":"getting-started/02-esp32/#run-a-test","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import machine , display , time , math , network , utime tft = display . TFT () tft . init ( tft . ST7789 , bgr = False , rot = tft . LANDSCAPE , miso = 17 , backl_pin = 4 , backl_on = 1 , mosi = 19 , clk = 18 , cs = 5 , dc = 16 ) tft . setwin ( 40 , 52 , 320 , 240 ) for i in range ( 0 , 241 ): color = 0xFFFFFF - tft . hsb2rgb ( i / 241 * 360 , 1 , 1 ) tft . line ( i , 0 , i , 135 , color ) tft . set_fg ( 0x000000 ) tft . ellipse ( 120 , 67 , 120 , 67 ) tft . line ( 0 , 0 , 240 , 135 ) text = \"CoderDojo Rocks!\" tft . text ( 120 - int ( tft . textWidth ( text ) / 2 ), 67 - int ( tft . fontSize ()[ 1 ] / 2 ), text , 0xFFFFFF ) You should see the following on the ESP32 display:","title":"Run a test"},{"location":"getting-started/02-esp32/#references","text":"https://www.instructables.com/TTGO-color-Display-With-Micropython-TTGO-T-display/","title":"References"},{"location":"getting-started/02-pi-pico/","text":"Getting Started with the Raspberry Pi RP2040 Microcontroller The Raspberry Pi RP2040 is a custom silicon microcontroller built by the Raspberry Pi Foundation . The RP2040 is used in the Raspberry Pi Pico with a retail list prices of $4. With 264K SRAM, it has around 100 times the RAM of an Arduino Uno (2K). It is ideal for projects that need more RAM such as projects that require drawing to an OLED display. Specs RP2040 microcontroller chip designed by Raspberry Pi Foundation Dual-core Arm Cortex M0+ processor, flexible clock running up to 133 MHz 264KB of SRAM, and 2MB of on-board Flash memory Support for up to 16MB of off-chip Flash memory via dedicated QSPI bus DMA controller Interpolator and integer divider peripherals Castellated module allows soldering direct to carrier boards USB 1.1 and PHY with device and host support Low-power sleep and dormant modes Drag-and-drop programming using mass storage over USB 26 \u00d7 multi-function GPIO pins 3 12 bit analogue inputs 16 controllable PWM channels 2 SPI, 2 I2C, and 2 UART channels Accurate clock and timer on-chip 8 Raspberry Pi Programmable I/O (PIO) state machines Temperature sensor Accelerated floating-point libraries on-chip 8 \u00d7 Programmable I/O (PIO) state machines for custom peripheral support Created using the TSMC 40LP (40 nano meter low power) manufacturing process USB mass-storage boot mode with UF2 support, for drag-and-drop programming USB Cable The Raspberry Pi Pico uses a USB-micro connector. You can purchase USB Micro-B to USB-A or USB-C (Mac) cables on e-bay for under $2 or for $5 at Microcenter. - image from ebay Pico Pinout The pinout diagram for the Raspberry Pi Pico is shown below. It features: * 26 \u00d7 multi-function GPIO pins * 2 \u00d7 SPI, 2 \u00d7 I2C, 2 \u00d7 UART, 3 \u00d7 12-bit ADC, 16 \u00d7 controllable PWM Raspberry Pi Pico\u2019s 40 pins with pin 1 in the upper right corner with the USB connector at the top. The pin numbers are incremented as you go counterclockwise around the board. You go down the left side and then continue up on the right side until you get to pin 40 in the upper right corner. When you program the Pico, you use the machine.Pin() but you always use the GP* number, never the pin number on the board pin numbers. The diagram above shows the top view where pins 1, 2 and 40 are printed next to the pins. Pico Pinout Datasheet PDF Next to each pin is the primary label of what the pin does. Pins 3, 8, 13, 18, 23, 28, 33 and 38 with the black background are all GND pins. Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Label Name Description V3 3.3 volts power A source of 3.3 V power, the same voltage your Pico runs at internally, generated from the VSYS input. This power supply can be switched on and off using the 3V3_EN pin above it, which also switches your Pico off. VSYS ~2-5 volts power A pin directly connected to your Pico\u2019s internal power supply, which cannot be switched off without also switching Pico off. VBUS 5 volts power A source of 5 V power taken from your Pico\u2019s micro USB port, and used to power hardware which needs more than 3.3 V. GND 0 volts ground A ground connection, used to complete a circuit connected to a power source. Several of these pins are dotted around your Pico to make wiring easier. GPxx General-purpose input/output pin number \u2018xx The GPIO pins available for your program, labelled \u2018GP0\u2019 through to \u2018GP28\u2019. GPxx_ADCx General-purpose input/output pin number \u2018xx\u2019, with analogue input number \u2018x\u2019 A GPIO pin which ends in \u2018ADC\u2019 and a number can be used as an analogue input as well as a digital input or output \u2013 but not both at the same time. ADC_VREF Analogue-to-digital converter (ADC) voltage reference A special input pin which sets a reference voltage for any analogue inputs. AGND Analogue-to-digital converter (ADC) 0 volts ground A special ground connection for use with the ADC_VREF pin. RUN Enables or disables your Pico The RUN header is used to start and stop your Pico from another microcontroller. Steps To Get Micropython Running on the Mac Download the MicroPython UF2 file. Push and hold the BOOTSEL button and plug your Pico into the USB port of your Raspberry Pi or other computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2. Drag and drop the MicroPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. You are now running MicroPython. Using Thonny Thonny is a free lightweight Python development tool. Download the Thonny Application Download the Thonny Pico driver Configure Thonny to use the Pico interpreter Test using the help() function Test by running a blink application 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done! Getting The Bootloader Running from the Thonny Python Shell Although you can hold down the BOOTSEL button as you are plugging in the Pico, there is a much easier way. Just type the following into the Thonny shell: 1 >>>machine.bootloader () This will make the Pico go into the Bootloader Mode and mount the file system. You can then copy the bootloader file using the drag-and-drop from your file system or use a UNIX copy command. Once the copy is finished the Pico will automaticaly restart using the new uf2 file. Using the Onboard LED 1 2 3 4 from machine import Pin import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) led_onboard . value ( 1 ) 1 2 3 4 5 6 7 8 9 from machine import Pin import utime # right uppermost pin with USB on the left led = Pin ( 16 , Pin . OUT ) led . low () while True : led . toggle () utime . sleep ( 1 ) Press the Play Button References Getting Started Guide Raspberry Pi Getting Started MicroPython RP2040 Reference MicroPython RP2040 Quick Reference - this web page has details on how MicroPython was ported to the RP2040 Microcontroller. Book PDF Raspberry Pi Book PDF Download from HackSpace Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)","title":"Raspberry Pi Pico"},{"location":"getting-started/02-pi-pico/#getting-started-with-the-raspberry-pi-rp2040-microcontroller","text":"The Raspberry Pi RP2040 is a custom silicon microcontroller built by the Raspberry Pi Foundation . The RP2040 is used in the Raspberry Pi Pico with a retail list prices of $4. With 264K SRAM, it has around 100 times the RAM of an Arduino Uno (2K). It is ideal for projects that need more RAM such as projects that require drawing to an OLED display.","title":"Getting Started with the Raspberry Pi RP2040 Microcontroller"},{"location":"getting-started/02-pi-pico/#specs","text":"RP2040 microcontroller chip designed by Raspberry Pi Foundation Dual-core Arm Cortex M0+ processor, flexible clock running up to 133 MHz 264KB of SRAM, and 2MB of on-board Flash memory Support for up to 16MB of off-chip Flash memory via dedicated QSPI bus DMA controller Interpolator and integer divider peripherals Castellated module allows soldering direct to carrier boards USB 1.1 and PHY with device and host support Low-power sleep and dormant modes Drag-and-drop programming using mass storage over USB 26 \u00d7 multi-function GPIO pins 3 12 bit analogue inputs 16 controllable PWM channels 2 SPI, 2 I2C, and 2 UART channels Accurate clock and timer on-chip 8 Raspberry Pi Programmable I/O (PIO) state machines Temperature sensor Accelerated floating-point libraries on-chip 8 \u00d7 Programmable I/O (PIO) state machines for custom peripheral support Created using the TSMC 40LP (40 nano meter low power) manufacturing process USB mass-storage boot mode with UF2 support, for drag-and-drop programming","title":"Specs"},{"location":"getting-started/02-pi-pico/#usb-cable","text":"The Raspberry Pi Pico uses a USB-micro connector. You can purchase USB Micro-B to USB-A or USB-C (Mac) cables on e-bay for under $2 or for $5 at Microcenter. - image from ebay","title":"USB Cable"},{"location":"getting-started/02-pi-pico/#pico-pinout","text":"The pinout diagram for the Raspberry Pi Pico is shown below. It features: * 26 \u00d7 multi-function GPIO pins * 2 \u00d7 SPI, 2 \u00d7 I2C, 2 \u00d7 UART, 3 \u00d7 12-bit ADC, 16 \u00d7 controllable PWM Raspberry Pi Pico\u2019s 40 pins with pin 1 in the upper right corner with the USB connector at the top. The pin numbers are incremented as you go counterclockwise around the board. You go down the left side and then continue up on the right side until you get to pin 40 in the upper right corner. When you program the Pico, you use the machine.Pin() but you always use the GP* number, never the pin number on the board pin numbers. The diagram above shows the top view where pins 1, 2 and 40 are printed next to the pins. Pico Pinout Datasheet PDF Next to each pin is the primary label of what the pin does. Pins 3, 8, 13, 18, 23, 28, 33 and 38 with the black background are all GND pins. Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Label Name Description V3 3.3 volts power A source of 3.3 V power, the same voltage your Pico runs at internally, generated from the VSYS input. This power supply can be switched on and off using the 3V3_EN pin above it, which also switches your Pico off. VSYS ~2-5 volts power A pin directly connected to your Pico\u2019s internal power supply, which cannot be switched off without also switching Pico off. VBUS 5 volts power A source of 5 V power taken from your Pico\u2019s micro USB port, and used to power hardware which needs more than 3.3 V. GND 0 volts ground A ground connection, used to complete a circuit connected to a power source. Several of these pins are dotted around your Pico to make wiring easier. GPxx General-purpose input/output pin number \u2018xx The GPIO pins available for your program, labelled \u2018GP0\u2019 through to \u2018GP28\u2019. GPxx_ADCx General-purpose input/output pin number \u2018xx\u2019, with analogue input number \u2018x\u2019 A GPIO pin which ends in \u2018ADC\u2019 and a number can be used as an analogue input as well as a digital input or output \u2013 but not both at the same time. ADC_VREF Analogue-to-digital converter (ADC) voltage reference A special input pin which sets a reference voltage for any analogue inputs. AGND Analogue-to-digital converter (ADC) 0 volts ground A special ground connection for use with the ADC_VREF pin. RUN Enables or disables your Pico The RUN header is used to start and stop your Pico from another microcontroller.","title":"Pico Pinout"},{"location":"getting-started/02-pi-pico/#steps-to-get-micropython-running-on-the-mac","text":"Download the MicroPython UF2 file. Push and hold the BOOTSEL button and plug your Pico into the USB port of your Raspberry Pi or other computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2. Drag and drop the MicroPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. You are now running MicroPython.","title":"Steps To Get Micropython Running on the Mac"},{"location":"getting-started/02-pi-pico/#using-thonny","text":"Thonny is a free lightweight Python development tool. Download the Thonny Application Download the Thonny Pico driver Configure Thonny to use the Pico interpreter Test using the help() function Test by running a blink application 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done!","title":"Using Thonny"},{"location":"getting-started/02-pi-pico/#getting-the-bootloader-running-from-the-thonny-python-shell","text":"Although you can hold down the BOOTSEL button as you are plugging in the Pico, there is a much easier way. Just type the following into the Thonny shell: 1 >>>machine.bootloader () This will make the Pico go into the Bootloader Mode and mount the file system. You can then copy the bootloader file using the drag-and-drop from your file system or use a UNIX copy command. Once the copy is finished the Pico will automaticaly restart using the new uf2 file.","title":"Getting The Bootloader Running from the Thonny Python Shell"},{"location":"getting-started/02-pi-pico/#using-the-onboard-led","text":"1 2 3 4 from machine import Pin import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) led_onboard . value ( 1 ) 1 2 3 4 5 6 7 8 9 from machine import Pin import utime # right uppermost pin with USB on the left led = Pin ( 16 , Pin . OUT ) led . low () while True : led . toggle () utime . sleep ( 1 ) Press the Play Button","title":"Using the Onboard LED"},{"location":"getting-started/02-pi-pico/#references","text":"","title":"References"},{"location":"getting-started/02-pi-pico/#getting-started-guide","text":"Raspberry Pi Getting Started","title":"Getting Started Guide"},{"location":"getting-started/02-pi-pico/#micropython-rp2040-reference","text":"MicroPython RP2040 Quick Reference - this web page has details on how MicroPython was ported to the RP2040 Microcontroller.","title":"MicroPython RP2040 Reference"},{"location":"getting-started/02-pi-pico/#book-pdf","text":"Raspberry Pi Book PDF Download from HackSpace Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)","title":"Book PDF"},{"location":"getting-started/02c-thonny/","text":"Thonny Python IDE A lightweight Python integrated development environment (IDE) that is ideal for beginners writing simple Python programs for first time users. It has been modified to work well with the Raspberry Pi Pico. It supports different ways of stepping through the code, step-by-step expression evaluation, detailed visualization of the call stack and a mode for explaining the concepts of references and heap. We strongly suggest that classes begin with Thonny for the first several weeks. As students want to do more complex functions such as build automatic deployment scripts other IDEs are more appropriate. Thonny 3.3.3 (2021-01-21) was the first version to support the Raspberry Pi Pico. There have also been several enhancements since that release. For a release history see the Thonny Release History . We suggest checking this link monthly for updates. Installing Thonny The best way to install Thonny is to go to the Thonny web site an look for the \"Download\" are for your opeating system. That link is here: https://thonny.org/ Make sure you upgrade to the latest version of Thonny if you already have a Thonny installed on your computer. You can find more tips on getting started with Thonny on the Raspberry Pi website: https://projects.raspberrypi.org/en/projects/getting-started-with-the-pico/2 Thonny runs on Mac, Windows and Linux. Upgrading Thonny Although you can always upgrade Thonny by removing it and reinstalling a new version, on Mac and Linux systems there is an easier method. Run the following shell command: 1 sudo yum upgrade thonny or 1 sudo apt-get upgrade thonny Running help() You can enter the help() function in the main script area and then press the Play button. This will tell you 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 MicroPython v1.14 on 2021-02-02; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT Welcome to MicroPython! For online help please visit https://micropython.org/help/. For access to the hardware use the 'machine' module. RP2 specific commands are in the 'rp2' module. Quick overview of some objects: machine.Pin(pin) -- get a pin, eg machine.Pin(0) machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p methods: init(..), value([v]), high(), low(), irq(handler) machine.ADC(pin) -- make an analog object from a pin methods: read_u16() machine.PWM(pin) -- make a PWM object from a pin methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d]) machine.I2C(id) -- create an I2C object (id=0,1) methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True) readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg) machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1) methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf) machine.Timer(freq, callback) -- create a software timer object eg: machine.Timer(freq=1, callback=lambda t:print(t)) Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Useful control commands: CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') >>> Save Options You can save a python file in Thonny to either the Pico or to your local computer's file system. first stop execution of any program you are running. Downloading the Firmware After you start up Thonny there will be a button in the lower right corner. After you click on it you will see the following: 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done! Version After you press play the following will appear in the console. 1 2 3 MicroPython v1.13-290-g556ae7914 on 2021 -01-21 ; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT Plotting Values on Thonny If you are reading sensor values and want to see a nice plot of the values, you can use Thonny's Plot function to view the values. Simply add numeric print values to your main loop and they will be displayed in the plot window. This is very useful for any analog to digital conversions and can be used as a simple tool to view anomalies in incoming data. For example if you accidently hook up at potentiometer's positive rail to 3.3OUT instead of the 3.3REF you will see noise in the incomming data cause by spikes on the power rails. Background on Thonny MicroPython was originally developed by Damien George and first released in 2014. However, MicroPython did not have a development environment that was easy for students to use. Thonny was developed to provide an easy to use tool just for MicroPython development. Thonney was created at the University of Tartu Institute of Computer Science in Estonia for this purpose. They continue to support Thonny. Several feature for Thonny were sponsored by the Raspberry Pi Foundation and we continue to see a close relationship between the Raspberry Pi Foundation and the Thonny development team. Thonny web site","title":"Thonny IDE"},{"location":"getting-started/02c-thonny/#thonny-python-ide","text":"A lightweight Python integrated development environment (IDE) that is ideal for beginners writing simple Python programs for first time users. It has been modified to work well with the Raspberry Pi Pico. It supports different ways of stepping through the code, step-by-step expression evaluation, detailed visualization of the call stack and a mode for explaining the concepts of references and heap. We strongly suggest that classes begin with Thonny for the first several weeks. As students want to do more complex functions such as build automatic deployment scripts other IDEs are more appropriate. Thonny 3.3.3 (2021-01-21) was the first version to support the Raspberry Pi Pico. There have also been several enhancements since that release. For a release history see the Thonny Release History . We suggest checking this link monthly for updates.","title":"Thonny Python IDE"},{"location":"getting-started/02c-thonny/#installing-thonny","text":"The best way to install Thonny is to go to the Thonny web site an look for the \"Download\" are for your opeating system. That link is here: https://thonny.org/ Make sure you upgrade to the latest version of Thonny if you already have a Thonny installed on your computer. You can find more tips on getting started with Thonny on the Raspberry Pi website: https://projects.raspberrypi.org/en/projects/getting-started-with-the-pico/2 Thonny runs on Mac, Windows and Linux.","title":"Installing Thonny"},{"location":"getting-started/02c-thonny/#upgrading-thonny","text":"Although you can always upgrade Thonny by removing it and reinstalling a new version, on Mac and Linux systems there is an easier method. Run the following shell command: 1 sudo yum upgrade thonny or 1 sudo apt-get upgrade thonny","title":"Upgrading Thonny"},{"location":"getting-started/02c-thonny/#running-help","text":"You can enter the help() function in the main script area and then press the Play button. This will tell you 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 MicroPython v1.14 on 2021-02-02; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT Welcome to MicroPython! For online help please visit https://micropython.org/help/. For access to the hardware use the 'machine' module. RP2 specific commands are in the 'rp2' module. Quick overview of some objects: machine.Pin(pin) -- get a pin, eg machine.Pin(0) machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p methods: init(..), value([v]), high(), low(), irq(handler) machine.ADC(pin) -- make an analog object from a pin methods: read_u16() machine.PWM(pin) -- make a PWM object from a pin methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d]) machine.I2C(id) -- create an I2C object (id=0,1) methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True) readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg) machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1) methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf) machine.Timer(freq, callback) -- create a software timer object eg: machine.Timer(freq=1, callback=lambda t:print(t)) Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Useful control commands: CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') >>>","title":"Running help()"},{"location":"getting-started/02c-thonny/#save-options","text":"You can save a python file in Thonny to either the Pico or to your local computer's file system. first stop execution of any program you are running.","title":"Save Options"},{"location":"getting-started/02c-thonny/#downloading-the-firmware","text":"After you start up Thonny there will be a button in the lower right corner. After you click on it you will see the following: 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done!","title":"Downloading the Firmware"},{"location":"getting-started/02c-thonny/#version","text":"After you press play the following will appear in the console. 1 2 3 MicroPython v1.13-290-g556ae7914 on 2021 -01-21 ; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT","title":"Version"},{"location":"getting-started/02c-thonny/#plotting-values-on-thonny","text":"If you are reading sensor values and want to see a nice plot of the values, you can use Thonny's Plot function to view the values. Simply add numeric print values to your main loop and they will be displayed in the plot window. This is very useful for any analog to digital conversions and can be used as a simple tool to view anomalies in incoming data. For example if you accidently hook up at potentiometer's positive rail to 3.3OUT instead of the 3.3REF you will see noise in the incomming data cause by spikes on the power rails.","title":"Plotting Values on Thonny"},{"location":"getting-started/02c-thonny/#background-on-thonny","text":"MicroPython was originally developed by Damien George and first released in 2014. However, MicroPython did not have a development environment that was easy for students to use. Thonny was developed to provide an easy to use tool just for MicroPython development. Thonney was created at the University of Tartu Institute of Computer Science in Estonia for this purpose. They continue to support Thonny. Several feature for Thonny were sponsored by the Raspberry Pi Foundation and we continue to see a close relationship between the Raspberry Pi Foundation and the Thonny development team. Thonny web site","title":"Background on Thonny"},{"location":"getting-started/02d-vscode/","text":"Using Visual Studio Code to Program MicroPython Although the Thonney IDE is a great way for kids to start programming in Python on the Raspberry Pi Pico, it has limited advanced features and no large library of extensions. For intermediate to advanced Python developers, the Visual Studio Code IDE is a good options when it is used with an appropriate extension such as the Pico Go extension by Chris Wood. Note that Visual Studio Code is sometimes just called VS Code. Code extensions provide code auto-completion and allows you to communicate with your Raspberry Pi Pico board using the built-in REPL console. You can a single file on your board, sync your entire project or directly type and execute commands. Because the files are stored on your local computer, it makes it easier to use version control software to allow you to work in teams with remote developers. Installing Visual Studio Code Visual Studio Code runs on Windows, Mac and Linux systems such as the operating systems that run on the Raspberry Pi 3 or 4. You typically need around 2GB of RAM to run VS-Code. See the VS Code Requirements . If you have a Raspberry Pi the installation instructions are here . Adding the Pico Go Extension After you have installed VS-Code you must download the Pico Go Extension: Pico Go Quick Start References Pico Go by Chris Wood Bao Phan Micropython Extension","title":"VS Code IDE"},{"location":"getting-started/02d-vscode/#using-visual-studio-code-to-program-micropython","text":"Although the Thonney IDE is a great way for kids to start programming in Python on the Raspberry Pi Pico, it has limited advanced features and no large library of extensions. For intermediate to advanced Python developers, the Visual Studio Code IDE is a good options when it is used with an appropriate extension such as the Pico Go extension by Chris Wood. Note that Visual Studio Code is sometimes just called VS Code. Code extensions provide code auto-completion and allows you to communicate with your Raspberry Pi Pico board using the built-in REPL console. You can a single file on your board, sync your entire project or directly type and execute commands. Because the files are stored on your local computer, it makes it easier to use version control software to allow you to work in teams with remote developers.","title":"Using Visual Studio Code to Program MicroPython"},{"location":"getting-started/02d-vscode/#installing-visual-studio-code","text":"Visual Studio Code runs on Windows, Mac and Linux systems such as the operating systems that run on the Raspberry Pi 3 or 4. You typically need around 2GB of RAM to run VS-Code. See the VS Code Requirements . If you have a Raspberry Pi the installation instructions are here .","title":"Installing Visual Studio Code"},{"location":"getting-started/02d-vscode/#adding-the-pico-go-extension","text":"After you have installed VS-Code you must download the Pico Go Extension: Pico Go Quick Start","title":"Adding the Pico Go Extension"},{"location":"getting-started/02d-vscode/#references","text":"Pico Go by Chris Wood Bao Phan Micropython Extension","title":"References"},{"location":"getting-started/03-suggested-parts/","text":"Sourcing Parts One of the key values of CoderDojo clubs around the world is to not charge any fees for attending these clubs. Parts need to be purchase by limited funds raised through donations. Club organizers need to be frugal about getting low-cost parts for the participants. Our experience is that is difficult to get the right parts at low cost using firms that promise quick delivery times of a few days. The lowest price parts often must be purchased weeks in advance from places like China and Taiwan. As a result, clubs that use funds carefully must plan weeks if not months in advance of classes and events. So we strongly suggest bringing an robot part procurement team together two months before you begin to offer robot courses where students can each have their own robots. Purchasing The Raspberry Pi Kits As of June 2021, the Raspberry Pi Pico did not come integrated into low-cost development kits that include robot kit parts. You frequently must to purchase the independent parts yourself. Here are some of the parts we recommend. The Raspberry Pi Pico In the US, our best source of these has been Microcenter stores. They sell them for $3.99 and they often have them on sale for $1.99. Microcenter Pico Part Listing Microcenter has around 25 Locations in the US. USB Cable For a Mac with USB-C connectors, you will need to get a USB micro to C cable: Ebay USB 3.1 USB C Type C to Micro USB Male Sync OTG Charge Data Transfers Adapters Sample 1 meter USB cable on eBay for $2.40. Headers We need male breakaway headers with standard 1/10th inch spacing. The Raspberry Pi Pico will need 20 pins on each side. If you get 40-pin versions they can easily be broken in half. EBay: Ebay 40-Pin Male Header 0.1\" 2.54mm Breadboard PCB Strip Connectors 5pc - these ship from China in a few weeks and you can get five of them for $1 (including shipping). Amazon: Amazon MCIGICM 10pcs Male Header Pin, 40 Pin Header Strip (2.54 mm) for Arduino Connector Solderless Breadboards We like the 1/2 size boards that have 400 connection points. We like to mount them with the USB connector at the top with the numbers running down the left side to align with the pin numbers. EBay: Solderless Breadboard 400 Point Tie Prototype Test Bread Board PCB For Arduino Amazon: Amazon 4 Pieces for $6 Hookup Wire Use 22 gauge wire. Get a large spool of black and red and smaller spools of other colors. Male-to-Male Breadboard Jumper Wires You can use 22 gauge wire to build your projects, however kids that don't have fine motor skills sometimes get frustrated with raw wires. You can purchase a Jumper Wire Kit with 65 jumpers on EBay for under $2 that has nice plastic ends that are easier to use. Ebay: 65pcs Jumper Wire cable kit for Solderless Breadboard New - 65 of various lengths for $1.50 Ebay: 65X 65PCS Jumper Wire Cable Kit For Solderless Breadboard Amazon: ZYAMY 195pcs Breadboard Jumper Wire 12cm 16cm 20cm 24cm Solderless Flexible Breadboard Connecting Line Cables Male to Male Breadboard Jumpers (65pcs/Set x 3) - three packs of 65 for about $8 Momentary Press Buttons A B3F Momentary Press Button with a blue cap. Note the schematic in the lower right corner that shows the internal connections of the button. We like the B3F-4055 12 x12x7.3mm Tactile Switch Momentary Press Buttons that have small dimples on the bottom that fit into the breadboard center trough. They can be purchased for under 10 cents per unit on eBay. You can by them with our without colored caps. The links below have example listings on eBay. eBay Tactile Push Button Switch Momentary Tact & Cap 12x12x7.3mm Assorted Kit - this kit includes 15 switchs with seven colors of caps for US $8.95. eBay: 10PCS New B3F Tactile Switch Key Button Switch 12x12x7.3mm Blue eBay 100PCS B3F-4055 Tactile Switch W/ OMRON Tact Push Button Momentary 12 x12 x7.3mm eBay Button Caps 140PCS Round Tactile Button Cap Kits 9.58 5.1mm for 12 12*7.3mm Tact Switch Sensor Kit Although not all of these items are really \"sensors\" (some are displays), these kits provide high value at a low price-per item cost. Note that some of these kits contain tilt switches that contain Mercery. I remove these from the kits. EBay 16 Sensor Kit Raspberry Pi / Arduino Sensor Kit 16 Modules Package 16 kinds of sensor EBay 45 Sensor Kit for $18 US 45 In 1 Sensor Module Starter Kit Updated Set For Arduino Raspberry Pi Education HiLetgo 37 Sensors Assortment Kit 37 Sensors Kit Sensor Starter Kit for Arduino Raspberry pi Sensor kit 37 in 1 Robot Projects Starter Kits for Arduino Raspberry pi Linear 10K Potentiometers We use linear 10K potentiometers in many labs and kits. The pre-wired options are very handy but you will need some male-to-male jumpers. EBay: Pre-wired Potentiometer with Knob EBay: 10 10K Pots for $2.29 Amazon: 10K Pot Kit with 8 pots and knobs for $8 Momentary Press Buttons We like these small momentary press buttons because they are easy to mount directly on the breadboard. They provide ideal \"Mode Programming\" buttons to put the microcontroller into a programming mode. Switches These are ideal for turning your project boxes on and off. Small 0.96\" OLED displays We love these low-cost 128X64 OLED displays. They are bright and draw very little power. There are two different connectors: 4-wire I2C and 7-wire SPI. I would suggest the simpler I2C for most starter projects. EBay: 0.96\" OLED LCD Display Module IIC I2C Interface 128x64 For SSD1306 Amazon: Five OLED displays for $7 Larger 2.42\" OLEDs For our robot projects our students like to view the values from a distance. For them we use these $17 OLED displays that are about twice the size. 2.42\" OLED Display wired with SPI Non-rechargeable AA and AAA Battery Packs Rechargeable Battery Packs If you are work on project that need long-lasting portable power such as LED strip costumes, there are a wide variety of long-lasting rechargeable battery packs available from prices around $9 to $15. My favorites are ones that have percentage of power remaining displayed. Ultrasonic Distance Sensors These inexpensive \"ping\" sensors are used in many robot projects. HC-SR04 Ultrasonic Distance Sensor - $1 on eBay Motor Controllers We like two motor three wheel robots in our classrooms. They need a H-Bridge circuit for controlling the motor direction. The popular L293D chip takes four PWM signals and will use these to drive two 3-12v DC motors. The L293D chip can be mounted directly on your breadboard. However, we like the low-cost Mini motor controller boards that are only $2 that also have handy screw headers for easily attaching and removing the motor and power wires. Here are the specs: Here Input DC 4.5-36V 600mA output per channel (per motor) See section 4.4 in the Raspberry Pi Pico Datasheet on the Powerchain - note that the input VSYS, the main system input voltage, is only designed to go up to up to 5.5 volts. VSYS feeds the RVT6150 buck-boost SMPS. Mini Motor Drive Shield Expansion Board L293D Module For Arduino UNO MEGA2560 R3 $3 [Amazon 3 motor drives for $7] L293 Datasheet Banggood L293D Motor Drive Module Parshavele ST Microelectronics L78M Datasheet Datasheet for 78M05 Voltage Datasheet for ST 78M05 Voltage Regulators Note that the L293D Mini Motor Drive shield also has a voltage regulator that delivers a constant 5 volt signal to the robot microcontroller.","title":"Sourcing Parts"},{"location":"getting-started/03-suggested-parts/#sourcing-parts","text":"One of the key values of CoderDojo clubs around the world is to not charge any fees for attending these clubs. Parts need to be purchase by limited funds raised through donations. Club organizers need to be frugal about getting low-cost parts for the participants. Our experience is that is difficult to get the right parts at low cost using firms that promise quick delivery times of a few days. The lowest price parts often must be purchased weeks in advance from places like China and Taiwan. As a result, clubs that use funds carefully must plan weeks if not months in advance of classes and events. So we strongly suggest bringing an robot part procurement team together two months before you begin to offer robot courses where students can each have their own robots.","title":"Sourcing Parts"},{"location":"getting-started/03-suggested-parts/#purchasing-the-raspberry-pi-kits","text":"As of June 2021, the Raspberry Pi Pico did not come integrated into low-cost development kits that include robot kit parts. You frequently must to purchase the independent parts yourself. Here are some of the parts we recommend.","title":"Purchasing The Raspberry Pi Kits"},{"location":"getting-started/03-suggested-parts/#the-raspberry-pi-pico","text":"In the US, our best source of these has been Microcenter stores. They sell them for $3.99 and they often have them on sale for $1.99. Microcenter Pico Part Listing Microcenter has around 25 Locations in the US.","title":"The Raspberry Pi Pico"},{"location":"getting-started/03-suggested-parts/#usb-cable","text":"For a Mac with USB-C connectors, you will need to get a USB micro to C cable: Ebay USB 3.1 USB C Type C to Micro USB Male Sync OTG Charge Data Transfers Adapters Sample 1 meter USB cable on eBay for $2.40.","title":"USB Cable"},{"location":"getting-started/03-suggested-parts/#headers","text":"We need male breakaway headers with standard 1/10th inch spacing. The Raspberry Pi Pico will need 20 pins on each side. If you get 40-pin versions they can easily be broken in half. EBay: Ebay 40-Pin Male Header 0.1\" 2.54mm Breadboard PCB Strip Connectors 5pc - these ship from China in a few weeks and you can get five of them for $1 (including shipping). Amazon: Amazon MCIGICM 10pcs Male Header Pin, 40 Pin Header Strip (2.54 mm) for Arduino Connector","title":"Headers"},{"location":"getting-started/03-suggested-parts/#solderless-breadboards","text":"We like the 1/2 size boards that have 400 connection points. We like to mount them with the USB connector at the top with the numbers running down the left side to align with the pin numbers. EBay: Solderless Breadboard 400 Point Tie Prototype Test Bread Board PCB For Arduino Amazon: Amazon 4 Pieces for $6","title":"Solderless Breadboards"},{"location":"getting-started/03-suggested-parts/#hookup-wire","text":"Use 22 gauge wire. Get a large spool of black and red and smaller spools of other colors.","title":"Hookup Wire"},{"location":"getting-started/03-suggested-parts/#male-to-male-breadboard-jumper-wires","text":"You can use 22 gauge wire to build your projects, however kids that don't have fine motor skills sometimes get frustrated with raw wires. You can purchase a Jumper Wire Kit with 65 jumpers on EBay for under $2 that has nice plastic ends that are easier to use. Ebay: 65pcs Jumper Wire cable kit for Solderless Breadboard New - 65 of various lengths for $1.50 Ebay: 65X 65PCS Jumper Wire Cable Kit For Solderless Breadboard Amazon: ZYAMY 195pcs Breadboard Jumper Wire 12cm 16cm 20cm 24cm Solderless Flexible Breadboard Connecting Line Cables Male to Male Breadboard Jumpers (65pcs/Set x 3) - three packs of 65 for about $8","title":"Male-to-Male Breadboard Jumper Wires"},{"location":"getting-started/03-suggested-parts/#momentary-press-buttons","text":"A B3F Momentary Press Button with a blue cap. Note the schematic in the lower right corner that shows the internal connections of the button. We like the B3F-4055 12 x12x7.3mm Tactile Switch Momentary Press Buttons that have small dimples on the bottom that fit into the breadboard center trough. They can be purchased for under 10 cents per unit on eBay. You can by them with our without colored caps. The links below have example listings on eBay. eBay Tactile Push Button Switch Momentary Tact & Cap 12x12x7.3mm Assorted Kit - this kit includes 15 switchs with seven colors of caps for US $8.95. eBay: 10PCS New B3F Tactile Switch Key Button Switch 12x12x7.3mm Blue eBay 100PCS B3F-4055 Tactile Switch W/ OMRON Tact Push Button Momentary 12 x12 x7.3mm eBay Button Caps 140PCS Round Tactile Button Cap Kits 9.58 5.1mm for 12 12*7.3mm Tact Switch","title":"Momentary Press Buttons"},{"location":"getting-started/03-suggested-parts/#sensor-kit","text":"Although not all of these items are really \"sensors\" (some are displays), these kits provide high value at a low price-per item cost. Note that some of these kits contain tilt switches that contain Mercery. I remove these from the kits. EBay 16 Sensor Kit Raspberry Pi / Arduino Sensor Kit 16 Modules Package 16 kinds of sensor EBay 45 Sensor Kit for $18 US 45 In 1 Sensor Module Starter Kit Updated Set For Arduino Raspberry Pi Education HiLetgo 37 Sensors Assortment Kit 37 Sensors Kit Sensor Starter Kit for Arduino Raspberry pi Sensor kit 37 in 1 Robot Projects Starter Kits for Arduino Raspberry pi","title":"Sensor Kit"},{"location":"getting-started/03-suggested-parts/#linear-10k-potentiometers","text":"We use linear 10K potentiometers in many labs and kits. The pre-wired options are very handy but you will need some male-to-male jumpers. EBay: Pre-wired Potentiometer with Knob EBay: 10 10K Pots for $2.29 Amazon: 10K Pot Kit with 8 pots and knobs for $8","title":"Linear 10K Potentiometers"},{"location":"getting-started/03-suggested-parts/#momentary-press-buttons_1","text":"We like these small momentary press buttons because they are easy to mount directly on the breadboard. They provide ideal \"Mode Programming\" buttons to put the microcontroller into a programming mode.","title":"Momentary Press Buttons"},{"location":"getting-started/03-suggested-parts/#switches","text":"These are ideal for turning your project boxes on and off.","title":"Switches"},{"location":"getting-started/03-suggested-parts/#small-096-oled-displays","text":"We love these low-cost 128X64 OLED displays. They are bright and draw very little power. There are two different connectors: 4-wire I2C and 7-wire SPI. I would suggest the simpler I2C for most starter projects. EBay: 0.96\" OLED LCD Display Module IIC I2C Interface 128x64 For SSD1306 Amazon: Five OLED displays for $7","title":"Small 0.96\" OLED displays"},{"location":"getting-started/03-suggested-parts/#larger-242-oleds","text":"For our robot projects our students like to view the values from a distance. For them we use these $17 OLED displays that are about twice the size. 2.42\" OLED Display wired with SPI","title":"Larger 2.42\" OLEDs"},{"location":"getting-started/03-suggested-parts/#non-rechargeable-aa-and-aaa-battery-packs","text":"","title":"Non-rechargeable AA and AAA Battery Packs"},{"location":"getting-started/03-suggested-parts/#rechargeable-battery-packs","text":"If you are work on project that need long-lasting portable power such as LED strip costumes, there are a wide variety of long-lasting rechargeable battery packs available from prices around $9 to $15. My favorites are ones that have percentage of power remaining displayed.","title":"Rechargeable Battery Packs"},{"location":"getting-started/03-suggested-parts/#ultrasonic-distance-sensors","text":"These inexpensive \"ping\" sensors are used in many robot projects. HC-SR04 Ultrasonic Distance Sensor - $1 on eBay","title":"Ultrasonic Distance Sensors"},{"location":"getting-started/03-suggested-parts/#motor-controllers","text":"We like two motor three wheel robots in our classrooms. They need a H-Bridge circuit for controlling the motor direction. The popular L293D chip takes four PWM signals and will use these to drive two 3-12v DC motors. The L293D chip can be mounted directly on your breadboard. However, we like the low-cost Mini motor controller boards that are only $2 that also have handy screw headers for easily attaching and removing the motor and power wires. Here are the specs: Here Input DC 4.5-36V 600mA output per channel (per motor) See section 4.4 in the Raspberry Pi Pico Datasheet on the Powerchain - note that the input VSYS, the main system input voltage, is only designed to go up to up to 5.5 volts. VSYS feeds the RVT6150 buck-boost SMPS. Mini Motor Drive Shield Expansion Board L293D Module For Arduino UNO MEGA2560 R3 $3 [Amazon 3 motor drives for $7] L293 Datasheet Banggood L293D Motor Drive Module Parshavele ST Microelectronics L78M Datasheet Datasheet for 78M05 Voltage Datasheet for ST 78M05 Voltage Regulators Note that the L293D Mini Motor Drive shield also has a voltage regulator that delivers a constant 5 volt signal to the robot microcontroller.","title":"Motor Controllers"},{"location":"getting-started/04-power/","text":"Powering Your MicroPython Projects If you are just using MicroPython to learn how to code you can use the USB connector from your Mac or PC to power your project. However, if you are creating a device that can't be connected to the USB cable such as a robot, then you will need to hook up portable power supply like a battery pack to power your device. The good news is that most microcontrollers like the Raspberry Pi Pico or ESP32 have many options and they are easy to use. Just be careful about applying too much power since unlike the old 5V Arduino boards, these devices only use 3.3v power supplies. Connecting the Pico to a 4 AA batteries (4 X 1.5 volts = 6 volt total) can damage the Pico microcontroller. Power Connectors The Raspberry Pi Pico has three important power connectors you should learn about. VBUS - A direct connection to the USB System bus and available in the upper right corner of the Pico. When connected, circuits inside the Pico will disconnect the other power sources. This is the preferred way to power the Pico when doing development and if a USB battery pack is used. VSYS - This the main system input voltage and used when the device is not connected to the USB. The Pico has on-board power control circuits that allow VSYS to vary anywhere in the range of 1.8V to 5.5V. This is great since three AAA batteries which start at 4.5 volts can be used even as their voltage drops to 1.8 volts. VSYS is used by the on-board SMPS (Switched Mode Power Supply) to generate the 3.3V for the RP2040 and its GPIO. You can use this to power the Pico if you have any non-USB battery pack such as 3 AA batteries or an external 5 volt power supply that is generated by a motor driver circuit. 3V3_EN connects to the on-board SMPS enable pin, and is pulled high (to VSYS) via a 100K resistor. To disable the 3.3V (which also de-powers the RP2040), short this pin low. 3.3OUT This pin can be used to power external circuitry. The maximum output current will depend on RP2040 load and VSYS voltage, it is recommended to keep the load on this pin less than 300mA. In in other words, you don't want to drive more than about 15 LEDs that each draw up to 20 milliamps at full power. 3V3 is the main 3.3V supply to RP2040 and its I/O, generated by the on-board SMPS. ADC_VREF - This should not be used for any purpose other than to provide a low-current voltage reference for any of the three analog-to-digital inputs. For example if you have three potentiometers you would hook the positive rail of each of them to this pin. This allows for reasonably high-resolution analog to digital that is mostly free of the power noise present on the 3.3OUT pin. USB Battery Packs There is large and growing market for rechargeable cell-phone power packs that are ideal for applications such as robotics and powering a remote microcontroller for a long time. They can be purchased in many power storage levels from 2500 milliamp hours up to over 1 million milliamp hours. Preventing USB Power Pack Autoshutdown The one issue to be aware of with battery packs is that they automatically power down if they don't sense a minimum current being drawn such as about 10 milliamps. In many applications the Pico draws less than that amount. One fix is to simply add LED power indicator that draws 10 milliamps. This will Battery Power 3 AA alkaline batteries wired in series provide plenty of power for small Pico-based MicroPython projects. Each battery is 1.5 volts which give a total of 4.5 volts which is well within the maximum power use by the VSYS input on the Pico. As an alternative, you can also use 4 rechargeable NiCad batteries that have a nominal rating of 1.2 volts each . This is a total of 4.8 volts, which is still under the 5.5 volt limit. Warning Do not connect 4 AA batteries directly to VSYS. 6 volts is too high for the Pico's power system and could damage it. Use a voltage regulator such as is found on motor driver boards. Another alternative is to use a DC-to-DC voltage regulator such as a Buck Converter . Monitoring USB Power On the Pico, GP24 can be used to indicate if power is being drawn from the USB cable. You can also use this information to change the behavior such as drop into low-power mode when disconnected from a USB source. See here Here is some sample MicroPython code that displays this value: 1 2 3 4 5 6 7 8 9 10 11 12 13 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) USBpower = machine . Pin ( 24 , machine . Pin . IN ) while True : led_onboard . value ( 1 ) utime . sleep ( 0.5 ) led_onboard . value ( 0 ) utime . sleep ( 0.5 ) if USBpower () != 1 : utime . sleep ( 1 ) This program prints out the value of the USB Power indicator. 1 2 3 4 5 6 7 8 9 10 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) USBpower = machine . Pin ( 24 , machine . Pin . IN ) if USBpower () = 1 : print ( 'drawing power from the USB' ) else print ( 'drawing power from VSYS - a battery or external power source' ) Power consumption when running this code is approximately 0.1W (19mA at 4.99V, so 4 x AA batteries (@ 2,000mAh each) would keep the Pico running for well over 4 days. Running both USB and External Battery Power on the Raspberry Pi Pico The battery should provide a voltage greater than 1.8v and less than 5.5v. Importantly if both a battery and a micro USB cable are connected at the same time a Schottky diode should be placed between the battery positive and VSYS [see section 4.4 & 4.5 of the Raspberry Pi Pico Datasheet . As long as the battery voltage is less than that coming in from the USB cable, power will be drawn from the USB supply and not the battery and, when you unplug the Pico from its USB supply, the Pico will keep on running, using power from the battery (and visa versa when you plug it back in). Monitoring Batter Power Level on the Raspberry Pi Pico You can use one of the three analog to digital converters to allow the Pico to monitor the power remaining in an external battery. For example if you have 3 AA batteries you can connect two 100K ohm resistors in series and connect the top and bottom to the power and ground. Then connect the midpoint to one of the three ADC inputs. This will give you a way to monitor the power remaining in an external battery. A fully charge battery pack voltage such at 4.5 volts will generate a voltage of 1/2 the maximum level. As the voltage drops to 1.8 volts it should display a value of 0%. An OLED can provide an ideal way to display the power level remaining.","title":"Powering Your Projects"},{"location":"getting-started/04-power/#powering-your-micropython-projects","text":"If you are just using MicroPython to learn how to code you can use the USB connector from your Mac or PC to power your project. However, if you are creating a device that can't be connected to the USB cable such as a robot, then you will need to hook up portable power supply like a battery pack to power your device. The good news is that most microcontrollers like the Raspberry Pi Pico or ESP32 have many options and they are easy to use. Just be careful about applying too much power since unlike the old 5V Arduino boards, these devices only use 3.3v power supplies. Connecting the Pico to a 4 AA batteries (4 X 1.5 volts = 6 volt total) can damage the Pico microcontroller.","title":"Powering Your MicroPython Projects"},{"location":"getting-started/04-power/#power-connectors","text":"The Raspberry Pi Pico has three important power connectors you should learn about. VBUS - A direct connection to the USB System bus and available in the upper right corner of the Pico. When connected, circuits inside the Pico will disconnect the other power sources. This is the preferred way to power the Pico when doing development and if a USB battery pack is used. VSYS - This the main system input voltage and used when the device is not connected to the USB. The Pico has on-board power control circuits that allow VSYS to vary anywhere in the range of 1.8V to 5.5V. This is great since three AAA batteries which start at 4.5 volts can be used even as their voltage drops to 1.8 volts. VSYS is used by the on-board SMPS (Switched Mode Power Supply) to generate the 3.3V for the RP2040 and its GPIO. You can use this to power the Pico if you have any non-USB battery pack such as 3 AA batteries or an external 5 volt power supply that is generated by a motor driver circuit. 3V3_EN connects to the on-board SMPS enable pin, and is pulled high (to VSYS) via a 100K resistor. To disable the 3.3V (which also de-powers the RP2040), short this pin low. 3.3OUT This pin can be used to power external circuitry. The maximum output current will depend on RP2040 load and VSYS voltage, it is recommended to keep the load on this pin less than 300mA. In in other words, you don't want to drive more than about 15 LEDs that each draw up to 20 milliamps at full power. 3V3 is the main 3.3V supply to RP2040 and its I/O, generated by the on-board SMPS. ADC_VREF - This should not be used for any purpose other than to provide a low-current voltage reference for any of the three analog-to-digital inputs. For example if you have three potentiometers you would hook the positive rail of each of them to this pin. This allows for reasonably high-resolution analog to digital that is mostly free of the power noise present on the 3.3OUT pin.","title":"Power Connectors"},{"location":"getting-started/04-power/#usb-battery-packs","text":"There is large and growing market for rechargeable cell-phone power packs that are ideal for applications such as robotics and powering a remote microcontroller for a long time. They can be purchased in many power storage levels from 2500 milliamp hours up to over 1 million milliamp hours.","title":"USB Battery Packs"},{"location":"getting-started/04-power/#preventing-usb-power-pack-autoshutdown","text":"The one issue to be aware of with battery packs is that they automatically power down if they don't sense a minimum current being drawn such as about 10 milliamps. In many applications the Pico draws less than that amount. One fix is to simply add LED power indicator that draws 10 milliamps. This will","title":"Preventing USB Power Pack Autoshutdown"},{"location":"getting-started/04-power/#battery-power","text":"3 AA alkaline batteries wired in series provide plenty of power for small Pico-based MicroPython projects. Each battery is 1.5 volts which give a total of 4.5 volts which is well within the maximum power use by the VSYS input on the Pico. As an alternative, you can also use 4 rechargeable NiCad batteries that have a nominal rating of 1.2 volts each . This is a total of 4.8 volts, which is still under the 5.5 volt limit. Warning Do not connect 4 AA batteries directly to VSYS. 6 volts is too high for the Pico's power system and could damage it. Use a voltage regulator such as is found on motor driver boards. Another alternative is to use a DC-to-DC voltage regulator such as a Buck Converter .","title":"Battery Power"},{"location":"getting-started/04-power/#monitoring-usb-power","text":"On the Pico, GP24 can be used to indicate if power is being drawn from the USB cable. You can also use this information to change the behavior such as drop into low-power mode when disconnected from a USB source. See here Here is some sample MicroPython code that displays this value: 1 2 3 4 5 6 7 8 9 10 11 12 13 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) USBpower = machine . Pin ( 24 , machine . Pin . IN ) while True : led_onboard . value ( 1 ) utime . sleep ( 0.5 ) led_onboard . value ( 0 ) utime . sleep ( 0.5 ) if USBpower () != 1 : utime . sleep ( 1 ) This program prints out the value of the USB Power indicator. 1 2 3 4 5 6 7 8 9 10 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) USBpower = machine . Pin ( 24 , machine . Pin . IN ) if USBpower () = 1 : print ( 'drawing power from the USB' ) else print ( 'drawing power from VSYS - a battery or external power source' ) Power consumption when running this code is approximately 0.1W (19mA at 4.99V, so 4 x AA batteries (@ 2,000mAh each) would keep the Pico running for well over 4 days.","title":"Monitoring USB Power"},{"location":"getting-started/04-power/#running-both-usb-and-external-battery-power-on-the-raspberry-pi-pico","text":"The battery should provide a voltage greater than 1.8v and less than 5.5v. Importantly if both a battery and a micro USB cable are connected at the same time a Schottky diode should be placed between the battery positive and VSYS [see section 4.4 & 4.5 of the Raspberry Pi Pico Datasheet . As long as the battery voltage is less than that coming in from the USB cable, power will be drawn from the USB supply and not the battery and, when you unplug the Pico from its USB supply, the Pico will keep on running, using power from the battery (and visa versa when you plug it back in).","title":"Running both USB and External Battery Power on the Raspberry Pi Pico"},{"location":"getting-started/04-power/#monitoring-batter-power-level-on-the-raspberry-pi-pico","text":"You can use one of the three analog to digital converters to allow the Pico to monitor the power remaining in an external battery. For example if you have 3 AA batteries you can connect two 100K ohm resistors in series and connect the top and bottom to the power and ground. Then connect the midpoint to one of the three ADC inputs. This will give you a way to monitor the power remaining in an external battery. A fully charge battery pack voltage such at 4.5 volts will generate a voltage of 1/2 the maximum level. As the voltage drops to 1.8 volts it should display a value of 0%. An OLED can provide an ideal way to display the power level remaining.","title":"Monitoring Batter Power Level on the Raspberry Pi Pico"},{"location":"getting-started/10-displays/","text":"Adding A Display to Your Project In the past, the memory available in an standard Arduino Uno (2K bytes) was too small to add high quality displays. With the arrival of the ESP32 and the Raspberry Pi Pico this has all changed. These microcontrollers have around 100 times that RAM - typically around 200K bytes. So we are integrating low-cost OLED displays into many of our CoderDojo projects! Display Types There are four main types of display technology that use for small microcontrollers. LED - Light Emitting Diode - these are often low-resolution but have larger area. The start with single color displays but there are also multi-color LED strips and LED matrix displays. OLED - Organic Light Emitting Diode - small low-cost and high-contrast monochrome displays used in watches. LCD - Liquid Crystal Display - many of these are monochrome displays that must have precise power to get consistent contrast. TFT - Thin Film Transistor - a type of LCD that are used for larger color screens. 240X240 TFT Display Full Color LCD TFT Display SPI HD 65K Module ST7735 Concepts Before you begin to use these displays, there are a few things to understand to use them effectively. Based on your project needs, you can use this knowledge to find the right solution for you. Framebuffers A framebuffer is a copy of the display information that is resident within the RAM of the microcontroller. It must be as large as the display. For a 128X64 monochrome display this would be 128 * 64 = 8192 bits or 1,024 bytes (1K). A full color 240X240 TFT which uses 8 bits for red, green and blue would require 3 X 8 X 240 X 240 = 1,382,400 bits or 172K bytes. Not all all displays need framebuffers. Some displays can take a series of vector drawing commands such as \"draw line\" and \"draw text\". These displays can be useful if you don't have a large amount of RAM. Display Chip Types There are two common versions: SSD1306 - This is the most popular and versatile chip. It can be used to drive many different types and sizes of OLEDs. The SSD1306 can be used with both the simple 4 wire I2C interface as well as the slightly faster 7 wire SPI interface. These devices have only four wires labeled VCC, GND, SDA and SCL. SDA is for data and SCL is for the clock. SH1106 - This is less popular version and supports the 4-wire I2C interface. ST7735 - This chip is used on larger color TFT displays. ILI9341 - This chip is used on larger TDF displays. You can usually look on the back of the display device and see what type of check controls your OLED display. Communication Protocols In addition to the multiple types of displays and types of chips driving the displays, there are also two options on how you want to communicate between your microcontroller and the display. I2C - This is the most common type and only requires two wires beside power and ground. Us this as your default unless you display does not support it. The original specification of I2C had a communication speed of 100K bits per second. Many systems can be run at 400K per second. SPI - This is a more complex interface and requires up to seven wires. Some devices only support SPI interfaces. SPI typically runs around 1M bits/second although it can go up to 10M bits/second in some applications. SPI is ideal when you want to transfer a large amount of display data to a screen quickly. Basic Draw Functions For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function. Initializing the Framebuffer Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following: Full list of Drawing Functions Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state is 0=off (black) and 1=on (white). Function Description Example blit fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x1, x2, y, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert invert the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel Draw a single point on the screen rect Draw an empty rectangle scroll Scroll the display text Write text at a point vline Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display Initialize the display write_cmd Write a command to the display show Update the display from the frame buffer poweroff poweron contrast write_data Interfaces I2C Pros: Simple four wire interface Pin Purpose Description SPI Example: 128X64 pixel monochrome displays Types of Displays Summary Table Display Type Cost Links Notes LCD OLED TFT Displays References ST7735 Micropython Driver by Anthony Norman","title":"Displays"},{"location":"getting-started/10-displays/#adding-a-display-to-your-project","text":"In the past, the memory available in an standard Arduino Uno (2K bytes) was too small to add high quality displays. With the arrival of the ESP32 and the Raspberry Pi Pico this has all changed. These microcontrollers have around 100 times that RAM - typically around 200K bytes. So we are integrating low-cost OLED displays into many of our CoderDojo projects!","title":"Adding A Display to Your Project"},{"location":"getting-started/10-displays/#display-types","text":"There are four main types of display technology that use for small microcontrollers. LED - Light Emitting Diode - these are often low-resolution but have larger area. The start with single color displays but there are also multi-color LED strips and LED matrix displays. OLED - Organic Light Emitting Diode - small low-cost and high-contrast monochrome displays used in watches. LCD - Liquid Crystal Display - many of these are monochrome displays that must have precise power to get consistent contrast. TFT - Thin Film Transistor - a type of LCD that are used for larger color screens. 240X240 TFT Display Full Color LCD TFT Display SPI HD 65K Module ST7735","title":"Display Types"},{"location":"getting-started/10-displays/#concepts","text":"Before you begin to use these displays, there are a few things to understand to use them effectively. Based on your project needs, you can use this knowledge to find the right solution for you.","title":"Concepts"},{"location":"getting-started/10-displays/#framebuffers","text":"A framebuffer is a copy of the display information that is resident within the RAM of the microcontroller. It must be as large as the display. For a 128X64 monochrome display this would be 128 * 64 = 8192 bits or 1,024 bytes (1K). A full color 240X240 TFT which uses 8 bits for red, green and blue would require 3 X 8 X 240 X 240 = 1,382,400 bits or 172K bytes. Not all all displays need framebuffers. Some displays can take a series of vector drawing commands such as \"draw line\" and \"draw text\". These displays can be useful if you don't have a large amount of RAM.","title":"Framebuffers"},{"location":"getting-started/10-displays/#display-chip-types","text":"There are two common versions: SSD1306 - This is the most popular and versatile chip. It can be used to drive many different types and sizes of OLEDs. The SSD1306 can be used with both the simple 4 wire I2C interface as well as the slightly faster 7 wire SPI interface. These devices have only four wires labeled VCC, GND, SDA and SCL. SDA is for data and SCL is for the clock. SH1106 - This is less popular version and supports the 4-wire I2C interface. ST7735 - This chip is used on larger color TFT displays. ILI9341 - This chip is used on larger TDF displays. You can usually look on the back of the display device and see what type of check controls your OLED display.","title":"Display Chip Types"},{"location":"getting-started/10-displays/#communication-protocols","text":"In addition to the multiple types of displays and types of chips driving the displays, there are also two options on how you want to communicate between your microcontroller and the display. I2C - This is the most common type and only requires two wires beside power and ground. Us this as your default unless you display does not support it. The original specification of I2C had a communication speed of 100K bits per second. Many systems can be run at 400K per second. SPI - This is a more complex interface and requires up to seven wires. Some devices only support SPI interfaces. SPI typically runs around 1M bits/second although it can go up to 10M bits/second in some applications. SPI is ideal when you want to transfer a large amount of display data to a screen quickly.","title":"Communication Protocols"},{"location":"getting-started/10-displays/#basic-draw-functions","text":"For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function.","title":"Basic Draw Functions"},{"location":"getting-started/10-displays/#initializing-the-framebuffer","text":"Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following:","title":"Initializing the Framebuffer"},{"location":"getting-started/10-displays/#full-list-of-drawing-functions","text":"Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state is 0=off (black) and 1=on (white). Function Description Example blit fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x1, x2, y, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert invert the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel Draw a single point on the screen rect Draw an empty rectangle scroll Scroll the display text Write text at a point vline Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display Initialize the display write_cmd Write a command to the display show Update the display from the frame buffer poweroff poweron contrast write_data","title":"Full list of Drawing Functions"},{"location":"getting-started/10-displays/#interfaces","text":"","title":"Interfaces"},{"location":"getting-started/10-displays/#i2c","text":"Pros: Simple four wire interface Pin Purpose Description","title":"I2C"},{"location":"getting-started/10-displays/#spi","text":"Example: 128X64 pixel monochrome displays","title":"SPI"},{"location":"getting-started/10-displays/#types-of-displays","text":"","title":"Types of Displays"},{"location":"getting-started/10-displays/#summary-table","text":"Display Type Cost Links Notes","title":"Summary Table"},{"location":"getting-started/10-displays/#lcd","text":"","title":"LCD"},{"location":"getting-started/10-displays/#oled","text":"","title":"OLED"},{"location":"getting-started/10-displays/#tft-displays","text":"","title":"TFT Displays"},{"location":"getting-started/10-displays/#references","text":"ST7735 Micropython Driver by Anthony Norman","title":"References"},{"location":"intro/01-intro/","text":"Introduction to MicroPython This lesson assumes that you have at least skimmed the Getting Started sections and have selected one of the MicroPython IDEs to write your code. The lesson will introduce you to the basic concepts of using MicroPython using the $4 Raspberry Pi Pico or a similar microcontroller. The first two examples just use the Raspberry Pi Pico and don't require a breadboard or wiring. All the subsequent examples will require you to place components on a solderless breadboard.","title":"Introduction"},{"location":"intro/01-intro/#introduction-to-micropython","text":"This lesson assumes that you have at least skimmed the Getting Started sections and have selected one of the MicroPython IDEs to write your code. The lesson will introduce you to the basic concepts of using MicroPython using the $4 Raspberry Pi Pico or a similar microcontroller. The first two examples just use the Raspberry Pi Pico and don't require a breadboard or wiring. All the subsequent examples will require you to place components on a solderless breadboard.","title":"Introduction to MicroPython"},{"location":"intro/03-blink/","text":"Blink in MicroPython Overview In this lab, we will use MicroPython to make the green on-board LED on the Raspberry Pi Pico blink on and off using MicroPython. The only things you need to run this program are an IDE like Thonny, a USB cable and a $4 Raspberry Pi Pico. Blinking the Builtin LED The pico has a single built in LED wired to logical pin 25. We call this GPIO 25. Here is a sample program that you can use: 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin # get the Pin function from the machine module from time import sleep # get the sleep library from the time module # this is the built-in green LED on the Pico led = machine . Pin ( 25 , machine . Pin . OUT ) # repeat forever while True : led . high () # turn on the LED sleep ( 0.5 ) # leave it on for 1/2 second led . low () # Turn off the LED sleep ( 0.5 ) # leave it off for 1/2 second This program has two parts. The first part is often called the preamble - this code gets executed once and loads the right libraries and initializes global variables. The second part is the main event loop. This program continues to run until the device is powered down or reset. The import machine statement is required to define the characteristics of our physical machine. The import time library is required for the python sleep function. Note that the text after the hash or pound characters are comments. Comments are ignored by the Python interpreter. Changing the Blink Speed Next, lets create a global variable for the delay that the LED is on and off. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin from time import sleep # this is the builtin LED on the Pico led = Pin ( 25 , machine . Pin . OUT ) # global variables delay = . 25 # repeat forever while True : led . high () # turn on the LED sleep ( delay ) # leave it on for 1/2 second led . low () # Turn off the LED sleep ( delay ) # leave it off for 1/2 second This program will blink the built-in LED on and off every 1/4 of a second. By changing the delay variable you can make the LED blink faster and slower. Challenge What is the fastest you can make the LED blink and still see it changing? What does this tell you about the human eye? Using Toggle Instead of using the on() and off() methods, we can also just use the toggle() function. 1 2 3 4 5 6 from machine import Pin from time import sleep led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () sleep ( . 25 ) If you save the file as main.py, this program will run when the pico starts up without the BOOTSEL being pressed. We will assume that an LED is connected to pin GIO16 and is connected via a 330 ohm resistor to ground. Here is the code that will blink an LED that is connected to PIN GIO16, which is in the upper right corner of the Pico. 1 2 3 4 5 6 7 8 9 10 11 import machine import time # this is the lower right corner pin on the Pico with USB on the bottom led = machine . Pin ( 16 , machine . Pin . OUT ) # repeat forever while True : led . high () # turn on the LED time . sleep ( 0.5 ) # leave it on for 1/2 second led . low () # Turn off the LED time . sleep ( 0.5 ) # leave it off for 1/2 second 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( 5 ) Virtual Lab If you don't have access to the $4 Raspberry Pi Pico or a similar device, you can also try the MicroPython Emulator: Unicorn Emulator","title":"Blink"},{"location":"intro/03-blink/#blink-in-micropython","text":"","title":"Blink in MicroPython"},{"location":"intro/03-blink/#overview","text":"In this lab, we will use MicroPython to make the green on-board LED on the Raspberry Pi Pico blink on and off using MicroPython. The only things you need to run this program are an IDE like Thonny, a USB cable and a $4 Raspberry Pi Pico.","title":"Overview"},{"location":"intro/03-blink/#blinking-the-builtin-led","text":"The pico has a single built in LED wired to logical pin 25. We call this GPIO 25. Here is a sample program that you can use: 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin # get the Pin function from the machine module from time import sleep # get the sleep library from the time module # this is the built-in green LED on the Pico led = machine . Pin ( 25 , machine . Pin . OUT ) # repeat forever while True : led . high () # turn on the LED sleep ( 0.5 ) # leave it on for 1/2 second led . low () # Turn off the LED sleep ( 0.5 ) # leave it off for 1/2 second This program has two parts. The first part is often called the preamble - this code gets executed once and loads the right libraries and initializes global variables. The second part is the main event loop. This program continues to run until the device is powered down or reset. The import machine statement is required to define the characteristics of our physical machine. The import time library is required for the python sleep function. Note that the text after the hash or pound characters are comments. Comments are ignored by the Python interpreter.","title":"Blinking the Builtin LED"},{"location":"intro/03-blink/#changing-the-blink-speed","text":"Next, lets create a global variable for the delay that the LED is on and off. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin from time import sleep # this is the builtin LED on the Pico led = Pin ( 25 , machine . Pin . OUT ) # global variables delay = . 25 # repeat forever while True : led . high () # turn on the LED sleep ( delay ) # leave it on for 1/2 second led . low () # Turn off the LED sleep ( delay ) # leave it off for 1/2 second This program will blink the built-in LED on and off every 1/4 of a second. By changing the delay variable you can make the LED blink faster and slower. Challenge What is the fastest you can make the LED blink and still see it changing? What does this tell you about the human eye?","title":"Changing the Blink Speed"},{"location":"intro/03-blink/#using-toggle","text":"Instead of using the on() and off() methods, we can also just use the toggle() function. 1 2 3 4 5 6 from machine import Pin from time import sleep led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () sleep ( . 25 ) If you save the file as main.py, this program will run when the pico starts up without the BOOTSEL being pressed. We will assume that an LED is connected to pin GIO16 and is connected via a 330 ohm resistor to ground. Here is the code that will blink an LED that is connected to PIN GIO16, which is in the upper right corner of the Pico. 1 2 3 4 5 6 7 8 9 10 11 import machine import time # this is the lower right corner pin on the Pico with USB on the bottom led = machine . Pin ( 16 , machine . Pin . OUT ) # repeat forever while True : led . high () # turn on the LED time . sleep ( 0.5 ) # leave it on for 1/2 second led . low () # Turn off the LED time . sleep ( 0.5 ) # leave it off for 1/2 second 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( 5 )","title":"Using Toggle"},{"location":"intro/03-blink/#virtual-lab","text":"If you don't have access to the $4 Raspberry Pi Pico or a similar device, you can also try the MicroPython Emulator: Unicorn Emulator","title":"Virtual Lab"},{"location":"intro/03-button/","text":"Button In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. We will use it to toggle the built-in LED. We will start out with simply polling the button 10 times a second to check it's state. Then we will show how to use an interrupt handler function to monitor events from the button. In the example above, we are connecting the button on the left to the lower-left corner pin of the Raspberry Pi Pico. This is GPIO Pin 15 and is in row number 20 of our breadboard . Momentary Switch Buttons We use \"B3F\" tactile switch buttons that can be mounted directly on our breadboards. When the button is pressed, it connects a wire that joins two pins on one side to the two pins on the other side. The buttons can be mounted directly over the trough in the center of the breadboard. They typically cost under $2 for 10 buttons or about 20 cents per button. Here are the internal connections within the switch. This is the connection diagram that shows how the button is connected to the GPIO connector in the lower-left corner of the Raspberry Pi Pico. This corresponds to GP15 or Pin #15 in our code. Sample Button Polling Code Here is our fist example that uses a simple \"watching\" loop to check if the button value has change 10 times per second. In this case, the built-in LED is connected to pin 25. 1 2 3 4 5 6 7 8 9 10 11 12 from machine import Pin import time # GPIO is the internal built-in LED led = Pin ( 25 , Pin . OUT ) # input on the lower left of the Pico using a built-in pull-down resistor to keep the value from floating button = Pin ( 15 , Pin . IN , Pin . PULL_DOWN ) while True : if button . value (): # if the value changes led . toggle () time . sleep ( 0.1 ) # wait 1/10th of a second Interrupt Handler Version Although the polling version is simple, it does take a lot of the CPU resources. The button.value() is checked 10 times a second, even though the button might only be pressed once a day! A more efficient version uses a strategy called an interrupt handler . This is a function that is \"registered\" by micropython to handel external events such as a button press. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Use an interrupt function count the number of times a button has been pressed from machine import Pin import micropython import time # global value button_pressed_count = 0 # Interrupt Service Routine for Button Pressed Events - with no debounce def button1_pressed ( change ): global button_pressed_count button_pressed_count += 1 button1 = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) button1 . irq ( handler = button1_pressed , trigger = Pin . IRQ_FALLING ) button_pressed_count_old = 0 while True : if button_pressed_count_old != button_pressed_count : print ( 'Button 1 value:' , button_pressed_count ) button_pressed_count_old = button_pressed_count Interrupt Handler with a Debounce Feature One of the problems with most switches is that they don't turn on and off perfectly each time. As the connection is getting close to closing some electrons jump the gap and the switch appears to turn on for a few microseconds. So to a computer, this looks like someone quickly pressing a button rapidly until it is firmly closed or completely open. This intermediate stage between completely open and closed is called the \"bounce\" stage of a switch opening and closing. To remove this problem and get a clean signal, we can use either a hardware solution (wiring a capacitor to remove the high frequency noise) or we can be clever and solve the problem with a few extra lines of code. The secret is to setup a timer when the switch is first closed or opened. We then ignore all the crazy stuff that happens for about 1/5th of a second (200 milliseconds). By then we usually have a solid indication that the button is changing state and we can return the new value. Here is a example of this \"Debounce\" code in MicroPython: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import utime from machine import Pin # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler button_presses = 0 # the count of times the button has been pressed last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # The lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail button_pin = machine . Pin ( 14 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global button_presses , last_time new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : button_presses += 1 last_time = new_time # now we register the handler function when the button is pressed button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # This is for only printing when a new button press count value happens old_presses = 0 while True : # only print on change in the button_presses value if button_presses != old_presses : print ( button_presses ) builtin_led . toggle () old_presses = button_presses References Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video Sample eBay List of Switches with trough pins Sample B3F Button on eBay 10 pieces for $1.50","title":"Buttons"},{"location":"intro/03-button/#button","text":"In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. We will use it to toggle the built-in LED. We will start out with simply polling the button 10 times a second to check it's state. Then we will show how to use an interrupt handler function to monitor events from the button. In the example above, we are connecting the button on the left to the lower-left corner pin of the Raspberry Pi Pico. This is GPIO Pin 15 and is in row number 20 of our breadboard .","title":"Button"},{"location":"intro/03-button/#momentary-switch-buttons","text":"We use \"B3F\" tactile switch buttons that can be mounted directly on our breadboards. When the button is pressed, it connects a wire that joins two pins on one side to the two pins on the other side. The buttons can be mounted directly over the trough in the center of the breadboard. They typically cost under $2 for 10 buttons or about 20 cents per button. Here are the internal connections within the switch. This is the connection diagram that shows how the button is connected to the GPIO connector in the lower-left corner of the Raspberry Pi Pico. This corresponds to GP15 or Pin #15 in our code.","title":"Momentary Switch Buttons"},{"location":"intro/03-button/#sample-button-polling-code","text":"Here is our fist example that uses a simple \"watching\" loop to check if the button value has change 10 times per second. In this case, the built-in LED is connected to pin 25. 1 2 3 4 5 6 7 8 9 10 11 12 from machine import Pin import time # GPIO is the internal built-in LED led = Pin ( 25 , Pin . OUT ) # input on the lower left of the Pico using a built-in pull-down resistor to keep the value from floating button = Pin ( 15 , Pin . IN , Pin . PULL_DOWN ) while True : if button . value (): # if the value changes led . toggle () time . sleep ( 0.1 ) # wait 1/10th of a second","title":"Sample Button Polling Code"},{"location":"intro/03-button/#interrupt-handler-version","text":"Although the polling version is simple, it does take a lot of the CPU resources. The button.value() is checked 10 times a second, even though the button might only be pressed once a day! A more efficient version uses a strategy called an interrupt handler . This is a function that is \"registered\" by micropython to handel external events such as a button press. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Use an interrupt function count the number of times a button has been pressed from machine import Pin import micropython import time # global value button_pressed_count = 0 # Interrupt Service Routine for Button Pressed Events - with no debounce def button1_pressed ( change ): global button_pressed_count button_pressed_count += 1 button1 = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) button1 . irq ( handler = button1_pressed , trigger = Pin . IRQ_FALLING ) button_pressed_count_old = 0 while True : if button_pressed_count_old != button_pressed_count : print ( 'Button 1 value:' , button_pressed_count ) button_pressed_count_old = button_pressed_count","title":"Interrupt Handler Version"},{"location":"intro/03-button/#interrupt-handler-with-a-debounce-feature","text":"One of the problems with most switches is that they don't turn on and off perfectly each time. As the connection is getting close to closing some electrons jump the gap and the switch appears to turn on for a few microseconds. So to a computer, this looks like someone quickly pressing a button rapidly until it is firmly closed or completely open. This intermediate stage between completely open and closed is called the \"bounce\" stage of a switch opening and closing. To remove this problem and get a clean signal, we can use either a hardware solution (wiring a capacitor to remove the high frequency noise) or we can be clever and solve the problem with a few extra lines of code. The secret is to setup a timer when the switch is first closed or opened. We then ignore all the crazy stuff that happens for about 1/5th of a second (200 milliseconds). By then we usually have a solid indication that the button is changing state and we can return the new value. Here is a example of this \"Debounce\" code in MicroPython: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import utime from machine import Pin # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler button_presses = 0 # the count of times the button has been pressed last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # The lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail button_pin = machine . Pin ( 14 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global button_presses , last_time new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : button_presses += 1 last_time = new_time # now we register the handler function when the button is pressed button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # This is for only printing when a new button press count value happens old_presses = 0 while True : # only print on change in the button_presses value if button_presses != old_presses : print ( button_presses ) builtin_led . toggle () old_presses = button_presses","title":"Interrupt Handler with a Debounce Feature"},{"location":"intro/03-button/#references","text":"Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video Sample eBay List of Switches with trough pins Sample B3F Button on eBay 10 pieces for $1.50","title":"References"},{"location":"intro/03-potentiometer/","text":"MicroPython Potentiometer Lab In this lab we will use a 10K ohm potentiometer to demonstrate how a turn of a knob can result in getting a continuous variable from a user into our code. We will show how we can use a potentiometer to change the blinking speed of on LED. About Analog to Digital Converters Digital microcontrollers are inherently noisy. They have clocks that pull power from the power supply and cause voltage fluctuations when we compare a signal to these power lines. This makes it difficult to get ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin. Circuit Diagram Connect the top rail of the potentiometer to row 6 which is the ADC_VREF pin. Connect the center tap to row 10 which is ADC0 Connect row 8 to the bottom rail of the potentiometer to the Analog Ground (AGND) pin Note: to get an accurate noise-free reading from the potentiometer you must use the ADC_VREF and the AGND pins. These are special pins designed to reduce the noise on the power areas of the pico. Sample Code To Print Potentiometer Values 1 2 3 4 5 6 from machine import ADC from utime import sleep pot = ADC ( 26 ) while True : print ( pot . read_u16 ()) sleep ( . 2 ) 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins. Changing Blink Speed with a Potentiometer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from machine import ADC , Pin from utime import sleep # this is the built-in LED on the Pico led = Pin ( 25 , Pin . OUT ) # ADC0 is GPIO 26. Connect to row 10 the right side pot = ADC ( 26 ) MAX_DELAY = . 5 # seconds # global variables delay = 0 # repeat forever while True : pot_value = pot . read_u16 () # read the value from the pot delay = pot_value / 65025 * MAX_DELAY print ( \"delay:\" , delay ) if delay > 0 : print ( \"frequency (toggles per second):\" , 1 / delay ) led . high () # turn on the LED sleep ( delay ) # leave it on for 1/2 second led . low () # Turn off the LED sleep ( delay ) # leave it off for 1/2 second The following video shows this script in action.","title":"Potentiometer"},{"location":"intro/03-potentiometer/#micropython-potentiometer-lab","text":"In this lab we will use a 10K ohm potentiometer to demonstrate how a turn of a knob can result in getting a continuous variable from a user into our code. We will show how we can use a potentiometer to change the blinking speed of on LED.","title":"MicroPython Potentiometer Lab"},{"location":"intro/03-potentiometer/#about-analog-to-digital-converters","text":"Digital microcontrollers are inherently noisy. They have clocks that pull power from the power supply and cause voltage fluctuations when we compare a signal to these power lines. This makes it difficult to get ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin.","title":"About Analog to Digital Converters"},{"location":"intro/03-potentiometer/#circuit-diagram","text":"Connect the top rail of the potentiometer to row 6 which is the ADC_VREF pin. Connect the center tap to row 10 which is ADC0 Connect row 8 to the bottom rail of the potentiometer to the Analog Ground (AGND) pin Note: to get an accurate noise-free reading from the potentiometer you must use the ADC_VREF and the AGND pins. These are special pins designed to reduce the noise on the power areas of the pico.","title":"Circuit Diagram"},{"location":"intro/03-potentiometer/#sample-code-to-print-potentiometer-values","text":"1 2 3 4 5 6 from machine import ADC from utime import sleep pot = ADC ( 26 ) while True : print ( pot . read_u16 ()) sleep ( . 2 ) 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins.","title":"Sample Code To Print Potentiometer Values"},{"location":"intro/03-potentiometer/#changing-blink-speed-with-a-potentiometer","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from machine import ADC , Pin from utime import sleep # this is the built-in LED on the Pico led = Pin ( 25 , Pin . OUT ) # ADC0 is GPIO 26. Connect to row 10 the right side pot = ADC ( 26 ) MAX_DELAY = . 5 # seconds # global variables delay = 0 # repeat forever while True : pot_value = pot . read_u16 () # read the value from the pot delay = pot_value / 65025 * MAX_DELAY print ( \"delay:\" , delay ) if delay > 0 : print ( \"frequency (toggles per second):\" , 1 / delay ) led . high () # turn on the LED sleep ( delay ) # leave it on for 1/2 second led . low () # Turn off the LED sleep ( delay ) # leave it off for 1/2 second The following video shows this script in action.","title":"Changing Blink Speed with a Potentiometer"},{"location":"intro/04-fade-in-and-out/","text":"Fade an LED in and Out In the prior Blink lab, we turned an LED on an off at different speeds. But what if we want to slowly turn on our LED on and off? In this lab we will show you how to dim your LED to any brightness level you want. Welcome to Pulse Width Modulation Although digital computers are good at quickly turning signals on and off, they don't really allow us to easily set an output to a given voltage level without complex circuits. But there is an easier way to adjust the brightness of an LED! We can quickly turn the signal to the LED on and off. We can do this so quickly that you can't even see it flicker. Controlling the amount of time a signal is on is all about controlling the width of the ON pulse. That is why this is called Pulse Width Modulation or PWM for short. With a PWM design there are two things we need to tell the microcontroller: How often do you want a square wave to go on and off? How wide should the on part of the pulse be (relative to the total width). This is called the duty cycle. The rate of change of the pulse is call the frequency. You can set the frequency to be 1,000 changes per second, which is much faster than the human eye can detect. This is done using the following line: 1 pwm . freq ( 1000 ) Note that we can slow the frequency way down and the dimming effect will still work. As an experiment you can change the PWM frequency to around 20 and you will see a distinct flicker as the LED turns on. Here is the sample program that will slowly dim the builtin LED that is on pin 25: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin, PWM from time import sleep pwm = PWM(Pin(25)) pwm.freq(1000) while True: for duty in range(65025): pwm.duty_u16(duty) sleep(0.0001) for duty in range(65025, 0, -1): pwm.duty_u16(duty) sleep(0.0001) Note that the duty cycle starts at 0 (always off) and moves slowly up to 65,025 (always on). It then does the reverse and slowly dims the LED and then repeats. There is only a 1/10,000 of a delay between these changes so the LED will completely turn on in about six seconds before it starts to dim again. PWM Functions Here is a list of the PWM functions. 1 2 3 4 5 6 7 8 from machine import Pin , PWM pwm0 = PWM ( Pin ( 0 )) # create PWM object from a pin pwm0 . freq () # get current frequency pwm0 . freq ( 1000 ) # set frequency (1000 cycles per minute) pwm0 . duty_u16 () # get current duty cycle, range 0-65535 pwm0 . duty_u16 ( 200 ) # set duty cycle, range 0-65535 pwm0 . deinit () # turn off PWM on the pin Make sure you deinit() to de-initialize the PWM controller after you are done. You may have to trap the stop to do this. For example if a PWM is driving motors, your Stop must send deinit() to each motor controller. See the Interrupt Handlers for details. Suggested Exercises Change the frequency from 1,000 to 500, 100, 50, 40, 30, 25, 20, and 10. When can you just barley see it flicker? What does this tell you about the human eye? Can you add a delay so that the LED stays on at full brightness for one second before it starts to dim again? Can you add a delay so that the LED is completely off for five seconds and then goes to full brightness and off in one second? What lights in your home would you like to see slowly dim on and off? How could you modify a light (safely) so that it slowly dimmed on and off. Would PWM work with all lightbulb types such as tungsten filament bulbs that take a long time to heat up and cool down? Can you hook up a set of red, green and blue LEDs program them to fade in and out to display all the colors of the rainbow (red, orange, yellow, green, blue, indigo and violet)? When you stop the program does the LED stop changing brightness? Does it retain the value that it had when you pressed the Stop function? What does that tell you about how main CPU and the role of PWM? Note that we will cover up doing \"cleanup\" events that stop all PWM activity in our Interrupt Handlers Lab References Pulse With Modulation Wikipedia Article on Pulse With Modulation","title":"Fade In and Out"},{"location":"intro/04-fade-in-and-out/#fade-an-led-in-and-out","text":"In the prior Blink lab, we turned an LED on an off at different speeds. But what if we want to slowly turn on our LED on and off? In this lab we will show you how to dim your LED to any brightness level you want.","title":"Fade an LED in and Out"},{"location":"intro/04-fade-in-and-out/#welcome-to-pulse-width-modulation","text":"Although digital computers are good at quickly turning signals on and off, they don't really allow us to easily set an output to a given voltage level without complex circuits. But there is an easier way to adjust the brightness of an LED! We can quickly turn the signal to the LED on and off. We can do this so quickly that you can't even see it flicker. Controlling the amount of time a signal is on is all about controlling the width of the ON pulse. That is why this is called Pulse Width Modulation or PWM for short. With a PWM design there are two things we need to tell the microcontroller: How often do you want a square wave to go on and off? How wide should the on part of the pulse be (relative to the total width). This is called the duty cycle. The rate of change of the pulse is call the frequency. You can set the frequency to be 1,000 changes per second, which is much faster than the human eye can detect. This is done using the following line: 1 pwm . freq ( 1000 ) Note that we can slow the frequency way down and the dimming effect will still work. As an experiment you can change the PWM frequency to around 20 and you will see a distinct flicker as the LED turns on. Here is the sample program that will slowly dim the builtin LED that is on pin 25: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin, PWM from time import sleep pwm = PWM(Pin(25)) pwm.freq(1000) while True: for duty in range(65025): pwm.duty_u16(duty) sleep(0.0001) for duty in range(65025, 0, -1): pwm.duty_u16(duty) sleep(0.0001) Note that the duty cycle starts at 0 (always off) and moves slowly up to 65,025 (always on). It then does the reverse and slowly dims the LED and then repeats. There is only a 1/10,000 of a delay between these changes so the LED will completely turn on in about six seconds before it starts to dim again.","title":"Welcome to Pulse Width Modulation"},{"location":"intro/04-fade-in-and-out/#pwm-functions","text":"Here is a list of the PWM functions. 1 2 3 4 5 6 7 8 from machine import Pin , PWM pwm0 = PWM ( Pin ( 0 )) # create PWM object from a pin pwm0 . freq () # get current frequency pwm0 . freq ( 1000 ) # set frequency (1000 cycles per minute) pwm0 . duty_u16 () # get current duty cycle, range 0-65535 pwm0 . duty_u16 ( 200 ) # set duty cycle, range 0-65535 pwm0 . deinit () # turn off PWM on the pin Make sure you deinit() to de-initialize the PWM controller after you are done. You may have to trap the stop to do this. For example if a PWM is driving motors, your Stop must send deinit() to each motor controller. See the Interrupt Handlers for details.","title":"PWM Functions"},{"location":"intro/04-fade-in-and-out/#suggested-exercises","text":"Change the frequency from 1,000 to 500, 100, 50, 40, 30, 25, 20, and 10. When can you just barley see it flicker? What does this tell you about the human eye? Can you add a delay so that the LED stays on at full brightness for one second before it starts to dim again? Can you add a delay so that the LED is completely off for five seconds and then goes to full brightness and off in one second? What lights in your home would you like to see slowly dim on and off? How could you modify a light (safely) so that it slowly dimmed on and off. Would PWM work with all lightbulb types such as tungsten filament bulbs that take a long time to heat up and cool down? Can you hook up a set of red, green and blue LEDs program them to fade in and out to display all the colors of the rainbow (red, orange, yellow, green, blue, indigo and violet)? When you stop the program does the LED stop changing brightness? Does it retain the value that it had when you pressed the Stop function? What does that tell you about how main CPU and the role of PWM? Note that we will cover up doing \"cleanup\" events that stop all PWM activity in our Interrupt Handlers Lab","title":"Suggested Exercises"},{"location":"intro/04-fade-in-and-out/#references","text":"","title":"References"},{"location":"intro/04-fade-in-and-out/#pulse-with-modulation","text":"Wikipedia Article on Pulse With Modulation","title":"Pulse With Modulation"},{"location":"intro/04-motor/","text":"Driving a Motor with the Pico The Pico has 26 general purpose input and output pins. However, each pin's power is designed to digitally communicate with other devices and has a limited current capacity of around 17 milliamps according to the Raspberry Pi Pico Datasheet Table 5 . 17 milliamps is fine for lighting up an LED. However, motors require much more power. 17 milliamps is not enough current to drive even small motors. Even our small DC hobby motors we use with our robots require around 200 milliamps. But don't worry! We have two ways around this problem. The first option is to use a simple transistor as a \"switch\" that will use our low-power digital signal to control its on-and-off settings. The second option is to use a full motor driver chip such as an L293D chip. This chip takes the same PWM signal we learned about in our Fade In and Out Lab . Basic Transistor Circuit Transistor NPN 2222A Diode: 1N1448 Motor: 3-6 volt hobby motor PWM Control PWM Frequency Set the frequency to 50Hz (one cycle per 20ms) and the duty value to between 51 (51/1023 * 20ms = 1ms) and 102 (102/1023 * 20ms = 2ms) Sample Coder 1 2 3 4 5 6 7 8 import machine # set the 7th from the bottom on right as our motor pin motor_pin = machine . Pin ( 21 , machine . Pin . OUT ) # allocate a PWM object for controlling the motor speed motor_pwm = machine . PWM ( motor_pin ) motor_pwm . freq ( 50 ) # 50 hertz motor_pwm . duty ( 51 ) References Sparkfun Motor Lab from SIK Kit Nick Zoic MicroPython Motor Control Tutorial","title":"Motor"},{"location":"intro/04-motor/#driving-a-motor-with-the-pico","text":"The Pico has 26 general purpose input and output pins. However, each pin's power is designed to digitally communicate with other devices and has a limited current capacity of around 17 milliamps according to the Raspberry Pi Pico Datasheet Table 5 . 17 milliamps is fine for lighting up an LED. However, motors require much more power. 17 milliamps is not enough current to drive even small motors. Even our small DC hobby motors we use with our robots require around 200 milliamps. But don't worry! We have two ways around this problem. The first option is to use a simple transistor as a \"switch\" that will use our low-power digital signal to control its on-and-off settings. The second option is to use a full motor driver chip such as an L293D chip. This chip takes the same PWM signal we learned about in our Fade In and Out Lab .","title":"Driving a Motor with the Pico"},{"location":"intro/04-motor/#basic-transistor-circuit","text":"Transistor NPN 2222A Diode: 1N1448 Motor: 3-6 volt hobby motor","title":"Basic Transistor Circuit"},{"location":"intro/04-motor/#pwm-control","text":"","title":"PWM Control"},{"location":"intro/04-motor/#pwm-frequency","text":"Set the frequency to 50Hz (one cycle per 20ms) and the duty value to between 51 (51/1023 * 20ms = 1ms) and 102 (102/1023 * 20ms = 2ms)","title":"PWM Frequency"},{"location":"intro/04-motor/#sample-coder","text":"1 2 3 4 5 6 7 8 import machine # set the 7th from the bottom on right as our motor pin motor_pin = machine . Pin ( 21 , machine . Pin . OUT ) # allocate a PWM object for controlling the motor speed motor_pwm = machine . PWM ( motor_pin ) motor_pwm . freq ( 50 ) # 50 hertz motor_pwm . duty ( 51 )","title":"Sample Coder"},{"location":"intro/04-motor/#references","text":"Sparkfun Motor Lab from SIK Kit Nick Zoic MicroPython Motor Control Tutorial","title":"References"},{"location":"intro/04-read-pot/","text":"Using MicroPython to Read a Potentiometer Reading a Potentiometer ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin. 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins. Sampling data Sometimes the data coming from your Potentiometer is noisy. You can sample the value multiple times and then average the values. Here is a sample program. Just pass in the pin and a count and it will return the average values. This version waits 5 milliseconds between samples. 1 2 3 4 5 6 def sample_pot ( pin , count ): total = 0 for i in range ( count ): total += int ( pin . read_u16 ()) utime . sleep_ms ( 5 ) return int ( total / count ) 1 2 3 pot_pin_1 = machine . ADC ( 26 ) # return a value after sampling 10 times sample_pot ( pot_pin_1 , 10 )","title":"Using MicroPython to Read a Potentiometer"},{"location":"intro/04-read-pot/#using-micropython-to-read-a-potentiometer","text":"","title":"Using MicroPython to Read a Potentiometer"},{"location":"intro/04-read-pot/#reading-a-potentiometer","text":"ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin. 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins.","title":"Reading a Potentiometer"},{"location":"intro/04-read-pot/#sampling-data","text":"Sometimes the data coming from your Potentiometer is noisy. You can sample the value multiple times and then average the values. Here is a sample program. Just pass in the pin and a count and it will return the average values. This version waits 5 milliseconds between samples. 1 2 3 4 5 6 def sample_pot ( pin , count ): total = 0 for i in range ( count ): total += int ( pin . read_u16 ()) utime . sleep_ms ( 5 ) return int ( total / count ) 1 2 3 pot_pin_1 = machine . ADC ( 26 ) # return a value after sampling 10 times sample_pot ( pot_pin_1 , 10 )","title":"Sampling data"},{"location":"intro/04-servo/","text":"Micropython Servo Lab TBD 1 2 3 4 5 6 7 import machine import pyb # The pyboard has four simple servo connections servo = pyb . Servo ( 1 ) servo . angle ( 90 , 5000 )","title":"Servo"},{"location":"intro/04-servo/#micropython-servo-lab","text":"TBD 1 2 3 4 5 6 7 import machine import pyb # The pyboard has four simple servo connections servo = pyb . Servo ( 1 ) servo . angle ( 90 , 5000 )","title":"Micropython Servo Lab"},{"location":"intro/05-neopixel/","text":"NeoPixel NeoPixels are Red-Green-Blue LEDs that are assembled in a way that makes them easy to control with three wires: GND, +5V and a serial data line. They are very popular with our students because they are powerful, easy to program and full of bling . Note As of September of 2021 there is no built-in support for NeoPixels in the MicroPython runtime for the Raspberry Pi RP2040 microcontroller. Other microcontrollers (like the ESP32, ESP8266), NeoPixel support is built in to the runtime library. The RP2040 may have direct support in the future, but for the short time we will have to download a NeoPixel library or add a NeoPixel function to our code. To find out if your current runtime has support for the NeoPixel run the help('modules') command at the RPEL prompt. Controlling NeoPixels is challenging since the timing of data being sent must be very precise. Python alone is not fast enough to send bits out of a serial port. So a small function that uses assembly code is used. This code can be called directly from a neopixel driver file so that the user's don't need to see this code. MicroPython Example Code on ESP8266 Circuit connections LED Strip Pico Name Pico Pin Description GND GND 3 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 1 Topmost left with USB on top Setup Parameters 1 2 NUM_LEDS = 12 PIN_NUM = 0 Initialize the Strip Object 1 2 3 4 5 NUMBER_PIXELS = 12 STATE_MACHINE = 0 LED_PIN = 0 strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) Turn all the Pixels Red 1 2 3 4 5 6 7 8 9 10 11 from neopixel import Neopixel NUMBER_PIXELS = 12 STATE_MACHINE = 0 LED_PIN = 0 strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) for i in range ( 0 , NUMBER_PIXELS ): strip . set_pixel ( i , ( 255 , 0 , 0 )) strip . show () Turn All the Pixels Red, Green and Blue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import time # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 12 STATE_MACHINE = 0 LED_PIN = 0 # We are using the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # set 100% brightness strip . brightness ( 100 ) delay = . 1 red = ( 255 , 0 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) while True : for i in range ( 0 , NUMBER_PIXELS ): strip . set_pixel ( i , red ) strip . show () time . sleep ( delay ) for i in range ( 0 , NUMBER_PIXELS ): strip . set_pixel ( i , green ) strip . show () time . sleep ( delay ) for i in range ( 0 , NUMBER_PIXELS ): strip . set_pixel ( i , blue ) strip . show () time . sleep ( delay ) Full code (no library) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 # Example using PIO to drive a set of WS2812 LEDs. import array , time from machine import Pin import rp2 # Configure the number of WS2812 LEDs. NUM_LEDS = 60 PIN_NUM = 22 brightness = 0.2 @rp2 . asm_pio ( sideset_init = rp2 . PIO . OUT_LOW , out_shiftdir = rp2 . PIO . SHIFT_LEFT , autopull = True , pull_thresh = 24 ) def ws2812 (): T1 = 2 T2 = 5 T3 = 3 wrap_target () label ( \"bitloop\" ) out ( x , 1 ) . side ( 0 ) [ T3 - 1 ] jmp ( not_x , \"do_zero\" ) . side ( 1 ) [ T1 - 1 ] jmp ( \"bitloop\" ) . side ( 1 ) [ T2 - 1 ] label ( \"do_zero\" ) nop () . side ( 0 ) [ T2 - 1 ] wrap () # Create the StateMachine with the ws2812 program, outputting on pin sm = rp2 . StateMachine ( 0 , ws2812 , freq = 8_000_000 , sideset_base = Pin ( PIN_NUM )) # Start the StateMachine, it will wait for data on its FIFO. sm . active ( 1 ) # Display a pattern on the LEDs via an array of LED RGB values. ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) ########################################################################## def pixels_show (): dimmer_ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) for i , c in enumerate ( ar ): r = int ((( c >> 8 ) & 0xFF ) * brightness ) g = int ((( c >> 16 ) & 0xFF ) * brightness ) b = int (( c & 0xFF ) * brightness ) dimmer_ar [ i ] = ( g << 16 ) + ( r << 8 ) + b sm . put ( dimmer_ar , 8 ) time . sleep_ms ( 10 ) def pixels_set ( i , color ): ar [ i ] = ( color [ 1 ] << 16 ) + ( color [ 0 ] << 8 ) + color [ 2 ] def pixels_fill ( color ): for i in range ( len ( ar )): pixels_set ( i , color ) def color_chase ( color , wait ): for i in range ( NUM_LEDS ): pixels_set ( i , color ) time . sleep ( wait ) pixels_show () time . sleep ( 0.2 ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait ): for j in range ( 255 ): for i in range ( NUM_LEDS ): rc_index = ( i * 256 // NUM_LEDS ) + j pixels_set ( i , wheel ( rc_index & 255 )) pixels_show () time . sleep ( wait ) BLACK = ( 0 , 0 , 0 ) RED = ( 255 , 0 , 0 ) YELLOW = ( 255 , 150 , 0 ) GREEN = ( 0 , 255 , 0 ) CYAN = ( 0 , 255 , 255 ) BLUE = ( 0 , 0 , 255 ) PURPLE = ( 180 , 0 , 255 ) WHITE = ( 255 , 255 , 255 ) COLORS = ( BLACK , RED , YELLOW , GREEN , CYAN , BLUE , PURPLE , WHITE ) print ( \"fills\" ) for color in COLORS : pixels_fill ( color ) pixels_show () time . sleep ( 0.2 ) print ( \"chases\" ) for color in COLORS : color_chase ( color , 0.01 ) print ( \"rainbow\" ) rainbow_cycle ( 0 ) References Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video MicroPython Library for NeoPixel - note the lack of support for the RP2040 microcontroller. rp2 port no module named array","title":"NeoPixel"},{"location":"intro/05-neopixel/#neopixel","text":"NeoPixels are Red-Green-Blue LEDs that are assembled in a way that makes them easy to control with three wires: GND, +5V and a serial data line. They are very popular with our students because they are powerful, easy to program and full of bling . Note As of September of 2021 there is no built-in support for NeoPixels in the MicroPython runtime for the Raspberry Pi RP2040 microcontroller. Other microcontrollers (like the ESP32, ESP8266), NeoPixel support is built in to the runtime library. The RP2040 may have direct support in the future, but for the short time we will have to download a NeoPixel library or add a NeoPixel function to our code. To find out if your current runtime has support for the NeoPixel run the help('modules') command at the RPEL prompt. Controlling NeoPixels is challenging since the timing of data being sent must be very precise. Python alone is not fast enough to send bits out of a serial port. So a small function that uses assembly code is used. This code can be called directly from a neopixel driver file so that the user's don't need to see this code. MicroPython Example Code on ESP8266","title":"NeoPixel"},{"location":"intro/05-neopixel/#circuit-connections","text":"LED Strip Pico Name Pico Pin Description GND GND 3 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 1 Topmost left with USB on top","title":"Circuit connections"},{"location":"intro/05-neopixel/#setup-parameters","text":"1 2 NUM_LEDS = 12 PIN_NUM = 0","title":"Setup Parameters"},{"location":"intro/05-neopixel/#initialize-the-strip-object","text":"1 2 3 4 5 NUMBER_PIXELS = 12 STATE_MACHINE = 0 LED_PIN = 0 strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" )","title":"Initialize the Strip Object"},{"location":"intro/05-neopixel/#turn-all-the-pixels-red","text":"1 2 3 4 5 6 7 8 9 10 11 from neopixel import Neopixel NUMBER_PIXELS = 12 STATE_MACHINE = 0 LED_PIN = 0 strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) for i in range ( 0 , NUMBER_PIXELS ): strip . set_pixel ( i , ( 255 , 0 , 0 )) strip . show ()","title":"Turn all the Pixels Red"},{"location":"intro/05-neopixel/#turn-all-the-pixels-red-green-and-blue","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import time # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 12 STATE_MACHINE = 0 LED_PIN = 0 # We are using the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # set 100% brightness strip . brightness ( 100 ) delay = . 1 red = ( 255 , 0 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) while True : for i in range ( 0 , NUMBER_PIXELS ): strip . set_pixel ( i , red ) strip . show () time . sleep ( delay ) for i in range ( 0 , NUMBER_PIXELS ): strip . set_pixel ( i , green ) strip . show () time . sleep ( delay ) for i in range ( 0 , NUMBER_PIXELS ): strip . set_pixel ( i , blue ) strip . show () time . sleep ( delay )","title":"Turn All the Pixels Red, Green and Blue"},{"location":"intro/05-neopixel/#full-code-no-library","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 # Example using PIO to drive a set of WS2812 LEDs. import array , time from machine import Pin import rp2 # Configure the number of WS2812 LEDs. NUM_LEDS = 60 PIN_NUM = 22 brightness = 0.2 @rp2 . asm_pio ( sideset_init = rp2 . PIO . OUT_LOW , out_shiftdir = rp2 . PIO . SHIFT_LEFT , autopull = True , pull_thresh = 24 ) def ws2812 (): T1 = 2 T2 = 5 T3 = 3 wrap_target () label ( \"bitloop\" ) out ( x , 1 ) . side ( 0 ) [ T3 - 1 ] jmp ( not_x , \"do_zero\" ) . side ( 1 ) [ T1 - 1 ] jmp ( \"bitloop\" ) . side ( 1 ) [ T2 - 1 ] label ( \"do_zero\" ) nop () . side ( 0 ) [ T2 - 1 ] wrap () # Create the StateMachine with the ws2812 program, outputting on pin sm = rp2 . StateMachine ( 0 , ws2812 , freq = 8_000_000 , sideset_base = Pin ( PIN_NUM )) # Start the StateMachine, it will wait for data on its FIFO. sm . active ( 1 ) # Display a pattern on the LEDs via an array of LED RGB values. ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) ########################################################################## def pixels_show (): dimmer_ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) for i , c in enumerate ( ar ): r = int ((( c >> 8 ) & 0xFF ) * brightness ) g = int ((( c >> 16 ) & 0xFF ) * brightness ) b = int (( c & 0xFF ) * brightness ) dimmer_ar [ i ] = ( g << 16 ) + ( r << 8 ) + b sm . put ( dimmer_ar , 8 ) time . sleep_ms ( 10 ) def pixels_set ( i , color ): ar [ i ] = ( color [ 1 ] << 16 ) + ( color [ 0 ] << 8 ) + color [ 2 ] def pixels_fill ( color ): for i in range ( len ( ar )): pixels_set ( i , color ) def color_chase ( color , wait ): for i in range ( NUM_LEDS ): pixels_set ( i , color ) time . sleep ( wait ) pixels_show () time . sleep ( 0.2 ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait ): for j in range ( 255 ): for i in range ( NUM_LEDS ): rc_index = ( i * 256 // NUM_LEDS ) + j pixels_set ( i , wheel ( rc_index & 255 )) pixels_show () time . sleep ( wait ) BLACK = ( 0 , 0 , 0 ) RED = ( 255 , 0 , 0 ) YELLOW = ( 255 , 150 , 0 ) GREEN = ( 0 , 255 , 0 ) CYAN = ( 0 , 255 , 255 ) BLUE = ( 0 , 0 , 255 ) PURPLE = ( 180 , 0 , 255 ) WHITE = ( 255 , 255 , 255 ) COLORS = ( BLACK , RED , YELLOW , GREEN , CYAN , BLUE , PURPLE , WHITE ) print ( \"fills\" ) for color in COLORS : pixels_fill ( color ) pixels_show () time . sleep ( 0.2 ) print ( \"chases\" ) for color in COLORS : color_chase ( color , 0.01 ) print ( \"rainbow\" ) rainbow_cycle ( 0 )","title":"Full code (no library)"},{"location":"intro/05-neopixel/#references","text":"Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video MicroPython Library for NeoPixel - note the lack of support for the RP2040 microcontroller. rp2 port no module named array","title":"References"},{"location":"kits/01-intro/","text":"Kits for Learning MicroPython This section review several kits for learning MicroPython. Most of them use the RP2040 chip, but there are some that also use the ESP32 when wireless communication is needed. Solderless Connectors There are several types of solderless connectors used in these kits. They connect sensors and motors to these kits without the need for soldering. They are ideal for student labs that don't want the fire-hazards associated with soldering or where solderless breadboards and hot-glue is not flexible enough. These are usually 3 and 4-wire connectors that support analog and digital input and output as well as I2C bus and UART communications. They are typically designed to carry about 1 amp of current. Grove Connectors - popular with Seeed and Cyton kits. See the manual here Qwiic - SparkFun I2C connector Stemma and Stemma QT - Adafruit connectors are built around standard JST PH 2mm spacing connectors. Example Kits The following list is not design to be an exhaustive list of all MicroPython development kits available on the market. We focus on value-based kits that will help our students have fun learning computational thinking. Basic Kit - Our standard labs use a $4 Raspberry Pi Pico on a $2 solderless breadboard. You will also need some 22-gauge wire or a jumper wire kit. Maker Pi RP2040 Kit - this is a $9.90 kit from Cytron that features a single board with many features for small robots. It is an ideal low-cost starter kit. Searching SparkFun You can also use the MicroPython \"tag\" to search all the kits on the SparkFun site: https://www.sparkfun.com/categories/tags/micropython References Here are kits that we have seen but have not yet evaluated: Waveshare PicoGo Robot PicoGo Mobile Robot is a $43 robot based on Raspberry Pi Pico. SKU: 20380 Part Number: PicoGo-EN Powered by 2x 14500 Li-ion batteries. NOTE! We don't recommend these for classroom use since they are a fire hazard. Battery protection circuit: over charge/discharge protection, over current protection, short circuit protection, reverse proof, more stable and safe operating Recharge/Discharge circuit, allows programming/debugging concurrently while recharging 5-ch infrared sensor, analog output, combined with PID algorithm, stable line tracking Onboard multiple smart robot sensors like line tracking, obstacle avoidance, no more messy wiring 1.14 inch IPS colorful LCD display, 240 x135 pixels, 65K colors Integrates Bluetooth module, allows teleoperations like robot movement, RGB LED display color, buzzer, etc. by using mobile phone APP N20 micro geared motors, with metal gears, low noise, high accuracy NeoPixel Line following sensors Getting Started Kits Vilros Getting Started Kit Vilros Getting Started With MicroPython on Raspberry Pi Pico Kit This kit includes: List price is $44.99 Raspberry Pi Pico with soldered headers Includes printed Vilros Get Started with MicroPython on Raspberry Pi Pico booklet USB Type-A to micro cable - 1 meter 3AA battery pack with micro USB connector 30 \u00d7 Jumper wires 12 LEDs: 3x red, 3x blue,3x yellow and 3x green 5 Push-button switches 10 330 \u03a9 resistors Piezoelectric buzzer 2 10 k\u03a9 potentiometers HC-SR501 PIR sensor I2C 1602 character LCD module WS2812B LED strip Clear hard plastic box for small part storage Neoprene case With pocket Raspberry Pi Pico pinout guide The only problem with the parts is the lack of connectors for the potentiometers don't work well directly on the breadboard. You will need to solder wires to use them on the breadboard.","title":"Introduction"},{"location":"kits/01-intro/#kits-for-learning-micropython","text":"This section review several kits for learning MicroPython. Most of them use the RP2040 chip, but there are some that also use the ESP32 when wireless communication is needed.","title":"Kits for Learning MicroPython"},{"location":"kits/01-intro/#solderless-connectors","text":"There are several types of solderless connectors used in these kits. They connect sensors and motors to these kits without the need for soldering. They are ideal for student labs that don't want the fire-hazards associated with soldering or where solderless breadboards and hot-glue is not flexible enough. These are usually 3 and 4-wire connectors that support analog and digital input and output as well as I2C bus and UART communications. They are typically designed to carry about 1 amp of current. Grove Connectors - popular with Seeed and Cyton kits. See the manual here Qwiic - SparkFun I2C connector Stemma and Stemma QT - Adafruit connectors are built around standard JST PH 2mm spacing connectors.","title":"Solderless Connectors"},{"location":"kits/01-intro/#example-kits","text":"The following list is not design to be an exhaustive list of all MicroPython development kits available on the market. We focus on value-based kits that will help our students have fun learning computational thinking. Basic Kit - Our standard labs use a $4 Raspberry Pi Pico on a $2 solderless breadboard. You will also need some 22-gauge wire or a jumper wire kit. Maker Pi RP2040 Kit - this is a $9.90 kit from Cytron that features a single board with many features for small robots. It is an ideal low-cost starter kit.","title":"Example Kits"},{"location":"kits/01-intro/#searching-sparkfun","text":"You can also use the MicroPython \"tag\" to search all the kits on the SparkFun site: https://www.sparkfun.com/categories/tags/micropython","title":"Searching SparkFun"},{"location":"kits/01-intro/#references","text":"Here are kits that we have seen but have not yet evaluated:","title":"References"},{"location":"kits/01-intro/#waveshare-picogo-robot","text":"PicoGo Mobile Robot is a $43 robot based on Raspberry Pi Pico. SKU: 20380 Part Number: PicoGo-EN Powered by 2x 14500 Li-ion batteries. NOTE! We don't recommend these for classroom use since they are a fire hazard. Battery protection circuit: over charge/discharge protection, over current protection, short circuit protection, reverse proof, more stable and safe operating Recharge/Discharge circuit, allows programming/debugging concurrently while recharging 5-ch infrared sensor, analog output, combined with PID algorithm, stable line tracking Onboard multiple smart robot sensors like line tracking, obstacle avoidance, no more messy wiring 1.14 inch IPS colorful LCD display, 240 x135 pixels, 65K colors Integrates Bluetooth module, allows teleoperations like robot movement, RGB LED display color, buzzer, etc. by using mobile phone APP N20 micro geared motors, with metal gears, low noise, high accuracy NeoPixel Line following sensors","title":"Waveshare PicoGo Robot"},{"location":"kits/01-intro/#getting-started-kits","text":"","title":"Getting Started Kits"},{"location":"kits/01-intro/#vilros-getting-started-kit","text":"Vilros Getting Started With MicroPython on Raspberry Pi Pico Kit This kit includes: List price is $44.99 Raspberry Pi Pico with soldered headers Includes printed Vilros Get Started with MicroPython on Raspberry Pi Pico booklet USB Type-A to micro cable - 1 meter 3AA battery pack with micro USB connector 30 \u00d7 Jumper wires 12 LEDs: 3x red, 3x blue,3x yellow and 3x green 5 Push-button switches 10 330 \u03a9 resistors Piezoelectric buzzer 2 10 k\u03a9 potentiometers HC-SR501 PIR sensor I2C 1602 character LCD module WS2812B LED strip Clear hard plastic box for small part storage Neoprene case With pocket Raspberry Pi Pico pinout guide The only problem with the parts is the lack of connectors for the potentiometers don't work well directly on the breadboard. You will need to solder wires to use them on the breadboard.","title":"Vilros Getting Started Kit"},{"location":"kits/larson-scanner/01-intro/","text":"Larson Scanner Pumpkin The Larson Scanner is a light pattern special effect named after Glen A. Larson . Larson used this pattern to give his Battlestar Galactica Cylon and KITT robot eyes a sense of sentience. See Knight Rider for the backstory. This project uses a 144 pixel/meter LED strip and a Raspberry Pi Pico to produce this effect. I used a craft pumpkin from Michaels. I cut a slit in it and used hot-glue to hold the LED strip in place. Parts List 9\" Craft Pumpkin from Micheals $10 Raspberry Pi Pico ($4) Breadboard ($2) 27 pixels of WS2811B NeoPixel Strip 144 pixels per meter preferred ($8) 3 AA battery pack or a USB battery pack This is a screen image from e-bay showing a 1/2 meter of LED strip for $8. Sample Code This code shows a five-pixel wide \"eye\" moving back-an-forth over a 27 pixel strip. There is a central bright red LED surrounded by dimmer red LEDs that move back-and-forth. We are using the NeoPixel library supplied by Bla\u017e Rolih . The example below has a delay of 1/10th of a second between drawing events. You can make the delay smaller to speed up the speed of the eye movement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from utime import sleep # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 27 STATE_MACHINE = 0 LED_PIN = 0 strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # Color RGB values red = ( 255 , 0 , 0 ) red_med = ( 32 , 0 , 0 ) red_light = ( 8 , 0 , 0 ) off = ( 0 , 0 , 0 ) delay = . 1 while True : for i in range ( 2 , NUMBER_PIXELS - 2 ): strip . set_pixel ( i - 2 , red_light ) strip . set_pixel ( i - 1 , red_med ) strip . set_pixel ( i , red ) strip . set_pixel ( i + 1 , red_med ) strip . set_pixel ( i + 2 , red_light ) if i > 0 : strip . set_pixel ( i - 3 , off ) strip . show () sleep ( delay ) for i in range ( NUMBER_PIXELS - 4 , 1 , - 1 ): if i < NUMBER_PIXELS - 2 : strip . set_pixel ( i + 3 , off ) strip . set_pixel ( i - 2 , red_light ) strip . set_pixel ( i - 1 , red_med ) strip . set_pixel ( i , red ) strip . set_pixel ( i + 1 , red_med ) strip . set_pixel ( i + 2 , red_light ) strip . show () sleep ( delay ) Adding Some Color The pattern above is faithful to the original Cylon robot pattern, but to be honest, it is a little boring. We can spruce it up a bit by adding some color and the comet-tail pattern. This program cycles through a \"moving rainbow\" pattern and then the comet pattern for 10 colors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 from utime import sleep # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 25 STATE_MACHINE = 0 LED_PIN = 0 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # Color RGB values red = ( 255 , 0 , 0 ) off = ( 0 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 255 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) def draw_eye_7 ( r , g , b ): for i in range ( 6 , NUMBER_PIXELS ): strip . set_pixel ( i , ( r , g , b )) # step back from the current to 6 back halfing the intensity each time for j in range ( 0 , 7 ): strip . set_pixel ( i - j , ( int ( r / pow ( 2 , j )), int ( g / pow ( 2 , j )), int ( b / pow ( 2 , j )))) if i > 6 : strip . set_pixel ( i - 7 , ( 0 , 0 , 0 )) strip . show () sleep ( delay ) strip . set_pixel ( i , off ) for i in range ( NUMBER_PIXELS - 6 , 0 , - 1 ): strip . set_pixel ( i , ( r , g , b )) for j in range ( 7 , 0 ): strip . set_pixel ( i + j , ( int ( r / pow ( 2 , j )), int ( g / pow ( 2 , j )), int ( b / pow ( 2 , j )))) if i < NUMBER_PIXELS - 7 : strip . set_pixel ( i + 7 , ( 0 , 0 , 0 )) strip . show () sleep ( delay ) def draw_rainbow (): for i in range ( 0 , NUMBER_PIXELS - 7 ): strip . set_pixel ( i , violet ) strip . set_pixel ( i + 1 , indigo ) strip . set_pixel ( i + 2 , blue ) strip . set_pixel ( i + 3 , green ) strip . set_pixel ( i + 4 , yellow ) strip . set_pixel ( i + 5 , orange ) strip . set_pixel ( i + 6 , red ) if i > 6 : strip . set_pixel ( i - 7 , ( 0 , 0 , 0 )) strip . show () sleep ( delay ) strip . set_pixel ( i , off ) for i in range ( NUMBER_PIXELS - 7 , 1 , - 1 ): strip . set_pixel ( i , red ) strip . set_pixel ( i + 1 , orange ) strip . set_pixel ( i + 2 , yellow ) strip . set_pixel ( i + 3 , green ) strip . set_pixel ( i + 4 , blue ) strip . set_pixel ( i + 5 , indigo ) strip . set_pixel ( i + 6 , violet ) if i < NUMBER_PIXELS - 7 : strip . set_pixel ( i + 7 , ( 0 , 0 , 0 )) strip . show () sleep ( delay ) # delay = .031 delay = . 06 color_index = 0 while True : draw_rainbow () draw_eye_7 ( 255 , 0 , 0 ) #red draw_eye_7 ( 255 , 60 , 0 ) #orange draw_eye_7 ( 255 , 255 , 0 ) # yellow draw_eye_7 ( 0 , 255 , 0 ) # green draw_eye_7 ( 0 , 0 , 255 ) # b;ie draw_eye_7 ( 0 , 255 , 255 ) # cyan draw_eye_7 ( 75 , 30 , 130 ) # indigo draw_eye_7 ( 255 , 0 , 255 ) # violet draw_eye_7 ( 255 , 255 , 255 ) # white Adding the Cylon Scanner Sounds You can also add the Cylon eye scanner sound by addint a .wav file to the pico and using the playWave library. This is covered in the Sound and Music Play Audio File lesson of this microsite. More to Explore Add a potentiometer to change the speed of the eye scan. Add a button to cycle through colors of the eye. Add multiple patterns such as a \"comet trail\" that has the first pixel brighter and the following pixels dimmer. Add a PIR motion sensor that will sense motion and get brighter if motion is sensed. Use the new I2S software to play a sound when the PIR motion sensor has been triggered. Use an MP3 player such as the DRF0229 to play the cylon sound when motion is detected. Add an OLED display and buttons to the back of the pumpkin to change the parameters of the display and the sounds.","title":"Larson Scanner Pumpkin"},{"location":"kits/larson-scanner/01-intro/#larson-scanner-pumpkin","text":"The Larson Scanner is a light pattern special effect named after Glen A. Larson . Larson used this pattern to give his Battlestar Galactica Cylon and KITT robot eyes a sense of sentience. See Knight Rider for the backstory. This project uses a 144 pixel/meter LED strip and a Raspberry Pi Pico to produce this effect. I used a craft pumpkin from Michaels. I cut a slit in it and used hot-glue to hold the LED strip in place.","title":"Larson Scanner Pumpkin"},{"location":"kits/larson-scanner/01-intro/#parts-list","text":"9\" Craft Pumpkin from Micheals $10 Raspberry Pi Pico ($4) Breadboard ($2) 27 pixels of WS2811B NeoPixel Strip 144 pixels per meter preferred ($8) 3 AA battery pack or a USB battery pack This is a screen image from e-bay showing a 1/2 meter of LED strip for $8.","title":"Parts List"},{"location":"kits/larson-scanner/01-intro/#sample-code","text":"This code shows a five-pixel wide \"eye\" moving back-an-forth over a 27 pixel strip. There is a central bright red LED surrounded by dimmer red LEDs that move back-and-forth. We are using the NeoPixel library supplied by Bla\u017e Rolih . The example below has a delay of 1/10th of a second between drawing events. You can make the delay smaller to speed up the speed of the eye movement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from utime import sleep # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 27 STATE_MACHINE = 0 LED_PIN = 0 strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # Color RGB values red = ( 255 , 0 , 0 ) red_med = ( 32 , 0 , 0 ) red_light = ( 8 , 0 , 0 ) off = ( 0 , 0 , 0 ) delay = . 1 while True : for i in range ( 2 , NUMBER_PIXELS - 2 ): strip . set_pixel ( i - 2 , red_light ) strip . set_pixel ( i - 1 , red_med ) strip . set_pixel ( i , red ) strip . set_pixel ( i + 1 , red_med ) strip . set_pixel ( i + 2 , red_light ) if i > 0 : strip . set_pixel ( i - 3 , off ) strip . show () sleep ( delay ) for i in range ( NUMBER_PIXELS - 4 , 1 , - 1 ): if i < NUMBER_PIXELS - 2 : strip . set_pixel ( i + 3 , off ) strip . set_pixel ( i - 2 , red_light ) strip . set_pixel ( i - 1 , red_med ) strip . set_pixel ( i , red ) strip . set_pixel ( i + 1 , red_med ) strip . set_pixel ( i + 2 , red_light ) strip . show () sleep ( delay )","title":"Sample Code"},{"location":"kits/larson-scanner/01-intro/#adding-some-color","text":"The pattern above is faithful to the original Cylon robot pattern, but to be honest, it is a little boring. We can spruce it up a bit by adding some color and the comet-tail pattern. This program cycles through a \"moving rainbow\" pattern and then the comet pattern for 10 colors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 from utime import sleep # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 25 STATE_MACHINE = 0 LED_PIN = 0 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # Color RGB values red = ( 255 , 0 , 0 ) off = ( 0 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 255 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) def draw_eye_7 ( r , g , b ): for i in range ( 6 , NUMBER_PIXELS ): strip . set_pixel ( i , ( r , g , b )) # step back from the current to 6 back halfing the intensity each time for j in range ( 0 , 7 ): strip . set_pixel ( i - j , ( int ( r / pow ( 2 , j )), int ( g / pow ( 2 , j )), int ( b / pow ( 2 , j )))) if i > 6 : strip . set_pixel ( i - 7 , ( 0 , 0 , 0 )) strip . show () sleep ( delay ) strip . set_pixel ( i , off ) for i in range ( NUMBER_PIXELS - 6 , 0 , - 1 ): strip . set_pixel ( i , ( r , g , b )) for j in range ( 7 , 0 ): strip . set_pixel ( i + j , ( int ( r / pow ( 2 , j )), int ( g / pow ( 2 , j )), int ( b / pow ( 2 , j )))) if i < NUMBER_PIXELS - 7 : strip . set_pixel ( i + 7 , ( 0 , 0 , 0 )) strip . show () sleep ( delay ) def draw_rainbow (): for i in range ( 0 , NUMBER_PIXELS - 7 ): strip . set_pixel ( i , violet ) strip . set_pixel ( i + 1 , indigo ) strip . set_pixel ( i + 2 , blue ) strip . set_pixel ( i + 3 , green ) strip . set_pixel ( i + 4 , yellow ) strip . set_pixel ( i + 5 , orange ) strip . set_pixel ( i + 6 , red ) if i > 6 : strip . set_pixel ( i - 7 , ( 0 , 0 , 0 )) strip . show () sleep ( delay ) strip . set_pixel ( i , off ) for i in range ( NUMBER_PIXELS - 7 , 1 , - 1 ): strip . set_pixel ( i , red ) strip . set_pixel ( i + 1 , orange ) strip . set_pixel ( i + 2 , yellow ) strip . set_pixel ( i + 3 , green ) strip . set_pixel ( i + 4 , blue ) strip . set_pixel ( i + 5 , indigo ) strip . set_pixel ( i + 6 , violet ) if i < NUMBER_PIXELS - 7 : strip . set_pixel ( i + 7 , ( 0 , 0 , 0 )) strip . show () sleep ( delay ) # delay = .031 delay = . 06 color_index = 0 while True : draw_rainbow () draw_eye_7 ( 255 , 0 , 0 ) #red draw_eye_7 ( 255 , 60 , 0 ) #orange draw_eye_7 ( 255 , 255 , 0 ) # yellow draw_eye_7 ( 0 , 255 , 0 ) # green draw_eye_7 ( 0 , 0 , 255 ) # b;ie draw_eye_7 ( 0 , 255 , 255 ) # cyan draw_eye_7 ( 75 , 30 , 130 ) # indigo draw_eye_7 ( 255 , 0 , 255 ) # violet draw_eye_7 ( 255 , 255 , 255 ) # white","title":"Adding Some Color"},{"location":"kits/larson-scanner/01-intro/#adding-the-cylon-scanner-sounds","text":"You can also add the Cylon eye scanner sound by addint a .wav file to the pico and using the playWave library. This is covered in the Sound and Music Play Audio File lesson of this microsite.","title":"Adding the Cylon Scanner Sounds"},{"location":"kits/larson-scanner/01-intro/#more-to-explore","text":"Add a potentiometer to change the speed of the eye scan. Add a button to cycle through colors of the eye. Add multiple patterns such as a \"comet trail\" that has the first pixel brighter and the following pixels dimmer. Add a PIR motion sensor that will sense motion and get brighter if motion is sensed. Use the new I2S software to play a sound when the PIR motion sensor has been triggered. Use an MP3 player such as the DRF0229 to play the cylon sound when motion is detected. Add an OLED display and buttons to the back of the pumpkin to change the parameters of the display and the sounds.","title":"More to Explore"},{"location":"kits/maker-pi-pico/01-intro/","text":"Cytron Maker Pi Pico The Cytron Maker Pi Pico is a $9.99 breakout board for the Raspberry Pi Pico with many features. Speaker Stereo headphone jacks SD Card reader Sample Labs Running Lights SD Card File Reader/Writer References Cytron Maker Pi Pico Github Repo","title":"Cytron Maker Pi Pico"},{"location":"kits/maker-pi-pico/01-intro/#cytron-maker-pi-pico","text":"The Cytron Maker Pi Pico is a $9.99 breakout board for the Raspberry Pi Pico with many features. Speaker Stereo headphone jacks SD Card reader","title":"Cytron Maker Pi Pico"},{"location":"kits/maker-pi-pico/01-intro/#sample-labs","text":"Running Lights SD Card File Reader/Writer","title":"Sample Labs"},{"location":"kits/maker-pi-pico/01-intro/#references","text":"Cytron Maker Pi Pico Github Repo","title":"References"},{"location":"kits/maker-pi-pico/02-running-lights/","text":"Running lights This program turns on all 24 blue LEDs on the board, one at a time. It then turns them all off. TODO - record a GIF or video. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import machine import utime # RUNNING LIGHT for i in range ( 29 ): # from 0 to 28 if i != 23 and i != 24 : # pin 23 and 24 are not GPIO pins machine . Pin ( i , machine . Pin . OUT ) # set the pins to output while True : for i in range ( 29 ): if i != 23 and i != 24 : machine . Pin ( i ) . value ( 0 ) # turn off the LED utime . sleep ( 0.1 ) # sleep for 100ms machine . Pin ( i ) . value ( 1 ) # turn on the LED for i in range ( 28 , - 1 , - 1 ): # from 28 to 0 if i != 23 and i != 24 : machine . Pin ( i ) . value ( 1 ) # turn on the LED utime . sleep ( 0.1 ) machine . Pin ( i ) . value ( 0 ) # turn off the LED References This program was taken from tje Cytron GitHub site here .","title":"Running lights"},{"location":"kits/maker-pi-pico/02-running-lights/#running-lights","text":"This program turns on all 24 blue LEDs on the board, one at a time. It then turns them all off. TODO - record a GIF or video. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import machine import utime # RUNNING LIGHT for i in range ( 29 ): # from 0 to 28 if i != 23 and i != 24 : # pin 23 and 24 are not GPIO pins machine . Pin ( i , machine . Pin . OUT ) # set the pins to output while True : for i in range ( 29 ): if i != 23 and i != 24 : machine . Pin ( i ) . value ( 0 ) # turn off the LED utime . sleep ( 0.1 ) # sleep for 100ms machine . Pin ( i ) . value ( 1 ) # turn on the LED for i in range ( 28 , - 1 , - 1 ): # from 28 to 0 if i != 23 and i != 24 : machine . Pin ( i ) . value ( 1 ) # turn on the LED utime . sleep ( 0.1 ) machine . Pin ( i ) . value ( 0 ) # turn off the LED","title":"Running lights"},{"location":"kits/maker-pi-pico/02-running-lights/#references","text":"This program was taken from tje Cytron GitHub site here .","title":"References"},{"location":"kits/maker-pi-pico/09-micro-sd-card-reader/","text":"Micro SD Card Reader Secure Digital (SD) is a non-volatile memory card format for use in portable devices such as cameras, MP3 players and portable devices. On Microcontrollers SD cards are usually access through an SPI interface although there are also devices that use I2C interfaces. Maker Pi Pico Connections GPIO Pin SD Mode SPI Mode GP10 CLK SCK GP11 CMD SDI GP12 DAT0 SD0 GP13 DAT1 X GP14 DAT2 X GP15 CD/DAT3 CSn Maker Pi Pico Example Code Pin Definitions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # SD Mode Definitions SDCARD_CLK = 10 SDCARD_CMD = 11 SDCARD_DAT0 = 12 SDCARD_DAT1 = 13 SDCARD_DAT2 = 14 SDCARD_CD_DAT3 = 15 # SPI Mode Definitions SDCARD_SCK = 10 SDCARD_SDI = 11 SDCARD_SD0 = 12 SDCARD_X1 = 13 SDCARD_X2 = 14 SDCARD_CSn = 15 Sample Code for SPI Mode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import machine , os , sdcard # Assign chip select (CS) pin (and start it high) cs = machine . Pin ( 15 , machine . Pin . OUT ) # Intialize SPI peripheral (start with 1 MHz) spi = machine . SPI ( 1 , baudrate = 1000000 , polarity = 0 , phase = 0 , bits = 8 , firstbit = machine . SPI . MSB , sck = machine . Pin ( 10 ), mosi = machine . Pin ( 11 ), miso = machine . Pin ( 12 )) # Initialize SD card sd = sdcard . SDCard ( spi , cs ) # OR this simpler initialization code should works on Maker Pi Pico too... #sd = sdcard.SDCard(machine.SPI(1), machine.Pin(15)) os . mount ( sd , '/sd' ) # check the content os . listdir ( '/sd' ) # try some standard file operations file = open ( '/sd/test.txt' , 'w' ) file . write ( 'Testing SD card on Maker Pi Pico' ) file . close () file = open ( '/sd/test.txt' , 'r' ) data = file . read () print ( data ) file . close () Results: 1 Testing SD card on Maker Pi Pico References MicroPython sdcard.py driver - note there is no documentation on use with the RP2040 although there is example code for the pyboard and the ESP8266 MicroPython.org Documentation Raspberry Pi Pico Forum YouTube Video by Shawn Hymel Cytron Maker Pi Pico Datasheet","title":"Micro SD Card Reader"},{"location":"kits/maker-pi-pico/09-micro-sd-card-reader/#micro-sd-card-reader","text":"Secure Digital (SD) is a non-volatile memory card format for use in portable devices such as cameras, MP3 players and portable devices. On Microcontrollers SD cards are usually access through an SPI interface although there are also devices that use I2C interfaces.","title":"Micro SD Card Reader"},{"location":"kits/maker-pi-pico/09-micro-sd-card-reader/#maker-pi-pico-connections","text":"GPIO Pin SD Mode SPI Mode GP10 CLK SCK GP11 CMD SDI GP12 DAT0 SD0 GP13 DAT1 X GP14 DAT2 X GP15 CD/DAT3 CSn","title":"Maker Pi Pico Connections"},{"location":"kits/maker-pi-pico/09-micro-sd-card-reader/#maker-pi-pico-example-code","text":"","title":"Maker Pi Pico Example Code"},{"location":"kits/maker-pi-pico/09-micro-sd-card-reader/#pin-definitions","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # SD Mode Definitions SDCARD_CLK = 10 SDCARD_CMD = 11 SDCARD_DAT0 = 12 SDCARD_DAT1 = 13 SDCARD_DAT2 = 14 SDCARD_CD_DAT3 = 15 # SPI Mode Definitions SDCARD_SCK = 10 SDCARD_SDI = 11 SDCARD_SD0 = 12 SDCARD_X1 = 13 SDCARD_X2 = 14 SDCARD_CSn = 15","title":"Pin Definitions"},{"location":"kits/maker-pi-pico/09-micro-sd-card-reader/#sample-code-for-spi-mode","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import machine , os , sdcard # Assign chip select (CS) pin (and start it high) cs = machine . Pin ( 15 , machine . Pin . OUT ) # Intialize SPI peripheral (start with 1 MHz) spi = machine . SPI ( 1 , baudrate = 1000000 , polarity = 0 , phase = 0 , bits = 8 , firstbit = machine . SPI . MSB , sck = machine . Pin ( 10 ), mosi = machine . Pin ( 11 ), miso = machine . Pin ( 12 )) # Initialize SD card sd = sdcard . SDCard ( spi , cs ) # OR this simpler initialization code should works on Maker Pi Pico too... #sd = sdcard.SDCard(machine.SPI(1), machine.Pin(15)) os . mount ( sd , '/sd' ) # check the content os . listdir ( '/sd' ) # try some standard file operations file = open ( '/sd/test.txt' , 'w' ) file . write ( 'Testing SD card on Maker Pi Pico' ) file . close () file = open ( '/sd/test.txt' , 'r' ) data = file . read () print ( data ) file . close () Results: 1 Testing SD card on Maker Pi Pico","title":"Sample Code for SPI Mode"},{"location":"kits/maker-pi-pico/09-micro-sd-card-reader/#references","text":"MicroPython sdcard.py driver - note there is no documentation on use with the RP2040 although there is example code for the pyboard and the ESP8266 MicroPython.org Documentation Raspberry Pi Pico Forum YouTube Video by Shawn Hymel Cytron Maker Pi Pico Datasheet","title":"References"},{"location":"kits/maker-pi-rp2040/01-getting-started/","text":"Getting Started Install the MicroPython Runtime Library The Maker Pi RP2040 comes with an incompatible CircuitPython run-time. Our first step is to re-initialize the board with the Raspberry Pi flash_nuke.uf2 runtime. We can then load the latest MicroPython libraries. When we wrote these labs we were using MicroPython version 1.7 that was released in September of 2021. To install MicroPython you mush hold down the BOTSEL button on the main board while you turn on the board using the on-board power switch. This will make the board look like a USB drive. You can then just drag the flash-nuke file onto the drive and the board will be initialized. Make sure to power the board off and back on. You can now repeat this process with the Raspberry Pi MicroPython Runtime . Just remember to press and hold down the BOTSEL before you turn on the board and reboot after the image has been copied to the microcontroller. If you have never used MicroPython, the Raspberry Pi Foundation has a nice Getting Started Guide that can be helpful. Get Familiar with your IDE (Thonney) and the Basic Programs There are many Integrated Development Environments (IDEs) that work with the Raspberry Pi RP2040 chip. The one you chose just should support MicroPython and be able to upload and run new programs. Once you turn on the board you should be able to configure Thonny to use the Raspberry Pi MicroPython interface. When you press the Stop/Reset button you should see the MicroPython RPEL prompt. Test the Motor Connections Use the Motor Connection Lab Getting Help MicroPython on the RP2040 is the most powerful low-cost system on the market today. With 264K of RAM, it will take a LOT of work to run out of memory. But with all things new, there is a lock of good documentation, drivers and sample code. To help you along, we suggest the following resources: The MicroPython Raspsberry Pi Forum . Be sure use the search to check for prior questions.","title":"Getting Started"},{"location":"kits/maker-pi-rp2040/01-getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"kits/maker-pi-rp2040/01-getting-started/#install-the-micropython-runtime-library","text":"The Maker Pi RP2040 comes with an incompatible CircuitPython run-time. Our first step is to re-initialize the board with the Raspberry Pi flash_nuke.uf2 runtime. We can then load the latest MicroPython libraries. When we wrote these labs we were using MicroPython version 1.7 that was released in September of 2021. To install MicroPython you mush hold down the BOTSEL button on the main board while you turn on the board using the on-board power switch. This will make the board look like a USB drive. You can then just drag the flash-nuke file onto the drive and the board will be initialized. Make sure to power the board off and back on. You can now repeat this process with the Raspberry Pi MicroPython Runtime . Just remember to press and hold down the BOTSEL before you turn on the board and reboot after the image has been copied to the microcontroller. If you have never used MicroPython, the Raspberry Pi Foundation has a nice Getting Started Guide that can be helpful.","title":"Install the MicroPython Runtime Library"},{"location":"kits/maker-pi-rp2040/01-getting-started/#get-familiar-with-your-ide-thonney-and-the-basic-programs","text":"There are many Integrated Development Environments (IDEs) that work with the Raspberry Pi RP2040 chip. The one you chose just should support MicroPython and be able to upload and run new programs. Once you turn on the board you should be able to configure Thonny to use the Raspberry Pi MicroPython interface. When you press the Stop/Reset button you should see the MicroPython RPEL prompt.","title":"Get Familiar with your IDE (Thonney) and the Basic Programs"},{"location":"kits/maker-pi-rp2040/01-getting-started/#_1","text":"","title":""},{"location":"kits/maker-pi-rp2040/01-getting-started/#test-the-motor-connections","text":"Use the Motor Connection Lab","title":"Test the Motor Connections"},{"location":"kits/maker-pi-rp2040/01-getting-started/#getting-help","text":"MicroPython on the RP2040 is the most powerful low-cost system on the market today. With 264K of RAM, it will take a LOT of work to run out of memory. But with all things new, there is a lock of good documentation, drivers and sample code. To help you along, we suggest the following resources: The MicroPython Raspsberry Pi Forum . Be sure use the search to check for prior questions.","title":"Getting Help"},{"location":"kits/maker-pi-rp2040/01-intro/","text":"Maker Pi RP2040 MicroPython Robotics Kit The Maker Pi PR2040 kit from Cytron Technologies is a $9.90 US kit that is designed to simplify learning robotics using the RP2040 chip. It became available in April of 2021, but demand has been very high and it is out-of-stock on many retailers sites. We can understand this. The Maker Pi PR2040 is the most powerful robotics board we have ever seen for under $10! The photo above is our base robot kit. It includes the Maker Pi RP2040 board mounted on a standards Smart Car chassis. The image above shows the Time-of-flight distance sensor mounted in the front below the chassis. Note that the batteries are mounted on the bottom of the robot. Below is the top view of the Cytron Maker Pi RP2040 robotics board. Features All our robots are built around a RP2040 and a motor driver with a few low-cost sensors and displays. With the exception of the OLED display, this board packs in a huge number of features for a low cost of $9.90. Power status LED (green) On/off switch 13 blue LEDs to show status on GP pins 0,1,2,3,4,5,6,16,17,26,27 and 28 2 WS2812B RGB LEDs connected to GP18 LiPo Battery Connector Micro USB Port (use for powering and programming) Reset button Boot button Momentary press buttons on ports GP20 and GP21 2 Motor drivers. Motor A is controlled by GP8 and GP10 and motor B is controlled by GP9 and GP11. 4 motor test buttons for testing motors A and B, forward and backward 4 red motor status LEDs buttons for displaying motors A and B, forward and backward 7 Grove Ports on GPs 1:0,1; 2:2,3; 3:4,5; 4:16,17; 5:6,26; 6:26,27 and 7:7,28 4 servo connectors on ports GP12, GP13, GP14 and GP15 Piezzo buzzer on port GP22 On/Off switch on GP22 which can be used to mute the sound Phillps head screwdriver that works on the header pins - really convenient for students! 4 Grove Connectors Rubber mounting feet Pins numbers clearly labeled both on top and bottom of the board Large area on bottom of the board for students to write their name List of Labs Part 1: No Accessories Required Labs These labs don't need anything except the Maker Pi RP2040 board. Blue LED Lab - make the blue GPIO status LEDs show cool patterns NeoPixel Lab - make the two NeoPixel each display many colors Button Lab - make the two buttons change the state of system Sound Lab - make the Piezoelectric Buzzer create sounds Up Down Mode Lab - make the buttons change the LEDs, NeoPixels and Sound Part 2: Motor and Servo Labs These labs require additional parts such as DC hobby motors and servos Motor Connection Lab - make two motors turn forward and in reverse Up/Down Motor Speed Lab - change the speed as you change the mode Servo Lab - control the direction of a 108% servo motor. Calibrate the end angles and sweep the direction back and forth. Part 3: Sensor Labs There are literally hundreds of sensors that have Grove connectors on them. In addition, we can purchase Grove connectors for as low as 30 cents each . Any other sensors with male pins can be easily connected with these 38 cent connectors with female Dupont jumper connectors . Classrooms with a large collection of these sensors can allow students to try new sensors and outputs without needing a breadboard or soldering. We will focus initially on two sensors we will use for our collision avoidance robot. We prefer the Time-of-Flight sensor because it uses a standard I2C interface and thus could share the I2C bus with other devices. Time of Flight Distance Sensor Lab - measure the distance to an object Ultrasonic Ping Distance Sensor - the classic low-cost ultrasonic distance sensor but now it works on a 3.3 volt power! (TBD) Time of Flight Sound Lab - sound pitch changes with distance Part 4: Collision Avoidance Robot Collision Avoidance Robot - this lab joins our motor and sensor labs with a SmartCar chassis to create a robot that avoids collisions. Collision Robot with Modes - TBD Adjustable Collision Avoidance - the adjusta bot! TBD Adding a display Basis for a Low-Cost Robot Kit When this kit is combined with a standard 2 Wheel Drive Smart Car Chassis and a distance sensor it becomes a great low-cost way of getting started with Python and robots. Clearly Labeled Pin Numbers One of the biggest disadvantages of the Raspberry Pi Pico is the fact that pin labels are NOT visible when it is mounted on a breadboard. We have to take the Pico out of the breadboard to read the pin numbers on the bottom of the board. A much better design would be to follow the best practices and put the labels on the top of the board where they are visible. This is clearly done on the Maker Pi RP2040 board! Note the pin labels, GND, 3.3V, GP0 and GP1 are clearly printed on the top of the board. Note the circuit in the upper right corner displays how you can use the analog input port to read the battery level of the robot. Removing the Default CircuitPython Cytron Technologies has a wonderful YouTube videos on how to program the Maker Pi RP2040 using MicroPython. Unfortunately, this board does NOT come with our standard MicroPython loaded! :-O It uses the non-standard Adafruit CircuitPython that is incompatible with most MicroPython programs being used today. This is a sad state of affairs that confuses our students and makes it difficult to share code and libraries for MicroPython. According to Google trends, over the last 12 months for worldwide searches, MicroPython has almost five time the interest of CircuitPython . Preloading the board with CircuitPython sends a very confusing message to the marketplace. Flash Nuke I want to make sure that my RP2040 was starting out with a clean image. I downloaded the flash_nuke.uf2 file to remove the default CircuitPython runtime and all the related files. Note that the board must be fully powered down after this load for it to work. I had 4 AA batteries connected to the VIN screw headers, so it was not resetting correctly and the reset was not working until I disconnected the batteries. The latests MicroPython runtimes are here Easy Motor Testing Buttons One of the things I love about this board is how incredibly easy it is for students to test their motors. The board provides four very convenient motor test buttons right on the board. By pressing each one you can make both motors go forward and backwards. This is a great way for students to learn about how we can generate PWM signals to simulate these four buttons. Whoever design this board clearly had their students in mind! References Link on Box GitHub Link Cytron Maker Pi RP2040 Product Page Cytron Maker Pi RP2040 Datasheet on Google Docs Digi-Key Cytron Maker Pi RP2040 reseller Amazon Listing - no availability as of Aug. 15th 2021 Adafruit Cytron Maker Pi RP2040 reseller - out of stock as of Aug. 15th 2021 1300 mah battery Ultrasonic Sensor Video on YouTube","title":"Introduction"},{"location":"kits/maker-pi-rp2040/01-intro/#maker-pi-rp2040-micropython-robotics-kit","text":"The Maker Pi PR2040 kit from Cytron Technologies is a $9.90 US kit that is designed to simplify learning robotics using the RP2040 chip. It became available in April of 2021, but demand has been very high and it is out-of-stock on many retailers sites. We can understand this. The Maker Pi PR2040 is the most powerful robotics board we have ever seen for under $10! The photo above is our base robot kit. It includes the Maker Pi RP2040 board mounted on a standards Smart Car chassis. The image above shows the Time-of-flight distance sensor mounted in the front below the chassis. Note that the batteries are mounted on the bottom of the robot. Below is the top view of the Cytron Maker Pi RP2040 robotics board.","title":"Maker Pi RP2040 MicroPython Robotics Kit"},{"location":"kits/maker-pi-rp2040/01-intro/#features","text":"All our robots are built around a RP2040 and a motor driver with a few low-cost sensors and displays. With the exception of the OLED display, this board packs in a huge number of features for a low cost of $9.90. Power status LED (green) On/off switch 13 blue LEDs to show status on GP pins 0,1,2,3,4,5,6,16,17,26,27 and 28 2 WS2812B RGB LEDs connected to GP18 LiPo Battery Connector Micro USB Port (use for powering and programming) Reset button Boot button Momentary press buttons on ports GP20 and GP21 2 Motor drivers. Motor A is controlled by GP8 and GP10 and motor B is controlled by GP9 and GP11. 4 motor test buttons for testing motors A and B, forward and backward 4 red motor status LEDs buttons for displaying motors A and B, forward and backward 7 Grove Ports on GPs 1:0,1; 2:2,3; 3:4,5; 4:16,17; 5:6,26; 6:26,27 and 7:7,28 4 servo connectors on ports GP12, GP13, GP14 and GP15 Piezzo buzzer on port GP22 On/Off switch on GP22 which can be used to mute the sound Phillps head screwdriver that works on the header pins - really convenient for students! 4 Grove Connectors Rubber mounting feet Pins numbers clearly labeled both on top and bottom of the board Large area on bottom of the board for students to write their name","title":"Features"},{"location":"kits/maker-pi-rp2040/01-intro/#list-of-labs","text":"","title":"List of Labs"},{"location":"kits/maker-pi-rp2040/01-intro/#part-1-no-accessories-required-labs","text":"These labs don't need anything except the Maker Pi RP2040 board. Blue LED Lab - make the blue GPIO status LEDs show cool patterns NeoPixel Lab - make the two NeoPixel each display many colors Button Lab - make the two buttons change the state of system Sound Lab - make the Piezoelectric Buzzer create sounds Up Down Mode Lab - make the buttons change the LEDs, NeoPixels and Sound","title":"Part 1: No Accessories Required Labs"},{"location":"kits/maker-pi-rp2040/01-intro/#part-2-motor-and-servo-labs","text":"These labs require additional parts such as DC hobby motors and servos Motor Connection Lab - make two motors turn forward and in reverse Up/Down Motor Speed Lab - change the speed as you change the mode Servo Lab - control the direction of a 108% servo motor. Calibrate the end angles and sweep the direction back and forth.","title":"Part 2: Motor and Servo Labs"},{"location":"kits/maker-pi-rp2040/01-intro/#part-3-sensor-labs","text":"There are literally hundreds of sensors that have Grove connectors on them. In addition, we can purchase Grove connectors for as low as 30 cents each . Any other sensors with male pins can be easily connected with these 38 cent connectors with female Dupont jumper connectors . Classrooms with a large collection of these sensors can allow students to try new sensors and outputs without needing a breadboard or soldering. We will focus initially on two sensors we will use for our collision avoidance robot. We prefer the Time-of-Flight sensor because it uses a standard I2C interface and thus could share the I2C bus with other devices. Time of Flight Distance Sensor Lab - measure the distance to an object Ultrasonic Ping Distance Sensor - the classic low-cost ultrasonic distance sensor but now it works on a 3.3 volt power! (TBD) Time of Flight Sound Lab - sound pitch changes with distance","title":"Part 3: Sensor Labs"},{"location":"kits/maker-pi-rp2040/01-intro/#part-4-collision-avoidance-robot","text":"Collision Avoidance Robot - this lab joins our motor and sensor labs with a SmartCar chassis to create a robot that avoids collisions. Collision Robot with Modes - TBD Adjustable Collision Avoidance - the adjusta bot! TBD Adding a display","title":"Part 4: Collision Avoidance Robot"},{"location":"kits/maker-pi-rp2040/01-intro/#basis-for-a-low-cost-robot-kit","text":"When this kit is combined with a standard 2 Wheel Drive Smart Car Chassis and a distance sensor it becomes a great low-cost way of getting started with Python and robots.","title":"Basis for a Low-Cost Robot Kit"},{"location":"kits/maker-pi-rp2040/01-intro/#clearly-labeled-pin-numbers","text":"One of the biggest disadvantages of the Raspberry Pi Pico is the fact that pin labels are NOT visible when it is mounted on a breadboard. We have to take the Pico out of the breadboard to read the pin numbers on the bottom of the board. A much better design would be to follow the best practices and put the labels on the top of the board where they are visible. This is clearly done on the Maker Pi RP2040 board! Note the pin labels, GND, 3.3V, GP0 and GP1 are clearly printed on the top of the board. Note the circuit in the upper right corner displays how you can use the analog input port to read the battery level of the robot.","title":"Clearly Labeled Pin Numbers"},{"location":"kits/maker-pi-rp2040/01-intro/#removing-the-default-circuitpython","text":"Cytron Technologies has a wonderful YouTube videos on how to program the Maker Pi RP2040 using MicroPython. Unfortunately, this board does NOT come with our standard MicroPython loaded! :-O It uses the non-standard Adafruit CircuitPython that is incompatible with most MicroPython programs being used today. This is a sad state of affairs that confuses our students and makes it difficult to share code and libraries for MicroPython. According to Google trends, over the last 12 months for worldwide searches, MicroPython has almost five time the interest of CircuitPython . Preloading the board with CircuitPython sends a very confusing message to the marketplace.","title":"Removing the Default CircuitPython"},{"location":"kits/maker-pi-rp2040/01-intro/#flash-nuke","text":"I want to make sure that my RP2040 was starting out with a clean image. I downloaded the flash_nuke.uf2 file to remove the default CircuitPython runtime and all the related files. Note that the board must be fully powered down after this load for it to work. I had 4 AA batteries connected to the VIN screw headers, so it was not resetting correctly and the reset was not working until I disconnected the batteries. The latests MicroPython runtimes are here","title":"Flash Nuke"},{"location":"kits/maker-pi-rp2040/01-intro/#easy-motor-testing-buttons","text":"One of the things I love about this board is how incredibly easy it is for students to test their motors. The board provides four very convenient motor test buttons right on the board. By pressing each one you can make both motors go forward and backwards. This is a great way for students to learn about how we can generate PWM signals to simulate these four buttons. Whoever design this board clearly had their students in mind!","title":"Easy Motor Testing Buttons"},{"location":"kits/maker-pi-rp2040/01-intro/#references","text":"Link on Box GitHub Link Cytron Maker Pi RP2040 Product Page Cytron Maker Pi RP2040 Datasheet on Google Docs Digi-Key Cytron Maker Pi RP2040 reseller Amazon Listing - no availability as of Aug. 15th 2021 Adafruit Cytron Maker Pi RP2040 reseller - out of stock as of Aug. 15th 2021 1300 mah battery Ultrasonic Sensor Video on YouTube","title":"References"},{"location":"kits/maker-pi-rp2040/02-blue-led-lab/","text":"Blue LED Lab Once you have the MicroPython runtime installed and your IDE setup, this board is easy to program! Let's take a look at the classic \"Blink\" program that turns a single LED on and off every second. Blink First Blue LED The Maker Pi RP2040 has a row of 13 small blue LEDs that monitor the digital input/output of 13 of the GPIO signals. If you set any of the output pins to be HIGH, the LED will be on. If you set the pin to be LOW, the blue LED will be off. These LEDs make it easy for you to view the state of your GPIO pins and can help debugging your programs. Just remember that if you are using the pins for communication, you can't use the LEDs for other purposes. Here is a small program that will blink the first blue LED: 1 2 3 4 5 6 7 8 import machine import time # setup the first LED as an output signal first_led = machine . Pin ( 0 , machine . Pin . OUT ) while True : first_led . toggle () time . sleep ( 1 ) Note that the first four lines are the \"setup\" of the program. These lines will only run once when the program starts. The code indented after the while True: line will continue to run until the device is reset or powered down. Running Lights on All LEDs Here is a demo using the 13 nice blue LEDs used to show the status of the pins. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import machine import time # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs blue_led_pins = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] number_leds = len ( blue_led_pins ) led_ports = [] delay = . 05 # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # loop forever while True : # blue up for i in range ( 0 , number_leds ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () This demo uses a list of all the 13 digital I/O ports. For each port it sets the port to be a digital output. In the main loop it then goes up and down the strip of LEDs, turning each one on for 1/20th of a second (.05 seconds).","title":"Blue LED Lab"},{"location":"kits/maker-pi-rp2040/02-blue-led-lab/#blue-led-lab","text":"Once you have the MicroPython runtime installed and your IDE setup, this board is easy to program! Let's take a look at the classic \"Blink\" program that turns a single LED on and off every second.","title":"Blue LED Lab"},{"location":"kits/maker-pi-rp2040/02-blue-led-lab/#blink-first-blue-led","text":"The Maker Pi RP2040 has a row of 13 small blue LEDs that monitor the digital input/output of 13 of the GPIO signals. If you set any of the output pins to be HIGH, the LED will be on. If you set the pin to be LOW, the blue LED will be off. These LEDs make it easy for you to view the state of your GPIO pins and can help debugging your programs. Just remember that if you are using the pins for communication, you can't use the LEDs for other purposes. Here is a small program that will blink the first blue LED: 1 2 3 4 5 6 7 8 import machine import time # setup the first LED as an output signal first_led = machine . Pin ( 0 , machine . Pin . OUT ) while True : first_led . toggle () time . sleep ( 1 ) Note that the first four lines are the \"setup\" of the program. These lines will only run once when the program starts. The code indented after the while True: line will continue to run until the device is reset or powered down.","title":"Blink First Blue LED"},{"location":"kits/maker-pi-rp2040/02-blue-led-lab/#running-lights-on-all-leds","text":"Here is a demo using the 13 nice blue LEDs used to show the status of the pins. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import machine import time # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs blue_led_pins = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] number_leds = len ( blue_led_pins ) led_ports = [] delay = . 05 # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # loop forever while True : # blue up for i in range ( 0 , number_leds ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () This demo uses a list of all the 13 digital I/O ports. For each port it sets the port to be a digital output. In the main loop it then goes up and down the strip of LEDs, turning each one on for 1/20th of a second (.05 seconds).","title":"Running Lights on All LEDs"},{"location":"kits/maker-pi-rp2040/03-neopixel-lab/","text":"NeoPixel Demo Lab The Maker Pi RP2040 comes with two built-in NeoPixels. Each NeoPixel has a red, green and blue LED inside it. Each of these LEDs can be set to any one of 256 values from 0 (off) to 255 (brightest value). NeoPixel Setup 1 2 3 4 5 6 7 8 from neopixel import Neopixel NUMBER_PIXELS = 2 STATE_MACHINE = 0 LED_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) NeoPixel Blink Lab In this lab, we will turn the first NeoPixel element on red for 1/2 second and then turn it off for 1/2 second. We repeat this until the program is terminated. Setting up the NeoPixel Library We will be calling a NeoPixel driver in the /lib directory. We initiaze our NeoPixel strip by calling the init method all Neopixel() and pass it three parameters: The number of pixels in the strip (in our case there are just two) The state machine (in our case 0) The LED PIN (in our case this is GP18) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from utime import sleep # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 2 STATE_MACHINE = 0 LED_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) while True : # turn on first pixel red for 1/2 second strip . set_pixel ( 0 , ( 255 , 0 , 0 )) strip . show () sleep ( . 5 ) strip . set_pixel ( 0 , ( 0 , 0 , 0 )) # turn all colors off strip . show () sleep ( . 5 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import time # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 2 STATE_MACHINE = 0 LED_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) color_index = 0 while True : for color in colors : for i in range ( NUMBER_PIXELS ): print ( i , color_names [ color_index ]) strip . set_pixel ( i , color ) strip . show () time . sleep ( 1 ) color_index += 1 if color_index >= num_colors : color_index = 0","title":"NeoPixel Lab"},{"location":"kits/maker-pi-rp2040/03-neopixel-lab/#neopixel-demo-lab","text":"The Maker Pi RP2040 comes with two built-in NeoPixels. Each NeoPixel has a red, green and blue LED inside it. Each of these LEDs can be set to any one of 256 values from 0 (off) to 255 (brightest value).","title":"NeoPixel Demo Lab"},{"location":"kits/maker-pi-rp2040/03-neopixel-lab/#neopixel-setup","text":"1 2 3 4 5 6 7 8 from neopixel import Neopixel NUMBER_PIXELS = 2 STATE_MACHINE = 0 LED_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" )","title":"NeoPixel Setup"},{"location":"kits/maker-pi-rp2040/03-neopixel-lab/#neopixel-blink-lab","text":"In this lab, we will turn the first NeoPixel element on red for 1/2 second and then turn it off for 1/2 second. We repeat this until the program is terminated.","title":"NeoPixel Blink Lab"},{"location":"kits/maker-pi-rp2040/03-neopixel-lab/#setting-up-the-neopixel-library","text":"We will be calling a NeoPixel driver in the /lib directory. We initiaze our NeoPixel strip by calling the init method all Neopixel() and pass it three parameters: The number of pixels in the strip (in our case there are just two) The state machine (in our case 0) The LED PIN (in our case this is GP18) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from utime import sleep # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 2 STATE_MACHINE = 0 LED_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) while True : # turn on first pixel red for 1/2 second strip . set_pixel ( 0 , ( 255 , 0 , 0 )) strip . show () sleep ( . 5 ) strip . set_pixel ( 0 , ( 0 , 0 , 0 )) # turn all colors off strip . show () sleep ( . 5 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import time # We are using https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel NUMBER_PIXELS = 2 STATE_MACHINE = 0 LED_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet ) # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) color_index = 0 while True : for color in colors : for i in range ( NUMBER_PIXELS ): print ( i , color_names [ color_index ]) strip . set_pixel ( i , color ) strip . show () time . sleep ( 1 ) color_index += 1 if color_index >= num_colors : color_index = 0","title":"Setting up the NeoPixel Library"},{"location":"kits/maker-pi-rp2040/04-button-lab/","text":"Two Button Press We learned how to write code to monitor a button press in the Button Lab . Recall we talked about how to remove the \"debounce noise\" when a button is pressed by adding a timer to make sure we had a clean transition (debouncing the switch): We did this by waiting for the transition to settle down to its new state. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import utime from machine import Pin # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler button_presses = 0 # the count of times the button has been pressed last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # The lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail faster_pin = machine . Pin ( 20 , machine . Pin . IN , machine . Pin . PULL_DOWN ) slower_pin = machine . Pin ( 21 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global button_presses , last_time new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): button_presses += 1 else : button_presses -= 1 last_time = new_time # now we register the handler function when the button is pressed faster_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) slower_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # This is for only printing when a new button press count value happens old_presses = 0 while True : # only print on change in the button_presses value if button_presses != old_presses : print ( button_presses ) builtin_led . toggle () old_presses = button_presses Making the Buttons Change the NeoPixel Color In this lab, we will combine the button press lab with our NeoPixel lab to allow you to change the NeoPixel colors if a button on the board is pressed. Each button will control the color of one of the pixels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 # press buttons to change the color of the NeoPixels import utime from machine import Pin from neopixel import Neopixel NUMBER_PIXELS = 2 STATE_MACHINE = 0 LED_PIN = 18 BUTTON_A_PIN = 20 BUTTON_B_PIN = 21 # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 125 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink white = ( 255 , 255 , 255 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'cyan' , 'indigo' , 'violet' , 'white' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) # color index into colors list neopixel_a = 0 neopixel_b = 0 # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) button_presses = 0 # the count of times the button has been pressed last_time = 0 # the last time we pressed the button # The lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail button_a = machine . Pin ( BUTTON_A_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_b = machine . Pin ( BUTTON_B_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global button_presses , last_time , num_colors , neopixel_a , neopixel_b new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work button_presses += 1 if '20' in str ( pin ): neopixel_a += 1 if neopixel_a > num_colors - 1 : neopixel_a = 0 else : neopixel_b += 1 if neopixel_b > num_colors - 1 : neopixel_b = 0 last_time = new_time # now we register the handler function when the button is pressed button_a . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) button_b . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # This is for only printing when a new button press count value happens old_presses = 0 print ( 'Running NeoPixel Button Lab' ) strip . set_pixel ( 0 , ( 4 , 5 , 5 )) strip . set_pixel ( 1 , ( 4 , 5 , 5 )) strip . show () def main (): global button_presses , old_presses , colors , neopixel_a , neopixel_b while True : # only print on change in the button_presses value if button_presses != old_presses : print ( button_presses ) print ( 'NeoPixel A:' , color_names [ neopixel_a ], 'index:' , neopixel_a ) print ( 'NeoPixel B:' , color_names [ neopixel_b ], 'index:' , neopixel_b ) strip . set_pixel ( 0 , colors [ neopixel_a ]) strip . set_pixel ( 1 , colors [ neopixel_b ]) strip . show () old_presses = button_presses try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Cleanup code print ( 'Turning off NeoPixels' ) strip . set_pixel ( 0 , ( 0 , 0 , 0 )) strip . set_pixel ( 1 , ( 0 , 0 , 0 )) strip . show ()","title":"Button Lab"},{"location":"kits/maker-pi-rp2040/04-button-lab/#two-button-press","text":"We learned how to write code to monitor a button press in the Button Lab . Recall we talked about how to remove the \"debounce noise\" when a button is pressed by adding a timer to make sure we had a clean transition (debouncing the switch): We did this by waiting for the transition to settle down to its new state. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import utime from machine import Pin # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler button_presses = 0 # the count of times the button has been pressed last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # The lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail faster_pin = machine . Pin ( 20 , machine . Pin . IN , machine . Pin . PULL_DOWN ) slower_pin = machine . Pin ( 21 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global button_presses , last_time new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): button_presses += 1 else : button_presses -= 1 last_time = new_time # now we register the handler function when the button is pressed faster_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) slower_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # This is for only printing when a new button press count value happens old_presses = 0 while True : # only print on change in the button_presses value if button_presses != old_presses : print ( button_presses ) builtin_led . toggle () old_presses = button_presses","title":"Two Button Press"},{"location":"kits/maker-pi-rp2040/04-button-lab/#making-the-buttons-change-the-neopixel-color","text":"In this lab, we will combine the button press lab with our NeoPixel lab to allow you to change the NeoPixel colors if a button on the board is pressed. Each button will control the color of one of the pixels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 # press buttons to change the color of the NeoPixels import utime from machine import Pin from neopixel import Neopixel NUMBER_PIXELS = 2 STATE_MACHINE = 0 LED_PIN = 18 BUTTON_A_PIN = 20 BUTTON_B_PIN = 21 # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , LED_PIN , \"GRB\" ) # Color RGB values red = ( 255 , 0 , 0 ) orange = ( 125 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) cyan = ( 0 , 255 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink white = ( 255 , 255 , 255 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'cyan' , 'indigo' , 'violet' , 'white' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , cyan , indigo , violet , white ) # color index into colors list neopixel_a = 0 neopixel_b = 0 # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) button_presses = 0 # the count of times the button has been pressed last_time = 0 # the last time we pressed the button # The lower left corner of the Pico has a wire that goes through the buttons upper left and the lower right goes to the 3.3 rail button_a = machine . Pin ( BUTTON_A_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_b = machine . Pin ( BUTTON_B_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global button_presses , last_time , num_colors , neopixel_a , neopixel_b new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work button_presses += 1 if '20' in str ( pin ): neopixel_a += 1 if neopixel_a > num_colors - 1 : neopixel_a = 0 else : neopixel_b += 1 if neopixel_b > num_colors - 1 : neopixel_b = 0 last_time = new_time # now we register the handler function when the button is pressed button_a . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) button_b . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # This is for only printing when a new button press count value happens old_presses = 0 print ( 'Running NeoPixel Button Lab' ) strip . set_pixel ( 0 , ( 4 , 5 , 5 )) strip . set_pixel ( 1 , ( 4 , 5 , 5 )) strip . show () def main (): global button_presses , old_presses , colors , neopixel_a , neopixel_b while True : # only print on change in the button_presses value if button_presses != old_presses : print ( button_presses ) print ( 'NeoPixel A:' , color_names [ neopixel_a ], 'index:' , neopixel_a ) print ( 'NeoPixel B:' , color_names [ neopixel_b ], 'index:' , neopixel_b ) strip . set_pixel ( 0 , colors [ neopixel_a ]) strip . set_pixel ( 1 , colors [ neopixel_b ]) strip . show () old_presses = button_presses try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Cleanup code print ( 'Turning off NeoPixels' ) strip . set_pixel ( 0 , ( 0 , 0 , 0 )) strip . set_pixel ( 1 , ( 0 , 0 , 0 )) strip . show ()","title":"Making the Buttons Change the NeoPixel Color"},{"location":"kits/maker-pi-rp2040/05-sound-lab/","text":"Play Mario on MicroPython This program will play the theme music from the Mario video game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from machine import Pin , PWM from utime import sleep buzzer = PWM ( Pin ( 22 )) tones = { \"B0\" : 31 , \"C1\" : 33 , \"CS1\" : 35 , \"D1\" : 37 , \"DS1\" : 39 , \"E1\" : 41 , \"F1\" : 44 , \"FS1\" : 46 , \"G1\" : 49 , \"GS1\" : 52 , \"A1\" : 55 , \"AS1\" : 58 , \"B1\" : 62 , \"C2\" : 65 , \"CS2\" : 69 , \"D2\" : 73 , \"DS2\" : 78 , \"E2\" : 82 , \"F2\" : 87 , \"FS2\" : 93 , \"G2\" : 98 , \"GS2\" : 104 , \"A2\" : 110 , \"AS2\" : 117 , \"B2\" : 123 , \"C3\" : 131 , \"CS3\" : 139 , \"D3\" : 147 , \"DS3\" : 156 , \"E3\" : 165 , \"F3\" : 175 , \"FS3\" : 185 , \"G3\" : 196 , \"GS3\" : 208 , \"A3\" : 220 , \"AS3\" : 233 , \"B3\" : 247 , \"C4\" : 262 , \"CS4\" : 277 , \"D4\" : 294 , \"DS4\" : 311 , \"E4\" : 330 , \"F4\" : 349 , \"FS4\" : 370 , \"G4\" : 392 , \"GS4\" : 415 , \"A4\" : 440 , \"AS4\" : 466 , \"B4\" : 494 , \"C5\" : 523 , \"CS5\" : 554 , \"D5\" : 587 , \"DS5\" : 622 , \"E5\" : 659 , \"F5\" : 698 , \"FS5\" : 740 , \"G5\" : 784 , \"GS5\" : 831 , \"A5\" : 880 , \"AS5\" : 932 , \"B5\" : 988 , \"C6\" : 1047 , \"CS6\" : 1109 , \"D6\" : 1175 , \"DS6\" : 1245 , \"E6\" : 1319 , \"F6\" : 1397 , \"FS6\" : 1480 , \"G6\" : 1568 , \"GS6\" : 1661 , \"A6\" : 1760 , \"AS6\" : 1865 , \"B6\" : 1976 , \"C7\" : 2093 , \"CS7\" : 2217 , \"D7\" : 2349 , \"DS7\" : 2489 , \"E7\" : 2637 , \"F7\" : 2794 , \"FS7\" : 2960 , \"G7\" : 3136 , \"GS7\" : 3322 , \"A7\" : 3520 , \"AS7\" : 3729 , \"B7\" : 3951 , \"C8\" : 4186 , \"CS8\" : 4435 , \"D8\" : 4699 , \"DS8\" : 4978 } song = [ \"E5\" , \"G5\" , \"A5\" , \"P\" , \"E5\" , \"G5\" , \"B5\" , \"A5\" , \"P\" , \"E5\" , \"G5\" , \"A5\" , \"P\" , \"G5\" , \"E5\" ] mario = [ \"E7\" , \"E7\" , 0 , \"E7\" , 0 , \"C7\" , \"E7\" , 0 , \"G7\" , 0 , 0 , 0 , \"G6\" , 0 , 0 , 0 , \"C7\" , 0 , 0 , \"G6\" , 0 , 0 , \"E6\" , 0 , 0 , \"A6\" , 0 , \"B6\" , 0 , \"AS6\" , \"A6\" , 0 , \"G6\" , \"E7\" , 0 , \"G7\" , \"A7\" , 0 , \"F7\" , \"G7\" , 0 , \"E7\" , 0 , \"C7\" , \"D7\" , \"B6\" , 0 , 0 , \"C7\" , 0 , 0 , \"G6\" , 0 , 0 , \"E6\" , 0 , 0 , \"A6\" , 0 , \"B6\" , 0 , \"AS6\" , \"A6\" , 0 , \"G6\" , \"E7\" , 0 , \"G7\" , \"A7\" , 0 , \"F7\" , \"G7\" , 0 , \"E7\" , 0 , \"C7\" , \"D7\" , \"B6\" , 0 , 0 ] def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) def playsong ( mysong ): for i in range ( len ( mysong )): if ( mysong [ i ] == \"P\" or mysong [ i ] == 0 ): bequiet () else : playtone ( tones [ mysong [ i ]]) sleep ( 0.3 ) bequiet () playsong ( mario )","title":"Sound Lab"},{"location":"kits/maker-pi-rp2040/05-sound-lab/#play-mario-on-micropython","text":"This program will play the theme music from the Mario video game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from machine import Pin , PWM from utime import sleep buzzer = PWM ( Pin ( 22 )) tones = { \"B0\" : 31 , \"C1\" : 33 , \"CS1\" : 35 , \"D1\" : 37 , \"DS1\" : 39 , \"E1\" : 41 , \"F1\" : 44 , \"FS1\" : 46 , \"G1\" : 49 , \"GS1\" : 52 , \"A1\" : 55 , \"AS1\" : 58 , \"B1\" : 62 , \"C2\" : 65 , \"CS2\" : 69 , \"D2\" : 73 , \"DS2\" : 78 , \"E2\" : 82 , \"F2\" : 87 , \"FS2\" : 93 , \"G2\" : 98 , \"GS2\" : 104 , \"A2\" : 110 , \"AS2\" : 117 , \"B2\" : 123 , \"C3\" : 131 , \"CS3\" : 139 , \"D3\" : 147 , \"DS3\" : 156 , \"E3\" : 165 , \"F3\" : 175 , \"FS3\" : 185 , \"G3\" : 196 , \"GS3\" : 208 , \"A3\" : 220 , \"AS3\" : 233 , \"B3\" : 247 , \"C4\" : 262 , \"CS4\" : 277 , \"D4\" : 294 , \"DS4\" : 311 , \"E4\" : 330 , \"F4\" : 349 , \"FS4\" : 370 , \"G4\" : 392 , \"GS4\" : 415 , \"A4\" : 440 , \"AS4\" : 466 , \"B4\" : 494 , \"C5\" : 523 , \"CS5\" : 554 , \"D5\" : 587 , \"DS5\" : 622 , \"E5\" : 659 , \"F5\" : 698 , \"FS5\" : 740 , \"G5\" : 784 , \"GS5\" : 831 , \"A5\" : 880 , \"AS5\" : 932 , \"B5\" : 988 , \"C6\" : 1047 , \"CS6\" : 1109 , \"D6\" : 1175 , \"DS6\" : 1245 , \"E6\" : 1319 , \"F6\" : 1397 , \"FS6\" : 1480 , \"G6\" : 1568 , \"GS6\" : 1661 , \"A6\" : 1760 , \"AS6\" : 1865 , \"B6\" : 1976 , \"C7\" : 2093 , \"CS7\" : 2217 , \"D7\" : 2349 , \"DS7\" : 2489 , \"E7\" : 2637 , \"F7\" : 2794 , \"FS7\" : 2960 , \"G7\" : 3136 , \"GS7\" : 3322 , \"A7\" : 3520 , \"AS7\" : 3729 , \"B7\" : 3951 , \"C8\" : 4186 , \"CS8\" : 4435 , \"D8\" : 4699 , \"DS8\" : 4978 } song = [ \"E5\" , \"G5\" , \"A5\" , \"P\" , \"E5\" , \"G5\" , \"B5\" , \"A5\" , \"P\" , \"E5\" , \"G5\" , \"A5\" , \"P\" , \"G5\" , \"E5\" ] mario = [ \"E7\" , \"E7\" , 0 , \"E7\" , 0 , \"C7\" , \"E7\" , 0 , \"G7\" , 0 , 0 , 0 , \"G6\" , 0 , 0 , 0 , \"C7\" , 0 , 0 , \"G6\" , 0 , 0 , \"E6\" , 0 , 0 , \"A6\" , 0 , \"B6\" , 0 , \"AS6\" , \"A6\" , 0 , \"G6\" , \"E7\" , 0 , \"G7\" , \"A7\" , 0 , \"F7\" , \"G7\" , 0 , \"E7\" , 0 , \"C7\" , \"D7\" , \"B6\" , 0 , 0 , \"C7\" , 0 , 0 , \"G6\" , 0 , 0 , \"E6\" , 0 , 0 , \"A6\" , 0 , \"B6\" , 0 , \"AS6\" , \"A6\" , 0 , \"G6\" , \"E7\" , 0 , \"G7\" , \"A7\" , 0 , \"F7\" , \"G7\" , 0 , \"E7\" , 0 , \"C7\" , \"D7\" , \"B6\" , 0 , 0 ] def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) def playsong ( mysong ): for i in range ( len ( mysong )): if ( mysong [ i ] == \"P\" or mysong [ i ] == 0 ): bequiet () else : playtone ( tones [ mysong [ i ]]) sleep ( 0.3 ) bequiet () playsong ( mario )","title":"Play Mario on MicroPython"},{"location":"kits/maker-pi-rp2040/06-up-down-lab/","text":"Up Down Mode Lab In this lab, we will combine the two buttons with the blue LEDs, the NeoPixels and the buzzer labs. The We will make the LED, NeoPixels and sound all change for each button press. You will be able to up and down the color spectrum and the sound frequency. We will start with the material from our button lab. We will create two functions that will be triggered by the two buttons. One will increment a counter (add one) and the other will decrement the counter (subtract 1). By pressing one of the two buttons you will cycle through the modes of the program. The diagram has eight different modes. The default mode is usually mode=0. When you press the left button the mode will increase by one. The NeoPixels will change from red to orange. Pressing the left button will increase the mode by one going to the orange mode. Pressing the right button will subtract one from the mode going from mode 1 (orange) back to model 0 (red). Within our Interrupt Request Handler (IRQ) function we will also have to add two lines to deal with the wrap around logic like this: 1 2 3 # wrap around to first mode if mode >= mode_count : mode = 0 if mode < 0 : mode = mode_count - 1 Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 # Mode Up/Down Lab # Change a mode using the buttons on the Maker Pi RP2040 board # Changes the NeoPixel color and the blue GPIO status LEDs import time from machine import Pin , PWM # We are using a MicroPython NeoPixel library from here: https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel BUZZER_PORT = 22 buzzer = PWM ( Pin ( BUZZER_PORT )) NUMBER_PIXELS = 2 STATE_MACHINE = 0 NEOPIXEL_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , NEOPIXEL_PIN , \"GRB\" ) # have up to 13 that we can use blue_led_pins = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] number_leds = len ( blue_led_pins ) led_ports = [] # create a list of the port pin object instances for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Color RGB values as tuples - needs some Gamma corrections red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink cyan = ( 0 , 255 , 255 ) lightgreen = ( 100 , 255 , 100 ) white = ( 128 , 128 , 128 ) # not too bright color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' , 'cyan' , 'lightgreen' , 'white' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , lightgreen , white ) # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler mode = 0 # the default mode on powerup and reset mode_count = len ( color_names ) last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # Give our pins some logical names next_mode_pin = machine . Pin ( 20 , machine . Pin . IN , machine . Pin . PULL_DOWN ) previous_mode_pin = machine . Pin ( 21 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global mode , last_time new_time = time . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): mode += 1 else : mode -= 1 # wrap around to first mode if mode >= mode_count : mode = 0 if mode < 0 : mode = mode_count - 1 last_time = new_time def set_blue_led_mode ( mode ): global num_colors for i in range ( 0 , num_colors ): if i == mode : led_ports [ i ] . high () else : led_ports [ i ] . low () # Register the handler function when either button is pressed next_mode_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) previous_mode_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # Note the non-linear increases in frequency - note that some are louder tone_freq = [ 100 , 150 , 210 , 280 , 350 , 450 , 580 , 750 , 850 , 950 , 1000 ] def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) # This is for only printing when a new button press count value happens old_mode = - 1 print ( 'found ' , mode_count , ' modes.' ) while True : # only print on change in the button_presses value if mode != old_mode : print ( 'new mode:' , mode , color_names [ mode ], tone_freq [ mode ]) # get the color mode color = colors [ mode ] strip . set_pixel ( 0 , color ) strip . set_pixel ( 1 , color ) strip . show () set_blue_led_mode ( mode ) playtone ( tone_freq [ mode ]) time . sleep ( . 2 ) bequiet () old_mode = mode","title":"Up/Down Mode Lab"},{"location":"kits/maker-pi-rp2040/06-up-down-lab/#up-down-mode-lab","text":"In this lab, we will combine the two buttons with the blue LEDs, the NeoPixels and the buzzer labs. The We will make the LED, NeoPixels and sound all change for each button press. You will be able to up and down the color spectrum and the sound frequency. We will start with the material from our button lab. We will create two functions that will be triggered by the two buttons. One will increment a counter (add one) and the other will decrement the counter (subtract 1). By pressing one of the two buttons you will cycle through the modes of the program. The diagram has eight different modes. The default mode is usually mode=0. When you press the left button the mode will increase by one. The NeoPixels will change from red to orange. Pressing the left button will increase the mode by one going to the orange mode. Pressing the right button will subtract one from the mode going from mode 1 (orange) back to model 0 (red). Within our Interrupt Request Handler (IRQ) function we will also have to add two lines to deal with the wrap around logic like this: 1 2 3 # wrap around to first mode if mode >= mode_count : mode = 0 if mode < 0 : mode = mode_count - 1","title":"Up Down Mode Lab"},{"location":"kits/maker-pi-rp2040/06-up-down-lab/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 # Mode Up/Down Lab # Change a mode using the buttons on the Maker Pi RP2040 board # Changes the NeoPixel color and the blue GPIO status LEDs import time from machine import Pin , PWM # We are using a MicroPython NeoPixel library from here: https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel BUZZER_PORT = 22 buzzer = PWM ( Pin ( BUZZER_PORT )) NUMBER_PIXELS = 2 STATE_MACHINE = 0 NEOPIXEL_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , NEOPIXEL_PIN , \"GRB\" ) # have up to 13 that we can use blue_led_pins = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] number_leds = len ( blue_led_pins ) led_ports = [] # create a list of the port pin object instances for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Color RGB values as tuples - needs some Gamma corrections red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink cyan = ( 0 , 255 , 255 ) lightgreen = ( 100 , 255 , 100 ) white = ( 128 , 128 , 128 ) # not too bright color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' , 'cyan' , 'lightgreen' , 'white' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , lightgreen , white ) # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler mode = 0 # the default mode on powerup and reset mode_count = len ( color_names ) last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # Give our pins some logical names next_mode_pin = machine . Pin ( 20 , machine . Pin . IN , machine . Pin . PULL_DOWN ) previous_mode_pin = machine . Pin ( 21 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global mode , last_time new_time = time . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): mode += 1 else : mode -= 1 # wrap around to first mode if mode >= mode_count : mode = 0 if mode < 0 : mode = mode_count - 1 last_time = new_time def set_blue_led_mode ( mode ): global num_colors for i in range ( 0 , num_colors ): if i == mode : led_ports [ i ] . high () else : led_ports [ i ] . low () # Register the handler function when either button is pressed next_mode_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) previous_mode_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # Note the non-linear increases in frequency - note that some are louder tone_freq = [ 100 , 150 , 210 , 280 , 350 , 450 , 580 , 750 , 850 , 950 , 1000 ] def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) # This is for only printing when a new button press count value happens old_mode = - 1 print ( 'found ' , mode_count , ' modes.' ) while True : # only print on change in the button_presses value if mode != old_mode : print ( 'new mode:' , mode , color_names [ mode ], tone_freq [ mode ]) # get the color mode color = colors [ mode ] strip . set_pixel ( 0 , color ) strip . set_pixel ( 1 , color ) strip . show () set_blue_led_mode ( mode ) playtone ( tone_freq [ mode ]) time . sleep ( . 2 ) bequiet () old_mode = mode","title":"Full Program"},{"location":"kits/maker-pi-rp2040-robot/01-intro/","text":"Cytron Maker Pi RP2040 Collision Avoidance Robot Base Robot Demo with OLED Display This kit allows you to create a collision avoidance robot using about $20 of parts or $40 if you use the larger OLED display. The robot can be built ia a few hours using a screwdriver and soldering four wires onto the motors. Parts List Cytron Maker Pi RP2040 robotics board ($10) SmartCar kit ($9) Time-of-flight sensor (4) Optional OLED SPI 2.24\" SSD1606 display ($18)","title":"Introduction"},{"location":"kits/maker-pi-rp2040-robot/01-intro/#cytron-maker-pi-rp2040-collision-avoidance-robot","text":"","title":"Cytron Maker Pi RP2040 Collision Avoidance Robot"},{"location":"kits/maker-pi-rp2040-robot/01-intro/#base-robot","text":"","title":"Base Robot"},{"location":"kits/maker-pi-rp2040-robot/01-intro/#demo-with-oled-display","text":"This kit allows you to create a collision avoidance robot using about $20 of parts or $40 if you use the larger OLED display. The robot can be built ia a few hours using a screwdriver and soldering four wires onto the motors.","title":"Demo with OLED Display"},{"location":"kits/maker-pi-rp2040-robot/01-intro/#parts-list","text":"Cytron Maker Pi RP2040 robotics board ($10) SmartCar kit ($9) Time-of-flight sensor (4) Optional OLED SPI 2.24\" SSD1606 display ($18)","title":"Parts List"},{"location":"kits/maker-pi-rp2040-robot/02-assembly/","text":"Assembling Your Maker Pi RP2040 Robot This kit is a $25 robot kit that we will use in our CoderDojo robotics classes. This kit includes: A SmartCar Chassis Two 3 to 6-volt DC geared hobby motors and wheels Plexiglass (acrylic) main board Screws and nuts 4 AA battery pack Power switch Cytron Maker Pi RP2040 kit Maker Pi RP2040 board 4x Grove to female header cables Screwdriver Silicone rubber feet (pack of 4) Ultrasonce sensor mounting braket 2 M2 6mm screws and nuts You will need to provide 4 AA batteries and a Micro USB connector that works with your PC or Mac. Assemble the SmartCar Chassis In this version of the kit the wires are pre-soldered onto the motors. Here is the robot kit in all the packaging: Your first task is to remove the protective backing from the acrylic body. Here are all the parts removed from the packaging: We mount the motors with the wires on the inside and the heads of the bolts on the outside. This photo shows cable ties I have added so that the wires don't get pulled out by our students. These cable ties are optional. Next, we position the battery pack on the BOTTOM so that we have more room on the top for our circuit board, sensors and add-on displays. I used a 1/8th inch drill bit to put holes where the battery pack should be mounted. Next, I put the flat head screws in the battery pack. We want to make sure the top of the screw is all the way in so that it does not get in the way of the battery. Next we mount the rubber feat on the bottom of the Maker Pi RP2040 circuit board so that we have some space between the PC board and the main chassis. I use the space next to the four corners to mount the feet. Note that we must put the drag wheel on before we put the PC board on top of the chassis. Next, we put the four screws and spacers in the four holes at the bottom rear of the robot directly behind the battery pack. We then add the four screws to mount the drag wheel. Now is a good time to check the spacing of the battery pack and the read drag wheel. The rear drag wheel must be able to spin freely in a full circle without bumping into the battery. If it bumps you might need to remount the battery pack before you proceed to the next step. This figure has the switch that comes with the battery pack. For our work, we will not need this switch since the Maker Pi RP2040 circuit board has an no-board power switch. Most of our students put the switch in if they ever need to change circuit boards that don't have a built-in power switch. If you do this, you can solder the switch between the red power of the battery and the positive terminal of VIN. Next, line up the printed circuit board with the USB connector facing the rear. Note where the holes are in the board and drill two 1/8\" holes to mount the board. This photo shows the holes drilled with the screws in them. This is the side-view from the rear of the screws holding on the circuit board. Next use two 6 mm M3 screws to mount the ultrasonic distance sensor on top front of the robot. Some of our students like to mount the ultrasonic sensor under the chassis and point the sensor up a little so the sensor does not reflect off the floor. You can use a heat gun to soften the plastic mount to change the angle. Next I added a drop of hot-glue under the front screws that mount the pc board. I did this because the battery pack and motor mounts get in the way of adding a nut under the board. Next, I used a small rubber coated twist tie to keep the wires under the robot away from the wheels and battery. We don't want them to drag on the floor. Next, we connect the motors up to the screw headers on the printed circuit board. There is a screwdriver that comes with the Cytron Maker Pi RP2040 that is handy for tightening the screws. Don't worry about getting the connections all correct. They can be adjusted in your software. Press the wheels on the motors. Lastly we connect the battery to the VIN jumper, making sure to connect the red wire to the \"+\" terminal and the black wire to the \"-\" terminal. Connect the Maker Pi RP2040 board to the top with the USB connector facing the rear. Here is a short video of the assembly of a SmartCar Chassis. Note that this video puts the battery on the top, where we put it on the bottom. There are many videos online how to assemble to motors to the chassis. The trick is orienting the motors correctly and making sure the bolts don't get in the way of the wheels.","title":"Assembly"},{"location":"kits/maker-pi-rp2040-robot/02-assembly/#assembling-your-maker-pi-rp2040-robot","text":"This kit is a $25 robot kit that we will use in our CoderDojo robotics classes. This kit includes: A SmartCar Chassis Two 3 to 6-volt DC geared hobby motors and wheels Plexiglass (acrylic) main board Screws and nuts 4 AA battery pack Power switch Cytron Maker Pi RP2040 kit Maker Pi RP2040 board 4x Grove to female header cables Screwdriver Silicone rubber feet (pack of 4) Ultrasonce sensor mounting braket 2 M2 6mm screws and nuts You will need to provide 4 AA batteries and a Micro USB connector that works with your PC or Mac.","title":"Assembling Your Maker Pi RP2040 Robot"},{"location":"kits/maker-pi-rp2040-robot/02-assembly/#assemble-the-smartcar-chassis","text":"In this version of the kit the wires are pre-soldered onto the motors. Here is the robot kit in all the packaging: Your first task is to remove the protective backing from the acrylic body. Here are all the parts removed from the packaging: We mount the motors with the wires on the inside and the heads of the bolts on the outside. This photo shows cable ties I have added so that the wires don't get pulled out by our students. These cable ties are optional. Next, we position the battery pack on the BOTTOM so that we have more room on the top for our circuit board, sensors and add-on displays. I used a 1/8th inch drill bit to put holes where the battery pack should be mounted. Next, I put the flat head screws in the battery pack. We want to make sure the top of the screw is all the way in so that it does not get in the way of the battery. Next we mount the rubber feat on the bottom of the Maker Pi RP2040 circuit board so that we have some space between the PC board and the main chassis. I use the space next to the four corners to mount the feet. Note that we must put the drag wheel on before we put the PC board on top of the chassis. Next, we put the four screws and spacers in the four holes at the bottom rear of the robot directly behind the battery pack. We then add the four screws to mount the drag wheel. Now is a good time to check the spacing of the battery pack and the read drag wheel. The rear drag wheel must be able to spin freely in a full circle without bumping into the battery. If it bumps you might need to remount the battery pack before you proceed to the next step. This figure has the switch that comes with the battery pack. For our work, we will not need this switch since the Maker Pi RP2040 circuit board has an no-board power switch. Most of our students put the switch in if they ever need to change circuit boards that don't have a built-in power switch. If you do this, you can solder the switch between the red power of the battery and the positive terminal of VIN. Next, line up the printed circuit board with the USB connector facing the rear. Note where the holes are in the board and drill two 1/8\" holes to mount the board. This photo shows the holes drilled with the screws in them. This is the side-view from the rear of the screws holding on the circuit board. Next use two 6 mm M3 screws to mount the ultrasonic distance sensor on top front of the robot. Some of our students like to mount the ultrasonic sensor under the chassis and point the sensor up a little so the sensor does not reflect off the floor. You can use a heat gun to soften the plastic mount to change the angle. Next I added a drop of hot-glue under the front screws that mount the pc board. I did this because the battery pack and motor mounts get in the way of adding a nut under the board. Next, I used a small rubber coated twist tie to keep the wires under the robot away from the wheels and battery. We don't want them to drag on the floor. Next, we connect the motors up to the screw headers on the printed circuit board. There is a screwdriver that comes with the Cytron Maker Pi RP2040 that is handy for tightening the screws. Don't worry about getting the connections all correct. They can be adjusted in your software. Press the wheels on the motors. Lastly we connect the battery to the VIN jumper, making sure to connect the red wire to the \"+\" terminal and the black wire to the \"-\" terminal. Connect the Maker Pi RP2040 board to the top with the USB connector facing the rear. Here is a short video of the assembly of a SmartCar Chassis. Note that this video puts the battery on the top, where we put it on the bottom. There are many videos online how to assemble to motors to the chassis. The trick is orienting the motors correctly and making sure the bolts don't get in the way of the wheels.","title":"Assemble the SmartCar Chassis"},{"location":"kits/maker-pi-rp2040-robot/06-up-down-motor-lab/","text":"Up Down Motor Speed Lab In this lab, we will make the motor speed change as the mode changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Motor Setup # motors just barely turn at this power level MIN_POWER_LEVEL = 10000 MAX_POWER_LEVEL = 65025 POWER_STEP = int (( MAX_POWER_LEVEL - MIN_POWER_LEVEL ) / 10 ) # lower right pins with USB on top RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def drive_speed ( power_level ): right_forward . duty_u16 ( power_level ) left_forward . duty_u16 ( power_level ) In the main we have: 1 2 3 4 power_level = MIN_POWER_LEVEL + mode * POWER_STEP # turn off the motor if we are at mode 0 if mode == 0 : power_level = 0 drive_speed ( power_level ) Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 # Mode Up/Down Lab # Change a mode using the buttons on the Maker Pi RP2040 board # Changes the NeoPixel color and the blue GPIO status LEDs import time from machine import Pin , PWM # We are using a MicroPython NeoPixel library from here: https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel BUZZER_PORT = 22 buzzer = PWM ( Pin ( BUZZER_PORT )) NUMBER_PIXELS = 2 STATE_MACHINE = 0 NEOPIXEL_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , NEOPIXEL_PIN , \"GRB\" ) # have up to 13 that we can use blue_led_pins = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] number_leds = len ( blue_led_pins ) led_ports = [] # create a list of the port pin object instances for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Color RGB values as tuples - needs some Gamma corrections red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink cyan = ( 0 , 255 , 255 ) lightgreen = ( 100 , 255 , 100 ) white = ( 128 , 128 , 128 ) # not too bright color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' , 'cyan' , 'lightgreen' , 'white' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , lightgreen , white ) # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler # Motor Setup # motors just barely turn at this power level MIN_POWER_LEVEL = 10000 MAX_POWER_LEVEL = 65025 POWER_STEP = int (( MAX_POWER_LEVEL - MIN_POWER_LEVEL ) / 10 ) # lower right pins with USB on top RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def drive_speed ( power_level ): right_forward . duty_u16 ( power_level ) left_forward . duty_u16 ( power_level ) mode = 0 # the default mode on powerup and reset mode_count = len ( color_names ) last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # Give our pins some logical names next_mode_pin = machine . Pin ( 20 , machine . Pin . IN , machine . Pin . PULL_DOWN ) previous_mode_pin = machine . Pin ( 21 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global mode , last_time , power_level new_time = time . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): mode += 1 # power_level += POWER_STEP else : mode -= 1 # power_level -= POWER_STEP # wrap around to first mode if mode >= mode_count : mode = 0 if mode < 0 : mode = mode_count - 1 last_time = new_time def set_blue_led_mode ( mode ): global num_colors for i in range ( 0 , num_colors ): if i == mode : led_ports [ i ] . high () else : led_ports [ i ] . low () # Register the handler function when either button is pressed next_mode_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) previous_mode_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # non-linear increase is frequency - note that some are lowder tone_freq = [ 100 , 150 , 210 , 280 , 350 , 450 , 580 , 750 , 850 , 950 , 1000 ] def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) # This is for only printing when a new button press count value happens old_mode = - 1 power_level = MIN_POWER_LEVEL print ( 'found ' , mode_count , ' modes.' ) while True : # only print on change in the button_presses value if mode != old_mode : print ( 'new mode:' , mode , color_names [ mode ], tone_freq [ mode ], power_level ) # get the color mode color = colors [ mode ] strip . set_pixel ( 0 , color ) strip . set_pixel ( 1 , color ) strip . show () set_blue_led_mode ( mode ) playtone ( tone_freq [ mode ]) time . sleep ( . 2 ) bequiet () power_level = MIN_POWER_LEVEL + mode * POWER_STEP # turn off the motor if we are at mode 0 if mode == 0 : power_level = 0 drive_speed ( power_level ) old_mode = mode","title":"Up/Down Motor Speed Lab"},{"location":"kits/maker-pi-rp2040-robot/06-up-down-motor-lab/#up-down-motor-speed-lab","text":"In this lab, we will make the motor speed change as the mode changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Motor Setup # motors just barely turn at this power level MIN_POWER_LEVEL = 10000 MAX_POWER_LEVEL = 65025 POWER_STEP = int (( MAX_POWER_LEVEL - MIN_POWER_LEVEL ) / 10 ) # lower right pins with USB on top RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def drive_speed ( power_level ): right_forward . duty_u16 ( power_level ) left_forward . duty_u16 ( power_level ) In the main we have: 1 2 3 4 power_level = MIN_POWER_LEVEL + mode * POWER_STEP # turn off the motor if we are at mode 0 if mode == 0 : power_level = 0 drive_speed ( power_level )","title":"Up Down Motor Speed Lab"},{"location":"kits/maker-pi-rp2040-robot/06-up-down-motor-lab/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 # Mode Up/Down Lab # Change a mode using the buttons on the Maker Pi RP2040 board # Changes the NeoPixel color and the blue GPIO status LEDs import time from machine import Pin , PWM # We are using a MicroPython NeoPixel library from here: https://github.com/blaz-r/pi_pico_neopixel from neopixel import Neopixel BUZZER_PORT = 22 buzzer = PWM ( Pin ( BUZZER_PORT )) NUMBER_PIXELS = 2 STATE_MACHINE = 0 NEOPIXEL_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , NEOPIXEL_PIN , \"GRB\" ) # have up to 13 that we can use blue_led_pins = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] number_leds = len ( blue_led_pins ) led_ports = [] # create a list of the port pin object instances for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Color RGB values as tuples - needs some Gamma corrections red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink cyan = ( 0 , 255 , 255 ) lightgreen = ( 100 , 255 , 100 ) white = ( 128 , 128 , 128 ) # not too bright color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' , 'cyan' , 'lightgreen' , 'white' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , lightgreen , white ) # set to be 1 to 100 for percent brightness strip . brightness ( 100 ) # Sample Raspberry Pi Pico MicroPython button press example with a debounce delay value of 200ms in the interrupt handler # Motor Setup # motors just barely turn at this power level MIN_POWER_LEVEL = 10000 MAX_POWER_LEVEL = 65025 POWER_STEP = int (( MAX_POWER_LEVEL - MIN_POWER_LEVEL ) / 10 ) # lower right pins with USB on top RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def drive_speed ( power_level ): right_forward . duty_u16 ( power_level ) left_forward . duty_u16 ( power_level ) mode = 0 # the default mode on powerup and reset mode_count = len ( color_names ) last_time = 0 # the last time we pressed the button builtin_led = machine . Pin ( 25 , Pin . OUT ) # Give our pins some logical names next_mode_pin = machine . Pin ( 20 , machine . Pin . IN , machine . Pin . PULL_DOWN ) previous_mode_pin = machine . Pin ( 21 , machine . Pin . IN , machine . Pin . PULL_DOWN ) # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global mode , last_time , power_level new_time = time . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): mode += 1 # power_level += POWER_STEP else : mode -= 1 # power_level -= POWER_STEP # wrap around to first mode if mode >= mode_count : mode = 0 if mode < 0 : mode = mode_count - 1 last_time = new_time def set_blue_led_mode ( mode ): global num_colors for i in range ( 0 , num_colors ): if i == mode : led_ports [ i ] . high () else : led_ports [ i ] . low () # Register the handler function when either button is pressed next_mode_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) previous_mode_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # non-linear increase is frequency - note that some are lowder tone_freq = [ 100 , 150 , 210 , 280 , 350 , 450 , 580 , 750 , 850 , 950 , 1000 ] def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) # This is for only printing when a new button press count value happens old_mode = - 1 power_level = MIN_POWER_LEVEL print ( 'found ' , mode_count , ' modes.' ) while True : # only print on change in the button_presses value if mode != old_mode : print ( 'new mode:' , mode , color_names [ mode ], tone_freq [ mode ], power_level ) # get the color mode color = colors [ mode ] strip . set_pixel ( 0 , color ) strip . set_pixel ( 1 , color ) strip . show () set_blue_led_mode ( mode ) playtone ( tone_freq [ mode ]) time . sleep ( . 2 ) bequiet () power_level = MIN_POWER_LEVEL + mode * POWER_STEP # turn off the motor if we are at mode 0 if mode == 0 : power_level = 0 drive_speed ( power_level ) old_mode = mode","title":"Full Program"},{"location":"kits/maker-pi-rp2040-robot/07-motor-connection-lab/","text":"Motor Drive Connection Test Built-In Motor Driver The Maker Pi RP2040 board contains a MX1508 dual channel H-bridge chip and easy-to-connect screw headers for power and motor connections. This is fantastic for teaching robotics since students can driver two motors without ever having to use a soldering iron. !!! Note that the is designed to work with small DC-hobby motors and there is no documentation on exactly what motor driver chip is used or its precise current and power limitations. The documentation only indicates that the maximum current is 1A continuous power and 1.5A for up to 5 seconds. The input voltage is only rated at 6 volts, which find for our standard 4 AA battery packs. If this motor driver chip is similar to the ubiquitous L293x motor controllers , and the current should be 1A per motor. I suspect that if you glued a small heat sink like a 16 pin DIP fin to the unknown motor driver IC on the main board you could drive slightly larger motors. Close-up of the motor driver chip. I can't quite make out the numbers on the chip, but the logo is not \"TI\". Testing The Connections In our standard robot, the M1 is the right wheel as you are looking from the top-back of the robot. The M2 wheel is the left wheel. I connect the red to the right of the two connectors and it is also the right terminal of the motors as you are looking from the rear. Look at the buttons near the motor connectors. Press the M1A button and verify that the right wheel is moving forward. Press the M1B and the motor should turn in reverse. Similarly the M2B button should turn the left wheel forward and the M2A should turn the left wheel in reverse. If you don't wire these connections the same way I did it is not a worry. It is easy to change the code. Motor Pin Definitions Now that we know what buttons control what motors and directions they turn, we are ready to define the pins that are associated with each robot movement. We have four pin assignments: both forward and reverse for both the right and left motors. 1 2 3 4 RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 Testing Your Pin Definitions The following program is called our motor connection test. It will turn each motor direction for three seconds and it will print out the motor and direction in the console. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from machine import Pin , PWM import time POWER_LEVEL = 65025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse )","title":"Motor Lab"},{"location":"kits/maker-pi-rp2040-robot/07-motor-connection-lab/#motor-drive-connection-test","text":"","title":"Motor Drive Connection Test"},{"location":"kits/maker-pi-rp2040-robot/07-motor-connection-lab/#built-in-motor-driver","text":"The Maker Pi RP2040 board contains a MX1508 dual channel H-bridge chip and easy-to-connect screw headers for power and motor connections. This is fantastic for teaching robotics since students can driver two motors without ever having to use a soldering iron. !!! Note that the is designed to work with small DC-hobby motors and there is no documentation on exactly what motor driver chip is used or its precise current and power limitations. The documentation only indicates that the maximum current is 1A continuous power and 1.5A for up to 5 seconds. The input voltage is only rated at 6 volts, which find for our standard 4 AA battery packs. If this motor driver chip is similar to the ubiquitous L293x motor controllers , and the current should be 1A per motor. I suspect that if you glued a small heat sink like a 16 pin DIP fin to the unknown motor driver IC on the main board you could drive slightly larger motors. Close-up of the motor driver chip. I can't quite make out the numbers on the chip, but the logo is not \"TI\".","title":"Built-In Motor Driver"},{"location":"kits/maker-pi-rp2040-robot/07-motor-connection-lab/#testing-the-connections","text":"In our standard robot, the M1 is the right wheel as you are looking from the top-back of the robot. The M2 wheel is the left wheel. I connect the red to the right of the two connectors and it is also the right terminal of the motors as you are looking from the rear. Look at the buttons near the motor connectors. Press the M1A button and verify that the right wheel is moving forward. Press the M1B and the motor should turn in reverse. Similarly the M2B button should turn the left wheel forward and the M2A should turn the left wheel in reverse. If you don't wire these connections the same way I did it is not a worry. It is easy to change the code.","title":"Testing The Connections"},{"location":"kits/maker-pi-rp2040-robot/07-motor-connection-lab/#motor-pin-definitions","text":"Now that we know what buttons control what motors and directions they turn, we are ready to define the pins that are associated with each robot movement. We have four pin assignments: both forward and reverse for both the right and left motors. 1 2 3 4 RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10","title":"Motor Pin Definitions"},{"location":"kits/maker-pi-rp2040-robot/07-motor-connection-lab/#testing-your-pin-definitions","text":"The following program is called our motor connection test. It will turn each motor direction for three seconds and it will print out the motor and direction in the console. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from machine import Pin , PWM import time POWER_LEVEL = 65025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse )","title":"Testing Your Pin Definitions"},{"location":"kits/maker-pi-rp2040-robot/07b-drive-square-lab/","text":"Drive Square Lab Prerequsites This lab assumes you have your Maker Pi RP2040 mounted on a SmartCar chassis with two motors and a battery hooked up. In this lab we will program our robot to drive in a square pattern. We will start out doing a \"bench test\" that will require you to put the robot up on a block so you can see the wheels turn, but it will not drive off your desktop. You can also observe the red LED lights on the many board to see which motor direction is on. The main loop will look like this: 1 2 3 4 5 6 7 8 9 10 11 12 while True : forward () sleep ( FWD_TIME ) stop () sleep ( STOP_TIME ) turn_right () sleep ( TURN_TIME ) stop () sleep ( STOP_TIME ) We will need to adjust the TURN_TIME parameter to have the robot turn 90 degrees. A good value for most robots is about 1/2 second or sleep(.5). Since we will be calling the sleep function many times we will use the following import format to keep our code tidy: 1 from utime import sleep This says that whenever we want to pause our system we just use the sleep(time) function we mean to use the sleep function in the micropython time library. This keeps our code small and portable. Adding a Keyboard Interrupt Handler (Control-C) It is also a problem that when we stop a program running that the PWM circuits keep generating signals, which means the robot keeps moving even after we press the STOP/RESET button. To clean this up we will allow you to run a special cleanup handler that will add a function to set all the motors to off using the stop() function. 1 2 3 4 5 6 7 8 9 try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'Cleaning up' ) print ( 'Powering down all motors now.' ) stop () Full Program You are now ready to test the full program. Save the following to the main.py file, disconnect the USB connector and turn on the power on the main board. Your robot should not we driving in a square! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 from machine import Pin , PWM from utime import sleep POWER_LEVEL = 65025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) FWD_TIME = 2 TURN_TIME = . 5 # adjust this to get the turn to be 90 degrees STOP_TIME = 2 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) print ( 'Running Drive Square Lab' ) print ( 'Use Control-C to Stop All Motors' ) def main (): while True : print ( 'forward' ) forward () sleep ( FWD_TIME ) print ( 'stop' ) stop () sleep ( STOP_TIME ) print ( 'turning right' ) turn_right () sleep ( TURN_TIME ) print ( 'stop' ) stop () sleep ( STOP_TIME ) try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'Cleaning up' ) print ( 'Powering down all motors now.' ) stop ()","title":"Square Lab"},{"location":"kits/maker-pi-rp2040-robot/07b-drive-square-lab/#drive-square-lab","text":"","title":"Drive Square Lab"},{"location":"kits/maker-pi-rp2040-robot/07b-drive-square-lab/#prerequsites","text":"This lab assumes you have your Maker Pi RP2040 mounted on a SmartCar chassis with two motors and a battery hooked up. In this lab we will program our robot to drive in a square pattern. We will start out doing a \"bench test\" that will require you to put the robot up on a block so you can see the wheels turn, but it will not drive off your desktop. You can also observe the red LED lights on the many board to see which motor direction is on. The main loop will look like this: 1 2 3 4 5 6 7 8 9 10 11 12 while True : forward () sleep ( FWD_TIME ) stop () sleep ( STOP_TIME ) turn_right () sleep ( TURN_TIME ) stop () sleep ( STOP_TIME ) We will need to adjust the TURN_TIME parameter to have the robot turn 90 degrees. A good value for most robots is about 1/2 second or sleep(.5). Since we will be calling the sleep function many times we will use the following import format to keep our code tidy: 1 from utime import sleep This says that whenever we want to pause our system we just use the sleep(time) function we mean to use the sleep function in the micropython time library. This keeps our code small and portable.","title":"Prerequsites"},{"location":"kits/maker-pi-rp2040-robot/07b-drive-square-lab/#adding-a-keyboard-interrupt-handler-control-c","text":"It is also a problem that when we stop a program running that the PWM circuits keep generating signals, which means the robot keeps moving even after we press the STOP/RESET button. To clean this up we will allow you to run a special cleanup handler that will add a function to set all the motors to off using the stop() function. 1 2 3 4 5 6 7 8 9 try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'Cleaning up' ) print ( 'Powering down all motors now.' ) stop ()","title":"Adding a Keyboard Interrupt Handler (Control-C)"},{"location":"kits/maker-pi-rp2040-robot/07b-drive-square-lab/#full-program","text":"You are now ready to test the full program. Save the following to the main.py file, disconnect the USB connector and turn on the power on the main board. Your robot should not we driving in a square! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 from machine import Pin , PWM from utime import sleep POWER_LEVEL = 65025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) FWD_TIME = 2 TURN_TIME = . 5 # adjust this to get the turn to be 90 degrees STOP_TIME = 2 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) print ( 'Running Drive Square Lab' ) print ( 'Use Control-C to Stop All Motors' ) def main (): while True : print ( 'forward' ) forward () sleep ( FWD_TIME ) print ( 'stop' ) stop () sleep ( STOP_TIME ) print ( 'turning right' ) turn_right () sleep ( TURN_TIME ) print ( 'stop' ) stop () sleep ( STOP_TIME ) try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'Cleaning up' ) print ( 'Powering down all motors now.' ) stop ()","title":"Full Program"},{"location":"kits/maker-pi-rp2040-robot/08-servo-lab/","text":"Maker Pi RP2040 Servo Lab Servo motors are ideal for controlling the angle of an item such as a steering angle or the direction of a sensor. The servos used in these labs are inexpensive SG90 micro-servos that draw very little power and are ideal for a teaching lab. They can be purchased for about $3 each US on eBay . To control a 180 degree servo, you just tell it what angle you would like it to move to. The range of values is typically -90 to 90 degrees with 0 being the nominal resting position for many applications such as the steering wheel angle of a car. The Maker Pi RP2040 has four servo ports in the upper left corner of the board (with the USB on the bottom) that use ports GP12, GP13, GP14 and GP15. You can connect any small micro servo directly to these ports. Just make sure to get the polarity correct. The colors for servos may vary somewhat, but the two most common standards are: Orange, red and brown - signal, positive and ground White, red, black - signal, positive and ground The general rule is that the lighter colors of orange and white will be the signal and the brown and black will be ground. Servo Control We will use the PWM functions in our MicroPython library to send a PWM signal to each of the servos. Servos are not controlled by the duty cycle directly. They are controlled by the width of the pulses. But we can control the approximate with of the pulses by holding the frequency constant and changing the duty cycle. We will use a 40 hertz signal to send a PWM signal to each of the servos like this. 1 2 3 SERVO_FREQ_HZ = 40 # SERVO_PERIOD_MS = 1000 / SERVO_FREQ_HZ is a 25 millisecond pulse width my_pwm . freq ( SERVO_FREQ_HZ ) Calibration of the Servo There are small manufacturing variations in servos. This means to get the full sweep of a 180% servo you have to adjust the duty cycle. Minimum duty cycle: 1700 Maximum duty cycle: 6300 By some experimentation I got the following results 1 2 SERVO_MIN_DUTY = 1725 # -90 degrees SERVO_MAX_DUTY = 6378 # 90 degrees We can use a linear mapping function to convert the angle (from -90 to 90): 1 2 3 4 5 6 7 8 9 # This will take in integers of range in (min and max) return a integer in the output range (min and max) # Used to convert one range of values into another using a linear function like the Arduino map() function def convert ( x , in_min , in_max , out_min , out_max ): return ( x - in_min ) * ( out_max - out_min ) // ( in_max - in_min ) + out_min angle = 0 duty = convert ( angle , - 90 , 90 , SERVO_MIN_DUTY , SERVO_MAX_DUTY ) print ( 'For angle: ' , angle , ' the duty is: ' , duty ) pwm . duty_u16 ( duty ) Checking your Servo Calibration with Buttons We can also use the buttons on the Maker Pi RP2040 to verify that the extreme angles are correct. One button will increase the angle and one will decrease the angle. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 # Maker Pi RP2040 program to check the limits of a 180 degree servo such as a SG90 micro servo from machine import Pin , PWM import time BUTTON_1_PIN = 20 # increment the angle BUTTON_2_PIN = 21 # decrement the angle SERVO_1_PIN = 12 SERVO_2_PIN = 13 # MAX=5749@40 SERVO_3_PIN = 14 SERVO_4_PIN = 15 # this is ususlly standard across most servos SERVO_FREQ_HZ = 40 pwm = PWM ( Pin ( SERVO_2_PIN )) # the two button on the Maker Pi RP2040 increment_angle_button_pin = machine . Pin ( BUTTON_1_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) decrement_angle_button_pin = machine . Pin ( BUTTON_2_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) # return int( ( (0.0015*SERVO_FREQ_HZ) + ((angle/90) * (0.0005*SERVO_FREQ_HZ)) ) * 65535 ) # This will take in integers of range in (min and max) return a integer in the output range (min and max) # Used to convert one range of values into another using a linear function like the Arduino map() function def convert ( x , in_min , in_max , out_min , out_max ): return ( x - in_min ) * ( out_max - out_min ) // ( in_max - in_min ) + out_min # globals angle = - 90 last_time = 0 # the last time we pressed the button # if the pin is 20 then increment, else decement def button_pressed_handler ( pin ): global angle , last_time new_time = time . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): angle += 1 else : angle -= 1 last_time = new_time # now we register the handler function when the button is pressed increment_angle_button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) decrement_angle_button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) pwm . freq ( SERVO_FREQ_HZ ) old_angle = - 1 while True : # only print on change in the button_presses value if angle != old_angle : duty = ServoDuty ( angle ) print ( 'new angle:' , angle , 'duty: ' , duty ) pwm . duty_u16 ( duty ) old_angle = angle Sample Sweep Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 from machine import Pin , PWM import time BUTTON_1_PIN = 20 BUTTON_2_PIN = 21 SERVO_1_PIN = 12 SERVO_2_PIN = 13 SERVO_3_PIN = 14 SERVO_4_PIN = 15 SERVO_FREQ_HZ = 50 SERVO_MIN_DUTY = 1725 SERVO_MAX_DUTY = 6378 # this is ususlly standard across most servos SERVO_FREQ_HZ = 40 pwm = PWM ( Pin ( SERVO_2_PIN )) # the two button on the Maker Pi RP2040 clock_button_pin = machine . Pin ( BUTTON_1_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) counter_clock_button_pin = machine . Pin ( BUTTON_2_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) # globals angle = 90 last_time = 0 # the last time we pressed the button def button_pressed_handler ( pin ): global angle , last_time new_time = time . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): angle += 1 else : angle -= 1 # wrap around to first mode if mode >= mode_count : mode = 0 if mode < 0 : mode = mode_count - 1 last_time = new_time # now we register the handler function when the button is pressed clock_button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) counter_clock_button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # return int( ( (0.0015*SERVO_FREQ_HZ) + ((angle/90) * (0.0005*SERVO_FREQ_HZ)) ) * 65535 ) # Thisw will take in integers of range in (min and max) return a integer in the output range (min and max) # Used to convert one range of values into another using a linear function like the Arduino map() function def convert ( x , in_min , in_max , out_min , out_max ): return ( x - in_min ) * ( out_max - out_min ) // ( in_max - in_min ) + out_min # -90 should generate 1725 # 90 should generate 7973 old_angle = - 1 pwm . freq ( 50 ) while True : for angle in range ( - 90 , 90 ): duty = convert ( angle , - 90 , 90 , SERVO_MIN_DUTY , SERVO_MAX_DUTY ) print ( 'angle:' , angle , 'duty: ' , duty ) pwm . duty_u16 ( duty ) old_angle = angle time . sleep ( . 01 ) for angle in range ( 90 , - 90 , - 1 ): duty = convert ( angle , - 90 , 90 , SERVO_MIN_DUTY , SERVO_MAX_DUTY ) print ( 'angle:' , angle , 'duty: ' , duty ) pwm . duty_u16 ( duty ) old_angle = angle time . sleep ( . 01 ) Shutting Down All Servos 1 2 3 4 5 6 7 8 9 10 11 12 13 from machine import Pin , PWM import time SERVO_1_PIN = 12 SERVO_2_PIN = 13 SERVO_3_PIN = 14 SERVO_4_PIN = 15 print ( 'shutting down all servos!' ) for i in range ( 12 , 16 ): print ( 'Servo' , i , 'shutting down' ) pwm1 = PWM ( Pin ( SERVO_1_PIN )) pwm1 . duty_u16 ( 0 ) Adding Cleanup Code PWM signals continue to be generated even after you do a STOP/RESET on your microcontroller. This could drain batteries and wear out your servo motors. To stop the servos from getting PWM signals you can add an interrupt to your code to catch these signals and set the PWM duty cycle back to zero. This 1 References MicroPython Reference Page - this page is not very helpful. The implication is that servo controls are standardized across MicroPython system. This does not appear to be the case.","title":"Servo Lab"},{"location":"kits/maker-pi-rp2040-robot/08-servo-lab/#maker-pi-rp2040-servo-lab","text":"Servo motors are ideal for controlling the angle of an item such as a steering angle or the direction of a sensor. The servos used in these labs are inexpensive SG90 micro-servos that draw very little power and are ideal for a teaching lab. They can be purchased for about $3 each US on eBay . To control a 180 degree servo, you just tell it what angle you would like it to move to. The range of values is typically -90 to 90 degrees with 0 being the nominal resting position for many applications such as the steering wheel angle of a car. The Maker Pi RP2040 has four servo ports in the upper left corner of the board (with the USB on the bottom) that use ports GP12, GP13, GP14 and GP15. You can connect any small micro servo directly to these ports. Just make sure to get the polarity correct. The colors for servos may vary somewhat, but the two most common standards are: Orange, red and brown - signal, positive and ground White, red, black - signal, positive and ground The general rule is that the lighter colors of orange and white will be the signal and the brown and black will be ground.","title":"Maker Pi RP2040 Servo Lab"},{"location":"kits/maker-pi-rp2040-robot/08-servo-lab/#servo-control","text":"We will use the PWM functions in our MicroPython library to send a PWM signal to each of the servos. Servos are not controlled by the duty cycle directly. They are controlled by the width of the pulses. But we can control the approximate with of the pulses by holding the frequency constant and changing the duty cycle. We will use a 40 hertz signal to send a PWM signal to each of the servos like this. 1 2 3 SERVO_FREQ_HZ = 40 # SERVO_PERIOD_MS = 1000 / SERVO_FREQ_HZ is a 25 millisecond pulse width my_pwm . freq ( SERVO_FREQ_HZ )","title":"Servo Control"},{"location":"kits/maker-pi-rp2040-robot/08-servo-lab/#calibration-of-the-servo","text":"There are small manufacturing variations in servos. This means to get the full sweep of a 180% servo you have to adjust the duty cycle. Minimum duty cycle: 1700 Maximum duty cycle: 6300 By some experimentation I got the following results 1 2 SERVO_MIN_DUTY = 1725 # -90 degrees SERVO_MAX_DUTY = 6378 # 90 degrees We can use a linear mapping function to convert the angle (from -90 to 90): 1 2 3 4 5 6 7 8 9 # This will take in integers of range in (min and max) return a integer in the output range (min and max) # Used to convert one range of values into another using a linear function like the Arduino map() function def convert ( x , in_min , in_max , out_min , out_max ): return ( x - in_min ) * ( out_max - out_min ) // ( in_max - in_min ) + out_min angle = 0 duty = convert ( angle , - 90 , 90 , SERVO_MIN_DUTY , SERVO_MAX_DUTY ) print ( 'For angle: ' , angle , ' the duty is: ' , duty ) pwm . duty_u16 ( duty )","title":"Calibration of the Servo"},{"location":"kits/maker-pi-rp2040-robot/08-servo-lab/#checking-your-servo-calibration-with-buttons","text":"We can also use the buttons on the Maker Pi RP2040 to verify that the extreme angles are correct. One button will increase the angle and one will decrease the angle. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 # Maker Pi RP2040 program to check the limits of a 180 degree servo such as a SG90 micro servo from machine import Pin , PWM import time BUTTON_1_PIN = 20 # increment the angle BUTTON_2_PIN = 21 # decrement the angle SERVO_1_PIN = 12 SERVO_2_PIN = 13 # MAX=5749@40 SERVO_3_PIN = 14 SERVO_4_PIN = 15 # this is ususlly standard across most servos SERVO_FREQ_HZ = 40 pwm = PWM ( Pin ( SERVO_2_PIN )) # the two button on the Maker Pi RP2040 increment_angle_button_pin = machine . Pin ( BUTTON_1_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) decrement_angle_button_pin = machine . Pin ( BUTTON_2_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) # return int( ( (0.0015*SERVO_FREQ_HZ) + ((angle/90) * (0.0005*SERVO_FREQ_HZ)) ) * 65535 ) # This will take in integers of range in (min and max) return a integer in the output range (min and max) # Used to convert one range of values into another using a linear function like the Arduino map() function def convert ( x , in_min , in_max , out_min , out_max ): return ( x - in_min ) * ( out_max - out_min ) // ( in_max - in_min ) + out_min # globals angle = - 90 last_time = 0 # the last time we pressed the button # if the pin is 20 then increment, else decement def button_pressed_handler ( pin ): global angle , last_time new_time = time . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): angle += 1 else : angle -= 1 last_time = new_time # now we register the handler function when the button is pressed increment_angle_button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) decrement_angle_button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) pwm . freq ( SERVO_FREQ_HZ ) old_angle = - 1 while True : # only print on change in the button_presses value if angle != old_angle : duty = ServoDuty ( angle ) print ( 'new angle:' , angle , 'duty: ' , duty ) pwm . duty_u16 ( duty ) old_angle = angle","title":"Checking your Servo Calibration with Buttons"},{"location":"kits/maker-pi-rp2040-robot/08-servo-lab/#sample-sweep-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 from machine import Pin , PWM import time BUTTON_1_PIN = 20 BUTTON_2_PIN = 21 SERVO_1_PIN = 12 SERVO_2_PIN = 13 SERVO_3_PIN = 14 SERVO_4_PIN = 15 SERVO_FREQ_HZ = 50 SERVO_MIN_DUTY = 1725 SERVO_MAX_DUTY = 6378 # this is ususlly standard across most servos SERVO_FREQ_HZ = 40 pwm = PWM ( Pin ( SERVO_2_PIN )) # the two button on the Maker Pi RP2040 clock_button_pin = machine . Pin ( BUTTON_1_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) counter_clock_button_pin = machine . Pin ( BUTTON_2_PIN , machine . Pin . IN , machine . Pin . PULL_DOWN ) # globals angle = 90 last_time = 0 # the last time we pressed the button def button_pressed_handler ( pin ): global angle , last_time new_time = time . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): angle += 1 else : angle -= 1 # wrap around to first mode if mode >= mode_count : mode = 0 if mode < 0 : mode = mode_count - 1 last_time = new_time # now we register the handler function when the button is pressed clock_button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) counter_clock_button_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # return int( ( (0.0015*SERVO_FREQ_HZ) + ((angle/90) * (0.0005*SERVO_FREQ_HZ)) ) * 65535 ) # Thisw will take in integers of range in (min and max) return a integer in the output range (min and max) # Used to convert one range of values into another using a linear function like the Arduino map() function def convert ( x , in_min , in_max , out_min , out_max ): return ( x - in_min ) * ( out_max - out_min ) // ( in_max - in_min ) + out_min # -90 should generate 1725 # 90 should generate 7973 old_angle = - 1 pwm . freq ( 50 ) while True : for angle in range ( - 90 , 90 ): duty = convert ( angle , - 90 , 90 , SERVO_MIN_DUTY , SERVO_MAX_DUTY ) print ( 'angle:' , angle , 'duty: ' , duty ) pwm . duty_u16 ( duty ) old_angle = angle time . sleep ( . 01 ) for angle in range ( 90 , - 90 , - 1 ): duty = convert ( angle , - 90 , 90 , SERVO_MIN_DUTY , SERVO_MAX_DUTY ) print ( 'angle:' , angle , 'duty: ' , duty ) pwm . duty_u16 ( duty ) old_angle = angle time . sleep ( . 01 )","title":"Sample Sweep Code"},{"location":"kits/maker-pi-rp2040-robot/08-servo-lab/#shutting-down-all-servos","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 from machine import Pin , PWM import time SERVO_1_PIN = 12 SERVO_2_PIN = 13 SERVO_3_PIN = 14 SERVO_4_PIN = 15 print ( 'shutting down all servos!' ) for i in range ( 12 , 16 ): print ( 'Servo' , i , 'shutting down' ) pwm1 = PWM ( Pin ( SERVO_1_PIN )) pwm1 . duty_u16 ( 0 )","title":"Shutting Down All Servos"},{"location":"kits/maker-pi-rp2040-robot/08-servo-lab/#adding-cleanup-code","text":"PWM signals continue to be generated even after you do a STOP/RESET on your microcontroller. This could drain batteries and wear out your servo motors. To stop the servos from getting PWM signals you can add an interrupt to your code to catch these signals and set the PWM duty cycle back to zero. This 1","title":"Adding Cleanup Code"},{"location":"kits/maker-pi-rp2040-robot/08-servo-lab/#references","text":"MicroPython Reference Page - this page is not very helpful. The implication is that servo controls are standardized across MicroPython system. This does not appear to be the case.","title":"References"},{"location":"kits/maker-pi-rp2040-robot/09-i2c-scanner-test/","text":"I2C Scanner Test How do we know that our connection to the distance sensor is wired correctly? The quick way to test this is to run a program called the I2C scanner. It will return a list of all the devices it finds on the I2C bus. We first run the I2C scanner program to verify that the sensor is connected correct and is responding to the I2C bus scan. 1 2 3 4 5 6 import machine # Pins on the Grove Connector 1 on the Maker Pi RP2040 are GP0 and GP1 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"I2C device ID list:\" , i2c . scan ()) This should return a list of the devices it finds. If you just have the Time-of-Flight sensor it will look like this: 1 2 3 4 5 [41] `` ```py device_id = i2c.scan()[0] Testing for the Time-of-Flight Sensor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # i2c.scan() returns a list of devices that have been found # i2c.scan()[0] is the first device found device_id = i2c . scan ()[ 0 ] print ( \"Device found at decimal\" , device_id ) if device_id == 41 : print ( \"TEST PASS\" ) else : print ( \"No device found at decimal 41\" ) print ( \"TEST FAIL\" )","title":"Scanner Test"},{"location":"kits/maker-pi-rp2040-robot/09-i2c-scanner-test/#i2c-scanner-test","text":"How do we know that our connection to the distance sensor is wired correctly? The quick way to test this is to run a program called the I2C scanner. It will return a list of all the devices it finds on the I2C bus. We first run the I2C scanner program to verify that the sensor is connected correct and is responding to the I2C bus scan. 1 2 3 4 5 6 import machine # Pins on the Grove Connector 1 on the Maker Pi RP2040 are GP0 and GP1 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"I2C device ID list:\" , i2c . scan ()) This should return a list of the devices it finds. If you just have the Time-of-Flight sensor it will look like this: 1 2 3 4 5 [41] `` ```py device_id = i2c.scan()[0]","title":"I2C Scanner Test"},{"location":"kits/maker-pi-rp2040-robot/09-i2c-scanner-test/#testing-for-the-time-of-flight-sensor","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # i2c.scan() returns a list of devices that have been found # i2c.scan()[0] is the first device found device_id = i2c . scan ()[ 0 ] print ( \"Device found at decimal\" , device_id ) if device_id == 41 : print ( \"TEST PASS\" ) else : print ( \"No device found at decimal 41\" ) print ( \"TEST FAIL\" )","title":"Testing for the Time-of-Flight Sensor"},{"location":"kits/maker-pi-rp2040-robot/10-time-of-flight-lab/","text":"Time of Flight Distance Sensor Lab In this lab we create a program that will show the distance measured by the Time-of-Flight sensor by printing the distance on the console and also displaying the distance on 11 blue LEDs. First, make sure you have your driver for the Time-of-Flight sensor installed. You can copy the code from here and save it in the file VL53L0X.py. Note the zero between the \"L\" and \"X\" in the file name, not the letter \"O\". We use a non-linear distance scale as we get closer to an object. We store the numbers of each LED and the distance it should change in a lists: 1 2 blue_led_pins = [ 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] dist_scale = [ 2 , 6 , 10 , 20 , 30 , 40 , 50 , 60 , 80 , 110 , 150 ] Calibration There are three numbers you can change when you calibrate the sensor: 1 2 3 ZERO_DIST = 60 # The value of the sensor when an object is 0 CM away MAX_DIST = 1200 # max raw distance we are able to read SCALE_DIST = . 3 # multiplier for raw to calibrated distance in CM Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 # Demo for Maker Pi RP2040 board using the VL32L0X time of flight distance sensor # Note the driver I used came from here: https://github.com/CoderDojoTC/micropython/blob/main/src/drivers/VL53L0X.py # Perhaps derived from here: https://github.com/uceeatz/VL53L0X/blob/master/VL53L0X.py # This demo makes the blue LEDs show the distance and prints the distance on the console import machine import time import VL53L0X sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # print(\"Device found at decimal\", i2c.scan()) # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs which we can use 11 # The distance scale is non linear # GP0 and GP1 will always be on since they are the I2C Data and Clock blue_led_pins = [ 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] dist_scale = [ 2 , 6 , 10 , 20 , 30 , 40 , 50 , 60 , 80 , 110 , 150 ] number_leds = len ( blue_led_pins ) led_ports = [] delay = . 05 # initial calibration parameters ZERO_DIST = 60 MAX_DIST = 1200 # max raw distance we are able to read SCALE_DIST = . 3 # multiplier for raw to calibrated distance # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) # get the normalized time-of-flight distance def get_distance (): global zero_dist , scale_factor tof_distance = tof . read () if tof_distance > MAX_DIST : return tof_distance # if our current time-of-flight distance is lower than our zero distance then reset the zero distance if tof_distance < ZERO_DIST : zero_dist = tof_distance return int (( tof_distance - ZERO_DIST ) * SCALE_DIST ) # use the dist_scale to turn on LEDs def led_show_dist ( in_distance ): global number_leds for led_index in range ( 0 , number_leds ): if in_distance > dist_scale [ led_index ]: led_ports [ led_index ] . high () else : led_ports [ led_index ] . low () print ( 'Using' , number_leds , ' blue leds to show distance.' ) # blue up for i in range ( 0 , number_leds ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # start our time-of-flight sensor tof . start () # autocalibrate the minimum distance min_distance = 1000 # loop forever while True : raw_distance = get_distance () # recalibrate if we have a new min distance if raw_distance < min_distance : min_distance = raw_distance calibrated_distance = raw_distance - min_distance print ( raw_distance , calibrated_distance ) led_show_dist ( calibrated_distance ) time . sleep ( 0.05 ) # clean up tof . stop () References Kevin McAleer's GitHub Repo on the Vl53lx0 Kevin McAleer's 662 line driver - I am not sure we need all 662 lines of code. Kevin McAleer's Time of Flight Test","title":"Time of Flight Lab"},{"location":"kits/maker-pi-rp2040-robot/10-time-of-flight-lab/#time-of-flight-distance-sensor-lab","text":"In this lab we create a program that will show the distance measured by the Time-of-Flight sensor by printing the distance on the console and also displaying the distance on 11 blue LEDs. First, make sure you have your driver for the Time-of-Flight sensor installed. You can copy the code from here and save it in the file VL53L0X.py. Note the zero between the \"L\" and \"X\" in the file name, not the letter \"O\". We use a non-linear distance scale as we get closer to an object. We store the numbers of each LED and the distance it should change in a lists: 1 2 blue_led_pins = [ 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] dist_scale = [ 2 , 6 , 10 , 20 , 30 , 40 , 50 , 60 , 80 , 110 , 150 ]","title":"Time of Flight Distance Sensor Lab"},{"location":"kits/maker-pi-rp2040-robot/10-time-of-flight-lab/#calibration","text":"There are three numbers you can change when you calibrate the sensor: 1 2 3 ZERO_DIST = 60 # The value of the sensor when an object is 0 CM away MAX_DIST = 1200 # max raw distance we are able to read SCALE_DIST = . 3 # multiplier for raw to calibrated distance in CM","title":"Calibration"},{"location":"kits/maker-pi-rp2040-robot/10-time-of-flight-lab/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 # Demo for Maker Pi RP2040 board using the VL32L0X time of flight distance sensor # Note the driver I used came from here: https://github.com/CoderDojoTC/micropython/blob/main/src/drivers/VL53L0X.py # Perhaps derived from here: https://github.com/uceeatz/VL53L0X/blob/master/VL53L0X.py # This demo makes the blue LEDs show the distance and prints the distance on the console import machine import time import VL53L0X sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # print(\"Device found at decimal\", i2c.scan()) # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs which we can use 11 # The distance scale is non linear # GP0 and GP1 will always be on since they are the I2C Data and Clock blue_led_pins = [ 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] dist_scale = [ 2 , 6 , 10 , 20 , 30 , 40 , 50 , 60 , 80 , 110 , 150 ] number_leds = len ( blue_led_pins ) led_ports = [] delay = . 05 # initial calibration parameters ZERO_DIST = 60 MAX_DIST = 1200 # max raw distance we are able to read SCALE_DIST = . 3 # multiplier for raw to calibrated distance # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) # get the normalized time-of-flight distance def get_distance (): global zero_dist , scale_factor tof_distance = tof . read () if tof_distance > MAX_DIST : return tof_distance # if our current time-of-flight distance is lower than our zero distance then reset the zero distance if tof_distance < ZERO_DIST : zero_dist = tof_distance return int (( tof_distance - ZERO_DIST ) * SCALE_DIST ) # use the dist_scale to turn on LEDs def led_show_dist ( in_distance ): global number_leds for led_index in range ( 0 , number_leds ): if in_distance > dist_scale [ led_index ]: led_ports [ led_index ] . high () else : led_ports [ led_index ] . low () print ( 'Using' , number_leds , ' blue leds to show distance.' ) # blue up for i in range ( 0 , number_leds ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # start our time-of-flight sensor tof . start () # autocalibrate the minimum distance min_distance = 1000 # loop forever while True : raw_distance = get_distance () # recalibrate if we have a new min distance if raw_distance < min_distance : min_distance = raw_distance calibrated_distance = raw_distance - min_distance print ( raw_distance , calibrated_distance ) led_show_dist ( calibrated_distance ) time . sleep ( 0.05 ) # clean up tof . stop ()","title":"Full Program"},{"location":"kits/maker-pi-rp2040-robot/10-time-of-flight-lab/#references","text":"Kevin McAleer's GitHub Repo on the Vl53lx0 Kevin McAleer's 662 line driver - I am not sure we need all 662 lines of code. Kevin McAleer's Time of Flight Test","title":"References"},{"location":"kits/maker-pi-rp2040-robot/11-ping-lab/","text":"Ultrasonic Ping Sensor Lab The Grove sensors on our Maker Pi RP2040 only supply 3.3 volts. So the standard very popular low cost HC-SR04 will not work, since it requires 5 volts of power. We have two options. One is to get a separate 5V power source, but the other is to purchase the new HC-SR04 P (for Pico?) sensor that will work with our 3.3 volt power on our Grove connector. Using the Grove 4 connection wire the HC-SP04P sensor with the trigger on GPIO-16 (White cable) and the echo on GPIO-17 (Yellow cable), VCC (Red cable), and GND (Black cable) All wired up 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # Sample code to test HC-SR04 Ultrasonice Ping Sensor # Connect GND to any GND pin on the Pico # Connnect VCC to VBUS or 5 Volt power from machine import Pin, Timer import utime TRIGGER_PIN = 16 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 17 # One up from bottom left corner # Init HC-SR04 pins trigger = Pin(TRIGGER_PIN, Pin.OUT) # send trigger out to sensor echo = Pin(ECHO_PIN, Pin.IN) # get the delay interval back def ping(): trigger.low() utime.sleep_us(2) # Wait 2 microseconds low trigger.high() utime.sleep_us(5) # Stay high for 5 miroseconds trigger.low() while echo.value() == 0: signaloff = utime.ticks_us() while echo.value() == 1: signalon = utime.ticks_us() timepassed = signalon - signaloff distance = (timepassed * 0.0343) / 2 return distance while True: print(\"Distance:\", ping(), \"cm\") utime.sleep(.25) More advanced version with sound 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Sample code to test HC-SR04 Ultrasonice Ping Sensor # Connect GND to any GND pin on the Pico # Connnect VCC to VBUS or 5 Volt power from machine import Pin, Timer, PWM import utime TRIGGER_PIN = 16 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 17 # One up from bottom left corner # Init HC-SR04 pins trigger = Pin(TRIGGER_PIN, Pin.OUT) # send trigger out to sensor echo = Pin(ECHO_PIN, Pin.IN) # get the delay interval back BUZZER_PORT = 22 buzzer = PWM(Pin(BUZZER_PORT)) # Note the non-linear increases in frequency - note that some are louder tone_freq = [100, 150, 210, 280, 350, 450, 580, 750, 850, 950, 1000] def playtone(frequency): buzzer.duty_u16(1000) buzzer.freq(frequency) def bequiet(): buzzer.duty_u16(0) def ping(): trigger.low() utime.sleep_us(2) # Wait 2 microseconds low trigger.high() utime.sleep_us(5) # Stay high for 5 miroseconds trigger.low() while echo.value() == 0: signaloff = utime.ticks_us() while echo.value() == 1: signalon = utime.ticks_us() timepassed = signalon - signaloff distance = (timepassed * 0.0343) / 2 return distance while True: dist=round(ping()) print(\"Distance:\", dist, \"cm\") if dist < 20: print(\"Panic\") playtone(350) # Beep faster the closer you get utime.sleep(.05/(20/dist)) bequiet() utime.sleep(.1) Link to Sample Ping Lab This code is very similar to the previous ping lab but with the different GPIO lines used. Link to Standard Ping Lab","title":"Ultrasonic Ping Lab"},{"location":"kits/maker-pi-rp2040-robot/11-ping-lab/#ultrasonic-ping-sensor-lab","text":"The Grove sensors on our Maker Pi RP2040 only supply 3.3 volts. So the standard very popular low cost HC-SR04 will not work, since it requires 5 volts of power. We have two options. One is to get a separate 5V power source, but the other is to purchase the new HC-SR04 P (for Pico?) sensor that will work with our 3.3 volt power on our Grove connector. Using the Grove 4 connection wire the HC-SP04P sensor with the trigger on GPIO-16 (White cable) and the echo on GPIO-17 (Yellow cable), VCC (Red cable), and GND (Black cable) All wired up 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # Sample code to test HC-SR04 Ultrasonice Ping Sensor # Connect GND to any GND pin on the Pico # Connnect VCC to VBUS or 5 Volt power from machine import Pin, Timer import utime TRIGGER_PIN = 16 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 17 # One up from bottom left corner # Init HC-SR04 pins trigger = Pin(TRIGGER_PIN, Pin.OUT) # send trigger out to sensor echo = Pin(ECHO_PIN, Pin.IN) # get the delay interval back def ping(): trigger.low() utime.sleep_us(2) # Wait 2 microseconds low trigger.high() utime.sleep_us(5) # Stay high for 5 miroseconds trigger.low() while echo.value() == 0: signaloff = utime.ticks_us() while echo.value() == 1: signalon = utime.ticks_us() timepassed = signalon - signaloff distance = (timepassed * 0.0343) / 2 return distance while True: print(\"Distance:\", ping(), \"cm\") utime.sleep(.25) More advanced version with sound 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Sample code to test HC-SR04 Ultrasonice Ping Sensor # Connect GND to any GND pin on the Pico # Connnect VCC to VBUS or 5 Volt power from machine import Pin, Timer, PWM import utime TRIGGER_PIN = 16 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 17 # One up from bottom left corner # Init HC-SR04 pins trigger = Pin(TRIGGER_PIN, Pin.OUT) # send trigger out to sensor echo = Pin(ECHO_PIN, Pin.IN) # get the delay interval back BUZZER_PORT = 22 buzzer = PWM(Pin(BUZZER_PORT)) # Note the non-linear increases in frequency - note that some are louder tone_freq = [100, 150, 210, 280, 350, 450, 580, 750, 850, 950, 1000] def playtone(frequency): buzzer.duty_u16(1000) buzzer.freq(frequency) def bequiet(): buzzer.duty_u16(0) def ping(): trigger.low() utime.sleep_us(2) # Wait 2 microseconds low trigger.high() utime.sleep_us(5) # Stay high for 5 miroseconds trigger.low() while echo.value() == 0: signaloff = utime.ticks_us() while echo.value() == 1: signalon = utime.ticks_us() timepassed = signalon - signaloff distance = (timepassed * 0.0343) / 2 return distance while True: dist=round(ping()) print(\"Distance:\", dist, \"cm\") if dist < 20: print(\"Panic\") playtone(350) # Beep faster the closer you get utime.sleep(.05/(20/dist)) bequiet() utime.sleep(.1)","title":"Ultrasonic Ping Sensor Lab"},{"location":"kits/maker-pi-rp2040-robot/11-ping-lab/#link-to-sample-ping-lab","text":"This code is very similar to the previous ping lab but with the different GPIO lines used. Link to Standard Ping Lab","title":"Link to Sample Ping Lab"},{"location":"kits/maker-pi-rp2040-robot/12-time-of-flight-sound-lab/","text":"Time of Flight Distance Sensor Test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 # Demo for Maker Pi RP2040 board from machine import Pin , PWM import time import VL53L0X buzzer = PWM ( Pin ( 22 )) sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # print(\"Device found at decimal\", i2c.scan()) # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs blue_led_pins = [ 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] # dist_scale = [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100] dist_scale = [ 2 , 4 , 6 , 8 , 10 , 15 , 20 , 25 , 50 , 100 , 150 , 200 , 300 ] number_leds = len ( blue_led_pins ) led_ports = [] delay = . 05 # calibration parameters zero_dist = 65 # distance measure when an object is about 1/2 cm away max_dist = 350 # max distance we are able to read scale_factor = . 2 # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) # blue up for i in range ( 0 , number_leds ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # get the normalized time-of-flight distance def get_distance (): global zero_dist , scale_factor tof_distance = tof . read () if tof_distance > max_dist : return tof_distance # if our current time-of-flight distance is lower than our zero distance then reset the zero distance if tof_distance < zero_dist : zero_dist = tof_distance return int (( tof_distance - zero_dist ) * scale_factor ) def led_show_dist ( in_distance ): global number_leds for led_index in range ( 0 , number_leds ): if in_distance > dist_scale [ led_index ]: led_ports [ led_index ] . high () else : led_ports [ led_index ] . low () def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) def play_no_signal (): playtone ( 100 ) time . sleep ( 0.1 ) bequiet () def play_turn (): playtone ( 500 ) time . sleep ( 0.1 ) bequiet () # start our time-of-flight sensor tof . start () valid_distance = 1 # loop forever def main (): while True : global valid_distance distance = get_distance () if distance > 1000 : # only print if we used to have a valid distance if valid_distance == 1 : print ( 'no signal' ) valid_distance = 0 else : print ( distance ) if distance < 30 : play_turn () valid_distance = 1 led_show_dist ( distance ) time . sleep ( 0.05 ) # clean up # This allows us to stop the sound by doing a Stop or Control-C which is a keyboard intrrup try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'turning off sound' ) buzzer . duty_u16 ( 0 ) tof . stop ()","title":"Time of Flight Sound Lab"},{"location":"kits/maker-pi-rp2040-robot/12-time-of-flight-sound-lab/#time-of-flight-distance-sensor-test","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 # Demo for Maker Pi RP2040 board from machine import Pin , PWM import time import VL53L0X buzzer = PWM ( Pin ( 22 )) sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # print(\"Device found at decimal\", i2c.scan()) # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs blue_led_pins = [ 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] # dist_scale = [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100] dist_scale = [ 2 , 4 , 6 , 8 , 10 , 15 , 20 , 25 , 50 , 100 , 150 , 200 , 300 ] number_leds = len ( blue_led_pins ) led_ports = [] delay = . 05 # calibration parameters zero_dist = 65 # distance measure when an object is about 1/2 cm away max_dist = 350 # max distance we are able to read scale_factor = . 2 # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) # blue up for i in range ( 0 , number_leds ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # get the normalized time-of-flight distance def get_distance (): global zero_dist , scale_factor tof_distance = tof . read () if tof_distance > max_dist : return tof_distance # if our current time-of-flight distance is lower than our zero distance then reset the zero distance if tof_distance < zero_dist : zero_dist = tof_distance return int (( tof_distance - zero_dist ) * scale_factor ) def led_show_dist ( in_distance ): global number_leds for led_index in range ( 0 , number_leds ): if in_distance > dist_scale [ led_index ]: led_ports [ led_index ] . high () else : led_ports [ led_index ] . low () def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) def play_no_signal (): playtone ( 100 ) time . sleep ( 0.1 ) bequiet () def play_turn (): playtone ( 500 ) time . sleep ( 0.1 ) bequiet () # start our time-of-flight sensor tof . start () valid_distance = 1 # loop forever def main (): while True : global valid_distance distance = get_distance () if distance > 1000 : # only print if we used to have a valid distance if valid_distance == 1 : print ( 'no signal' ) valid_distance = 0 else : print ( distance ) if distance < 30 : play_turn () valid_distance = 1 led_show_dist ( distance ) time . sleep ( 0.05 ) # clean up # This allows us to stop the sound by doing a Stop or Control-C which is a keyboard intrrup try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'turning off sound' ) buzzer . duty_u16 ( 0 ) tof . stop ()","title":"Time of Flight Distance Sensor Test"},{"location":"kits/maker-pi-rp2040-robot/20-collision-avoidance-robot/","text":"Maker Pi RP2040 Collision Avoidance Robot This robot works very similar to our standard CoderDojo Collision Avoidance Robot but all the pins are now configured to use the connections on the Maker Pi RP2040 board. The board is mounted on a SmartCar Chassis and Grove Connector 0 is used to connect to a Time-of-Flight distance sensor that is using the I2C bus. Random Turn Direction 1 2 3 4 5 6 7 8 9 10 11 12 13 if dist < TURN_DIST : play_reverse () reverse () sleep ( REVERSE_TIME ) # half right and half left turns if urandom . random () < . 5 : turn_right () play_turn_right () else : turn_left () play_turn_left () sleep ( TURN_TIME ) forward () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 # Demo for Maker Pi RP2040 board from machine import Pin , PWM from time import sleep , sleep_ms import urandom import VL53L0X # Piezo Buzzer is on GP22 buzzer = PWM ( Pin ( 22 )) # this is the max power level POWER_LEVEL = 65025 # Motor Pins are A: 8,9 and B: 10,11 RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 # our PWM objects right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def turn_motor_on ( pwm ): pwm . duty_u16 ( 65025 ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) # Time of flight sensor is on the I2C bus on Grove connector 0 sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # print(\"Device found at decimal\", i2c.scan()) # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs blue_led_pins = [ 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] # dist_scale = [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100] dist_scale = [ 2 , 4 , 6 , 8 , 10 , 15 , 20 , 25 , 50 , 100 , 150 , 200 , 300 ] number_leds = len ( blue_led_pins ) led_ports = [] delay = . 05 # calibration parameters zero_dist = 65 # distance measure when an object is about 1/2 cm away max_dist = 350 # max distance we are able to read scale_factor = . 2 # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) # blue up for i in range ( 0 , number_leds ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # get the normalized time-of-flight distance def get_distance (): global zero_dist , scale_factor tof_distance = tof . read () if tof_distance > max_dist : return tof_distance # if our current time-of-flight distance is lower than our zero distance then reset the zero distance if tof_distance < zero_dist : zero_dist = tof_distance return int (( tof_distance - zero_dist ) * scale_factor ) def led_show_dist ( in_distance ): global number_leds for led_index in range ( 0 , number_leds ): if in_distance > dist_scale [ led_index ]: led_ports [ led_index ] . high () else : led_ports [ led_index ] . low () def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) def play_no_signal (): playtone ( 100 ) time . sleep ( 0.1 ) bequiet () def play_turn (): playtone ( 500 ) sleep ( 0.1 ) bequiet () # start our time-of-flight sensor tof . start () valid_distance = 1 # loop forever def main (): global valid_distance while True : distance = get_distance () if distance > 1000 : # only print if we used to have a valid distance if valid_distance == 1 : print ( 'no signal' ) valid_distance = 0 else : print ( distance ) if distance < 30 : play_turn () # back up for 1/2 second reverse () sleep ( 0.5 ) turn_right () sleep ( 0.75 ) forward () else : print ( 'forward' ) forward () valid_distance = 1 led_show_dist ( distance ) sleep ( 0.05 ) # clean up # This allows us to stop the sound by doing a Stop or Control-C which is a keyboard intrrup try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'turning off sound' ) buzzer . duty_u16 ( 0 ) print ( 'powering down all motors' ) stop () print ( 'stopping time of flight sensor' ) tof . stop ()","title":"Collision Avoidance Time-of-Flight"},{"location":"kits/maker-pi-rp2040-robot/20-collision-avoidance-robot/#maker-pi-rp2040-collision-avoidance-robot","text":"This robot works very similar to our standard CoderDojo Collision Avoidance Robot but all the pins are now configured to use the connections on the Maker Pi RP2040 board. The board is mounted on a SmartCar Chassis and Grove Connector 0 is used to connect to a Time-of-Flight distance sensor that is using the I2C bus.","title":"Maker Pi RP2040 Collision Avoidance Robot"},{"location":"kits/maker-pi-rp2040-robot/20-collision-avoidance-robot/#random-turn-direction","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 if dist < TURN_DIST : play_reverse () reverse () sleep ( REVERSE_TIME ) # half right and half left turns if urandom . random () < . 5 : turn_right () play_turn_right () else : turn_left () play_turn_left () sleep ( TURN_TIME ) forward () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 # Demo for Maker Pi RP2040 board from machine import Pin , PWM from time import sleep , sleep_ms import urandom import VL53L0X # Piezo Buzzer is on GP22 buzzer = PWM ( Pin ( 22 )) # this is the max power level POWER_LEVEL = 65025 # Motor Pins are A: 8,9 and B: 10,11 RIGHT_FORWARD_PIN = 8 RIGHT_REVERSE_PIN = 9 LEFT_FORWARD_PIN = 11 LEFT_REVERSE_PIN = 10 # our PWM objects right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def turn_motor_on ( pwm ): pwm . duty_u16 ( 65025 ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) # Time of flight sensor is on the I2C bus on Grove connector 0 sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # print(\"Device found at decimal\", i2c.scan()) # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs blue_led_pins = [ 2 , 3 , 4 , 5 , 6 , 7 , 16 , 17 , 26 , 27 , 28 ] # dist_scale = [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100] dist_scale = [ 2 , 4 , 6 , 8 , 10 , 15 , 20 , 25 , 50 , 100 , 150 , 200 , 300 ] number_leds = len ( blue_led_pins ) led_ports = [] delay = . 05 # calibration parameters zero_dist = 65 # distance measure when an object is about 1/2 cm away max_dist = 350 # max distance we are able to read scale_factor = . 2 # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) # blue up for i in range ( 0 , number_leds ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () time . sleep ( delay ) led_ports [ i ] . low () # get the normalized time-of-flight distance def get_distance (): global zero_dist , scale_factor tof_distance = tof . read () if tof_distance > max_dist : return tof_distance # if our current time-of-flight distance is lower than our zero distance then reset the zero distance if tof_distance < zero_dist : zero_dist = tof_distance return int (( tof_distance - zero_dist ) * scale_factor ) def led_show_dist ( in_distance ): global number_leds for led_index in range ( 0 , number_leds ): if in_distance > dist_scale [ led_index ]: led_ports [ led_index ] . high () else : led_ports [ led_index ] . low () def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) def play_no_signal (): playtone ( 100 ) time . sleep ( 0.1 ) bequiet () def play_turn (): playtone ( 500 ) sleep ( 0.1 ) bequiet () # start our time-of-flight sensor tof . start () valid_distance = 1 # loop forever def main (): global valid_distance while True : distance = get_distance () if distance > 1000 : # only print if we used to have a valid distance if valid_distance == 1 : print ( 'no signal' ) valid_distance = 0 else : print ( distance ) if distance < 30 : play_turn () # back up for 1/2 second reverse () sleep ( 0.5 ) turn_right () sleep ( 0.75 ) forward () else : print ( 'forward' ) forward () valid_distance = 1 led_show_dist ( distance ) sleep ( 0.05 ) # clean up # This allows us to stop the sound by doing a Stop or Control-C which is a keyboard intrrup try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'turning off sound' ) buzzer . duty_u16 ( 0 ) print ( 'powering down all motors' ) stop () print ( 'stopping time of flight sensor' ) tof . stop ()","title":"Random Turn Direction"},{"location":"kits/maker-pi-rp2040-robot/21-collision-avoidance-ping/","text":"Maker Pi RP2040 Collision Avoidance Robot With Ping Sensor This robot works very similar to our standard CoderDojo Collision Avoidance Robot but all the pins are now configured to use the connections on the Maker Pi RP2040 board. The board is mounted on a SmartCar Chassis and Grove Connector 4 is used to connect the ultrasonic ping sensor. Connect the Trigger on white and Echo on yellow. The black should be connected to GND and the Red is connected to the VCC which on the The robot has an initial mode of 0, which will run the blue LEDs and change colors on the Neopixels. By pressing the on-board button you will start the collision avoidance program. Robot Parameters There are four different robot parameters you can adjust. They change the speed and distance before the robot backs up. You can also adjust the time the robots goes into reverse and the time it turns. 1 2 3 4 POWER_LEVEL = 35000 # max is TURN_DISTANCE = 20 # distance in cm we decide to turn - try 20 REVERSE_TIME = . 4 # how long we backup TURN_TIME = . 4 # how long we turn Full Source Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 # Demo for Maker Pi RP2040 board using Ping sensor from machine import Pin , PWM , Timer import utime import urandom from neopixel import Neopixel # Adjust these parameters to tune the collision avoidance behavior POWER_LEVEL = 35000 TURN_DISTANCE = 20 # distance we decide to turn - try 20 REVERSE_TIME = . 4 # how long we backup TURN_TIME = . 4 # how long we turn # startup mode is 0 - motors off and LEDs flashing # mode 1 is slow # mode 2 is medium # mode 3 is fast mode = 0 # Use the Grove 4 Connector and put trigger on white and echo on yellow TRIGGER_PIN = 16 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 17 # One up from bottom left corner # Init HC-SR04P pins trigger = Pin ( TRIGGER_PIN , Pin . OUT ) # send trigger out to sensor echo = Pin ( ECHO_PIN , Pin . IN ) # get the delay interval back faster_pin = machine . Pin ( 20 , machine . Pin . IN , machine . Pin . PULL_DOWN ) slower_pin = machine . Pin ( 21 , machine . Pin . IN , machine . Pin . PULL_DOWN ) last_time = 0 # the last time we pressed the button # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global mode , last_time new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): mode += 1 else : mode -= 1 # deal with ends if mode > 4 : mode = 2 if mode < 0 : mode = 0 last_time = new_time # now we register the handler function when the button is pressed faster_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) slower_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # Piezo Buzzer is on GP22 buzzer = PWM ( Pin ( 22 )) MAX_POWER_LEVEL = 65025 MAX_DISTANCE = 100 # ignore anything above this # Motor Pins are A: 8,9 and B: 10,11 RIGHT_FORWARD_PIN = 11 RIGHT_REVERSE_PIN = 10 LEFT_FORWARD_PIN = 9 LEFT_REVERSE_PIN = 8 # our PWM objects right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # returns distance in cm def ping (): print ( 'in ping' ) trigger . low () utime . sleep_us ( 2 ) # Wait 2 microseconds low trigger . high () utime . sleep_us ( 5 ) # Stay high for 5 miroseconds trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () print ( 'echo is 1' ) while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 print ( distance ) return int ( distance ) def turn_motor_on ( pwm ): pwm . duty_u16 ( 65025 ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs # remove 16 and 17 since the are used for the ping sensor blue_led_pins = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 26 , 27 , 28 ] # dist_scale = [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100] dist_scale = [ 2 , 4 , 6 , 8 , 10 , 15 , 20 , 25 , 50 , 100 , 150 , 200 , 300 ] NUMBER_PIXELS = 2 STATE_MACHINE = 0 NEOPIXEL_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , NEOPIXEL_PIN , \"GRB\" ) strip . brightness ( 100 ) number_leds = len ( blue_led_pins ) led_ports = [] red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink cyan = ( 0 , 255 , 255 ) lightgreen = ( 100 , 255 , 100 ) white = ( 128 , 128 , 128 ) # not too bright pink = ( 255 , 128 , 128 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' , 'cyan' , 'lightgreen' , 'white' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , lightgreen , white , pink ) # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) LED_DELAY = . 08 def run_lights (): for i in range ( 0 , number_leds ): led_ports [ i ] . high () strip . set_pixel ( 0 , colors [ i ]) strip . set_pixel ( 1 , colors [ i ]) strip . show () utime . sleep ( LED_DELAY ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () strip . set_pixel ( 0 , colors [ i ]) strip . set_pixel ( 1 , colors [ i ]) strip . show () utime . sleep ( LED_DELAY ) led_ports [ i ] . low () def led_show_dist ( in_distance ): global number_leds for led_index in range ( 0 , number_leds ): if in_distance > dist_scale [ led_index ]: led_ports [ led_index ] . high () else : led_ports [ led_index ] . low () def play_no_signal (): playnote ( 100 , 0.1 ) sound_off () def play_turn (): playnote ( 500 , . 1 ) sound_off () def setfreq ( frequency ): buzzer . freq ( frequency ) def playnote ( frequency , time ): buzzer . duty_u16 ( 1000 ) setfreq ( frequency ) utime . sleep ( time ) def sound_off (): buzzer . duty_u16 ( 0 ) def rest ( time ): buzzer . duty_u16 ( 0 ) utime . sleep ( time ) def play_startup (): playnote ( 600 , . 2 ) rest ( . 05 ) playnote ( 600 , . 2 ) rest ( . 05 ) playnote ( 600 , . 2 ) rest ( . 1 ) playnote ( 800 , . 4 ) sound_off () valid_distance = 1 # loop forever def main (): global valid_distance print ( \"running main()\" ) play_startup () while True : if mode == 0 : stop () run_lights () else : distance = ping () print ( 'Distance:' , distance ) if distance > MAX_DISTANCE : # only print if we used to have a valid distance if valid_distance == 1 : print ( 'no signal' ) valid_distance = 0 else : print ( distance ) if distance < TURN_DISTANCE : play_turn () # back up for a bit reverse () utime . sleep ( REVERSE_TIME ) # half right and half left turns if urandom . random () < . 5 : turn_right () else : turn_left () utime . sleep ( TURN_TIME ) forward () else : print ( 'forward' ) forward () valid_distance = 1 led_show_dist ( distance ) utime . sleep ( 0.05 ) # clean up # This allows us to stop the sound and motors when we do a Stop or Control-C which is a keyboard interrupt try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'turning off sound' ) buzzer . duty_u16 ( 0 ) print ( 'shutting motors down' ) stop () Experiments Adjust the power level and the distance before turning. See how these change the performance of the robot. Adjust the angle of the ping sensor by gently heating the plexiglass holder. How does this change the robot behavior? Add additional modes that change the power and the turn distance. You can have one mode for slow, one for medium and one for fast. Change the Neopixel colors to indicate the distance to an object. Change the pattern of the blue LEDs to indicate the distance to the object.","title":"Collision Avoidance Ping"},{"location":"kits/maker-pi-rp2040-robot/21-collision-avoidance-ping/#maker-pi-rp2040-collision-avoidance-robot-with-ping-sensor","text":"This robot works very similar to our standard CoderDojo Collision Avoidance Robot but all the pins are now configured to use the connections on the Maker Pi RP2040 board. The board is mounted on a SmartCar Chassis and Grove Connector 4 is used to connect the ultrasonic ping sensor. Connect the Trigger on white and Echo on yellow. The black should be connected to GND and the Red is connected to the VCC which on the The robot has an initial mode of 0, which will run the blue LEDs and change colors on the Neopixels. By pressing the on-board button you will start the collision avoidance program.","title":"Maker Pi RP2040 Collision Avoidance Robot With Ping Sensor"},{"location":"kits/maker-pi-rp2040-robot/21-collision-avoidance-ping/#robot-parameters","text":"There are four different robot parameters you can adjust. They change the speed and distance before the robot backs up. You can also adjust the time the robots goes into reverse and the time it turns. 1 2 3 4 POWER_LEVEL = 35000 # max is TURN_DISTANCE = 20 # distance in cm we decide to turn - try 20 REVERSE_TIME = . 4 # how long we backup TURN_TIME = . 4 # how long we turn","title":"Robot Parameters"},{"location":"kits/maker-pi-rp2040-robot/21-collision-avoidance-ping/#full-source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 # Demo for Maker Pi RP2040 board using Ping sensor from machine import Pin , PWM , Timer import utime import urandom from neopixel import Neopixel # Adjust these parameters to tune the collision avoidance behavior POWER_LEVEL = 35000 TURN_DISTANCE = 20 # distance we decide to turn - try 20 REVERSE_TIME = . 4 # how long we backup TURN_TIME = . 4 # how long we turn # startup mode is 0 - motors off and LEDs flashing # mode 1 is slow # mode 2 is medium # mode 3 is fast mode = 0 # Use the Grove 4 Connector and put trigger on white and echo on yellow TRIGGER_PIN = 16 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 17 # One up from bottom left corner # Init HC-SR04P pins trigger = Pin ( TRIGGER_PIN , Pin . OUT ) # send trigger out to sensor echo = Pin ( ECHO_PIN , Pin . IN ) # get the delay interval back faster_pin = machine . Pin ( 20 , machine . Pin . IN , machine . Pin . PULL_DOWN ) slower_pin = machine . Pin ( 21 , machine . Pin . IN , machine . Pin . PULL_DOWN ) last_time = 0 # the last time we pressed the button # This function gets called every time the button is pressed. The parameter \"pin\" is not used. def button_pressed_handler ( pin ): global mode , last_time new_time = utime . ticks_ms () # if it has been more that 1/5 of a second since the last event, we have a new event if ( new_time - last_time ) > 200 : # this should be pin.id but it does not work if '20' in str ( pin ): mode += 1 else : mode -= 1 # deal with ends if mode > 4 : mode = 2 if mode < 0 : mode = 0 last_time = new_time # now we register the handler function when the button is pressed faster_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) slower_pin . irq ( trigger = machine . Pin . IRQ_FALLING , handler = button_pressed_handler ) # Piezo Buzzer is on GP22 buzzer = PWM ( Pin ( 22 )) MAX_POWER_LEVEL = 65025 MAX_DISTANCE = 100 # ignore anything above this # Motor Pins are A: 8,9 and B: 10,11 RIGHT_FORWARD_PIN = 11 RIGHT_REVERSE_PIN = 10 LEFT_FORWARD_PIN = 9 LEFT_REVERSE_PIN = 8 # our PWM objects right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # returns distance in cm def ping (): print ( 'in ping' ) trigger . low () utime . sleep_us ( 2 ) # Wait 2 microseconds low trigger . high () utime . sleep_us ( 5 ) # Stay high for 5 miroseconds trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () print ( 'echo is 1' ) while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 print ( distance ) return int ( distance ) def turn_motor_on ( pwm ): pwm . duty_u16 ( 65025 ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) # The Maker Pi RP2040 has 13 fantastic blue GPIO status LEDs # remove 16 and 17 since the are used for the ping sensor blue_led_pins = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 26 , 27 , 28 ] # dist_scale = [2, 4, 6, 8, 10, 13, 16, 20, 25, 35, 50, 75, 100] dist_scale = [ 2 , 4 , 6 , 8 , 10 , 15 , 20 , 25 , 50 , 100 , 150 , 200 , 300 ] NUMBER_PIXELS = 2 STATE_MACHINE = 0 NEOPIXEL_PIN = 18 # The Neopixels on the Maker Pi RP2040 are the GRB variety, not RGB strip = Neopixel ( NUMBER_PIXELS , STATE_MACHINE , NEOPIXEL_PIN , \"GRB\" ) strip . brightness ( 100 ) number_leds = len ( blue_led_pins ) led_ports = [] red = ( 255 , 0 , 0 ) orange = ( 255 , 60 , 0 ) # Gamma corrected from G=128 to be less like yellow yellow = ( 255 , 150 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) # purple? violet = ( 138 , 43 , 226 ) # mostly pink cyan = ( 0 , 255 , 255 ) lightgreen = ( 100 , 255 , 100 ) white = ( 128 , 128 , 128 ) # not too bright pink = ( 255 , 128 , 128 ) color_names = ( 'red' , 'orange' , 'yellow' , 'green' , 'blue' , 'indigo' , 'violet' , 'cyan' , 'lightgreen' , 'white' ) num_colors = len ( color_names ) colors = ( red , orange , yellow , green , blue , indigo , violet , cyan , lightgreen , white , pink ) # create a list of the ports for i in range ( number_leds ): led_ports . append ( machine . Pin ( blue_led_pins [ i ], machine . Pin . OUT )) LED_DELAY = . 08 def run_lights (): for i in range ( 0 , number_leds ): led_ports [ i ] . high () strip . set_pixel ( 0 , colors [ i ]) strip . set_pixel ( 1 , colors [ i ]) strip . show () utime . sleep ( LED_DELAY ) led_ports [ i ] . low () # blue down for i in range ( number_leds - 1 , 0 , - 1 ): led_ports [ i ] . high () strip . set_pixel ( 0 , colors [ i ]) strip . set_pixel ( 1 , colors [ i ]) strip . show () utime . sleep ( LED_DELAY ) led_ports [ i ] . low () def led_show_dist ( in_distance ): global number_leds for led_index in range ( 0 , number_leds ): if in_distance > dist_scale [ led_index ]: led_ports [ led_index ] . high () else : led_ports [ led_index ] . low () def play_no_signal (): playnote ( 100 , 0.1 ) sound_off () def play_turn (): playnote ( 500 , . 1 ) sound_off () def setfreq ( frequency ): buzzer . freq ( frequency ) def playnote ( frequency , time ): buzzer . duty_u16 ( 1000 ) setfreq ( frequency ) utime . sleep ( time ) def sound_off (): buzzer . duty_u16 ( 0 ) def rest ( time ): buzzer . duty_u16 ( 0 ) utime . sleep ( time ) def play_startup (): playnote ( 600 , . 2 ) rest ( . 05 ) playnote ( 600 , . 2 ) rest ( . 05 ) playnote ( 600 , . 2 ) rest ( . 1 ) playnote ( 800 , . 4 ) sound_off () valid_distance = 1 # loop forever def main (): global valid_distance print ( \"running main()\" ) play_startup () while True : if mode == 0 : stop () run_lights () else : distance = ping () print ( 'Distance:' , distance ) if distance > MAX_DISTANCE : # only print if we used to have a valid distance if valid_distance == 1 : print ( 'no signal' ) valid_distance = 0 else : print ( distance ) if distance < TURN_DISTANCE : play_turn () # back up for a bit reverse () utime . sleep ( REVERSE_TIME ) # half right and half left turns if urandom . random () < . 5 : turn_right () else : turn_left () utime . sleep ( TURN_TIME ) forward () else : print ( 'forward' ) forward () valid_distance = 1 led_show_dist ( distance ) utime . sleep ( 0.05 ) # clean up # This allows us to stop the sound and motors when we do a Stop or Control-C which is a keyboard interrupt try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'turning off sound' ) buzzer . duty_u16 ( 0 ) print ( 'shutting motors down' ) stop ()","title":"Full Source Code"},{"location":"kits/maker-pi-rp2040-robot/21-collision-avoidance-ping/#experiments","text":"Adjust the power level and the distance before turning. See how these change the performance of the robot. Adjust the angle of the ping sensor by gently heating the plexiglass holder. How does this change the robot behavior? Add additional modes that change the power and the turn distance. You can have one mode for slow, one for medium and one for fast. Change the Neopixel colors to indicate the distance to an object. Change the pattern of the blue LEDs to indicate the distance to the object.","title":"Experiments"},{"location":"kits/maker-pi-rp2040-robot/23-microswitch-bot/","text":"MicroSwitch Robot using the Cytron Maker Pi RP2040 This robot was inspired by my friend, Michael York. Microswitches can be purchased for under $1 . They can be mounted on the front of our robot. When the robot hits a wall in front of it the switch will open (or close) and the robot controller can make the robot go in reverse or turn. In the example below, we attached a stiff wire to the lever of the microswitch. In the example below, we connected three microswitches to the front of our robot. If the left switch is activated, the robot should turn to the right. If the right switch is activated, the robot should go to the left. This image shows how we used two of the Grove connectors to read in the values of the switches. Testing Switches The following code can be used to test your switches. A line on the console prints out which of the three switches are activated using the pin value() function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from machine import Pin from time import sleep # GPIO is the internal built-in LED led0 = Pin ( 0 , Pin . OUT ) led1 = Pin ( 1 , Pin . OUT ) led2 = Pin ( 2 , Pin . OUT ) # input on the lower left of the Pico using a built-in pull-down resistor to keep the value from floating middle_switch = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right_switch = Pin ( 28 , Pin . IN , Pin . PULL_DOWN ) left_switch = Pin ( 27 , Pin . IN , Pin . PULL_DOWN ) while True : if middle_switch . value (): # if the value changes led0 . on () print ( 'middle' ) else : led0 . off () if right_switch . value (): # if the value changes led1 . on () print ( 'right' ) else : led1 . off () if left_switch . value (): # if the value changes led2 . on () print ( 'left' ) else : led2 . off () sleep ( . 1 ) Sample Collision Avoidance Robot Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 from machine import Pin , PWM from time import sleep # GPIO is the internal built-in LED led0 = Pin ( 0 , Pin . OUT ) led1 = Pin ( 1 , Pin . OUT ) led2 = Pin ( 2 , Pin . OUT ) # input on the lower left of the Pico using a built-in pull-down resistor to keep the value from floating middle_switch = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right_switch = Pin ( 28 , Pin . IN , Pin . PULL_DOWN ) left_switch = Pin ( 27 , Pin . IN , Pin . PULL_DOWN ) # Go slow to avoid bending wires POWER_LEVEL = 25000 # max is 65000 # These values depend on motor wiring RIGHT_FORWARD_PIN = 10 RIGHT_REVERSE_PIN = 11 LEFT_FORWARD_PIN = 9 LEFT_REVERSE_PIN = 8 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) def main (): while True : if middle_switch . value (): # if the value changes print ( 'middle' ) led0 . on () reverse () sleep ( 1 ) turn_right () sleep ( . 75 ) forward () else : led0 . off () forward () if right_switch . value (): # if the value changes print ( 'right' ) led1 . on () reverse () sleep ( . 75 ) turn_left () sleep ( . 5 ) forward () else : led1 . off () forward () if left_switch . value (): # if the value changes led2 . on () print ( 'left' ) reverse () sleep ( . 75 ) turn_right () sleep ( . 5 ) forward () else : led2 . off () forward () print ( 'middle' , middle_switch . value ()) print ( 'left' , left_switch . value ()) print ( 'right' , right_switch . value ()) try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'turning off sound' ) # sound_off() print ( 'turning off motors' ) stop ()","title":"MicroSwitch Bot"},{"location":"kits/maker-pi-rp2040-robot/23-microswitch-bot/#microswitch-robot-using-the-cytron-maker-pi-rp2040","text":"This robot was inspired by my friend, Michael York. Microswitches can be purchased for under $1 . They can be mounted on the front of our robot. When the robot hits a wall in front of it the switch will open (or close) and the robot controller can make the robot go in reverse or turn. In the example below, we attached a stiff wire to the lever of the microswitch. In the example below, we connected three microswitches to the front of our robot. If the left switch is activated, the robot should turn to the right. If the right switch is activated, the robot should go to the left. This image shows how we used two of the Grove connectors to read in the values of the switches.","title":"MicroSwitch Robot using the Cytron Maker Pi RP2040"},{"location":"kits/maker-pi-rp2040-robot/23-microswitch-bot/#testing-switches","text":"The following code can be used to test your switches. A line on the console prints out which of the three switches are activated using the pin value() function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from machine import Pin from time import sleep # GPIO is the internal built-in LED led0 = Pin ( 0 , Pin . OUT ) led1 = Pin ( 1 , Pin . OUT ) led2 = Pin ( 2 , Pin . OUT ) # input on the lower left of the Pico using a built-in pull-down resistor to keep the value from floating middle_switch = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right_switch = Pin ( 28 , Pin . IN , Pin . PULL_DOWN ) left_switch = Pin ( 27 , Pin . IN , Pin . PULL_DOWN ) while True : if middle_switch . value (): # if the value changes led0 . on () print ( 'middle' ) else : led0 . off () if right_switch . value (): # if the value changes led1 . on () print ( 'right' ) else : led1 . off () if left_switch . value (): # if the value changes led2 . on () print ( 'left' ) else : led2 . off () sleep ( . 1 )","title":"Testing Switches"},{"location":"kits/maker-pi-rp2040-robot/23-microswitch-bot/#sample-collision-avoidance-robot-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 from machine import Pin , PWM from time import sleep # GPIO is the internal built-in LED led0 = Pin ( 0 , Pin . OUT ) led1 = Pin ( 1 , Pin . OUT ) led2 = Pin ( 2 , Pin . OUT ) # input on the lower left of the Pico using a built-in pull-down resistor to keep the value from floating middle_switch = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right_switch = Pin ( 28 , Pin . IN , Pin . PULL_DOWN ) left_switch = Pin ( 27 , Pin . IN , Pin . PULL_DOWN ) # Go slow to avoid bending wires POWER_LEVEL = 25000 # max is 65000 # These values depend on motor wiring RIGHT_FORWARD_PIN = 10 RIGHT_REVERSE_PIN = 11 LEFT_FORWARD_PIN = 9 LEFT_REVERSE_PIN = 8 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) def main (): while True : if middle_switch . value (): # if the value changes print ( 'middle' ) led0 . on () reverse () sleep ( 1 ) turn_right () sleep ( . 75 ) forward () else : led0 . off () forward () if right_switch . value (): # if the value changes print ( 'right' ) led1 . on () reverse () sleep ( . 75 ) turn_left () sleep ( . 5 ) forward () else : led1 . off () forward () if left_switch . value (): # if the value changes led2 . on () print ( 'left' ) reverse () sleep ( . 75 ) turn_right () sleep ( . 5 ) forward () else : led2 . off () forward () print ( 'middle' , middle_switch . value ()) print ( 'left' , left_switch . value ()) print ( 'right' , right_switch . value ()) try : main () except KeyboardInterrupt : print ( 'Got ctrl-c' ) finally : # Optional cleanup code print ( 'turning off sound' ) # sound_off() print ( 'turning off motors' ) stop ()","title":"Sample Collision Avoidance Robot Code"},{"location":"misc/11-os/","text":"Sample OS functions Thonny does not easily allow you to delete files. To do this you will need to use the \"os\" functions. 1 2 3 4 import os os . listdir () os . remove ( 'myfile' ) os . listdir () To find out all the os functions use: 1 2 3 4 5 import os print ( dir ( os )) `` Returns [' class ', ' name ', 'remove', 'VfsFat', 'VfsLfs2', 'chdir', 'getcwd', 'ilistdir', 'listdir', 'mkdir', 'mount', 'rename', 'rmdir', 'stat', 'statvfs', 'umount', 'uname', 'urandom']` References https://www.youtube.com/watch?v=jnSX8ZMmHZ4","title":"Sample OS functions"},{"location":"misc/11-os/#sample-os-functions","text":"Thonny does not easily allow you to delete files. To do this you will need to use the \"os\" functions. 1 2 3 4 import os os . listdir () os . remove ( 'myfile' ) os . listdir () To find out all the os functions use: 1 2 3 4 5 import os print ( dir ( os )) `` Returns [' class ', ' name ', 'remove', 'VfsFat', 'VfsLfs2', 'chdir', 'getcwd', 'ilistdir', 'listdir', 'mkdir', 'mount', 'rename', 'rmdir', 'stat', 'statvfs', 'umount', 'uname', 'urandom']`","title":"Sample OS functions"},{"location":"misc/11-os/#references","text":"https://www.youtube.com/watch?v=jnSX8ZMmHZ4","title":"References"},{"location":"misc/30-colophon/","text":"Colophon We are mostly a group of unpaid volunteers without a large budget for distributed content management software. However, we still want to provide a great user experience for both our mentors and our students. So we use free open-source tools whenever we can. Here is how we built this site. Our content language is Markdown . We use Python Markdown to parse our content. We convert Markdown to HTML with mkdocs . Our user interface theme is Mkdocs Material . We use an extensive number of Material user interface components. Our software version control system is git Our site is hosted on GitHub page . We use standard code highlighting provided by the mkdocs codehilite extension. Our BY-NC-SA content license agreement is created by Creative Commons We wish to acknowledge the work of everyone that contributes to open-source projects. Without these systems this work would not be possible. If you would like to contribute lesson we welcome your contribution as a git pull request. You can read our CoderDojo Twin CitiesAuthoring Guide if you would like to help out.","title":"Colophon"},{"location":"misc/30-colophon/#colophon","text":"We are mostly a group of unpaid volunteers without a large budget for distributed content management software. However, we still want to provide a great user experience for both our mentors and our students. So we use free open-source tools whenever we can. Here is how we built this site. Our content language is Markdown . We use Python Markdown to parse our content. We convert Markdown to HTML with mkdocs . Our user interface theme is Mkdocs Material . We use an extensive number of Material user interface components. Our software version control system is git Our site is hosted on GitHub page . We use standard code highlighting provided by the mkdocs codehilite extension. Our BY-NC-SA content license agreement is created by Creative Commons We wish to acknowledge the work of everyone that contributes to open-source projects. Without these systems this work would not be possible. If you would like to contribute lesson we welcome your contribution as a git pull request. You can read our CoderDojo Twin CitiesAuthoring Guide if you would like to help out.","title":"Colophon"},{"location":"misc/contact/","text":"Cybersecurity for Kids Contacts General Code Savvy Contact kidscode@codesavvy.org Contact for CoderDojo Twin Cities hello@coderdojotc.org Specific questions on this repository Dan McCreary","title":"Contact"},{"location":"misc/contact/#cybersecurity-for-kids-contacts","text":"","title":"Cybersecurity for Kids Contacts"},{"location":"misc/contact/#general-code-savvy-contact","text":"kidscode@codesavvy.org","title":"General Code Savvy Contact"},{"location":"misc/contact/#contact-for-coderdojo-twin-cities","text":"hello@coderdojotc.org","title":"Contact for CoderDojo Twin Cities"},{"location":"misc/contact/#specific-questions-on-this-repository","text":"Dan McCreary","title":"Specific questions on this repository"},{"location":"misc/contributing/","text":"MicroPython Book Contributing Guide The goal of this microsite is to provide MicroPython content to STEM educational programs around the world. We value inclusion and we love low-cost projects that promote STEM instruction in communities that don't have large budgets. We value a focus on instructional design that teaches computational thinking and uses evidence of the effective delivery of this content to underprivileged communities. We welcome anyone that would like to add content to this microsite with the following guidelines: Contribution License Your content must be your own original content. We discourage copying bulk content from other sites without clear understanding of the copyrights that govern this content. We put a special focus on image attribution. Any images added must clearly state that the images are original content created by the author. You must agree to license your new original content to allow other teachers and mentors to reuse this content in their classrooms free of charge. We use Creative Commons Licenses Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) for all content in this microsite and other microsites managed by CoderDojo Twin Cities. Under these terms teachers and mentors are free to: Share \u2014 copy and redistribute the material in any medium or format Adapt \u2014 remix, transform, and build upon the material The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. NonCommercial \u2014 You may not use the material for commercial purposes. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Ways to Contribute Start out by helping us proof-read our content and help us find typos, spelling, lack-of clarity, and missing content. As you learn the style of our lessons you will be better able to contribute new lessons that have a similar style You may submit pull requests to this site of if you are not familiar with this process, you can add a link to your content in an issue. You may add an issue to our issues board here You are welcome to participate by looking for open tasks and using GitHub workflows to take on tasks to completion. Teaching Suggestions Avoid too much focus on building games that don't promote teaching computational thinking skills. Simple remote control robots might be fun, but sometime the fun of driving a robot around gets in the way of learning new concepts. Lesson Structure Try to begin each section or lesson with a kid-friendly image. This help readers quickly recall if they have visited this page before. If if it not obvious, include any prior knowledge that is required to understand a lesson in an Intended Audience or Prerequsites section. Try to keep the introductory lessons in a section short and small. After you have introduce the core concepts you can integrate concepts from other areas. Add a \"Further Explorations\" section to the end of each lesson Include references to other sites or wikipedia articles that can be explored further. Resources Please see our page on Teaching Computational Thinking .","title":"Contributing"},{"location":"misc/contributing/#micropython-book-contributing-guide","text":"The goal of this microsite is to provide MicroPython content to STEM educational programs around the world. We value inclusion and we love low-cost projects that promote STEM instruction in communities that don't have large budgets. We value a focus on instructional design that teaches computational thinking and uses evidence of the effective delivery of this content to underprivileged communities. We welcome anyone that would like to add content to this microsite with the following guidelines:","title":"MicroPython Book Contributing Guide"},{"location":"misc/contributing/#contribution-license","text":"Your content must be your own original content. We discourage copying bulk content from other sites without clear understanding of the copyrights that govern this content. We put a special focus on image attribution. Any images added must clearly state that the images are original content created by the author. You must agree to license your new original content to allow other teachers and mentors to reuse this content in their classrooms free of charge. We use Creative Commons Licenses Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) for all content in this microsite and other microsites managed by CoderDojo Twin Cities. Under these terms teachers and mentors are free to: Share \u2014 copy and redistribute the material in any medium or format Adapt \u2014 remix, transform, and build upon the material The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. NonCommercial \u2014 You may not use the material for commercial purposes. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.","title":"Contribution License"},{"location":"misc/contributing/#ways-to-contribute","text":"Start out by helping us proof-read our content and help us find typos, spelling, lack-of clarity, and missing content. As you learn the style of our lessons you will be better able to contribute new lessons that have a similar style You may submit pull requests to this site of if you are not familiar with this process, you can add a link to your content in an issue. You may add an issue to our issues board here You are welcome to participate by looking for open tasks and using GitHub workflows to take on tasks to completion.","title":"Ways to Contribute"},{"location":"misc/contributing/#teaching-suggestions","text":"Avoid too much focus on building games that don't promote teaching computational thinking skills. Simple remote control robots might be fun, but sometime the fun of driving a robot around gets in the way of learning new concepts.","title":"Teaching Suggestions"},{"location":"misc/contributing/#lesson-structure","text":"Try to begin each section or lesson with a kid-friendly image. This help readers quickly recall if they have visited this page before. If if it not obvious, include any prior knowledge that is required to understand a lesson in an Intended Audience or Prerequsites section. Try to keep the introductory lessons in a section short and small. After you have introduce the core concepts you can integrate concepts from other areas. Add a \"Further Explorations\" section to the end of each lesson Include references to other sites or wikipedia articles that can be explored further.","title":"Lesson Structure"},{"location":"misc/contributing/#resources","text":"Please see our page on Teaching Computational Thinking .","title":"Resources"},{"location":"misc/glossary/","text":"Micropython Glossary of Terms Ampy An obsolete MicroPython support tool created by Adafruit but no longer supported. Check out other MicroPython tools like rshell or mpfshell for more advanced interaction with boards. Analog to Digital Converter A component that takes an analogue signal and changes it to a digital one. Every ADC has two parameters, its resolution , measured in digital bits, and its channels , or how many analogue signals it can accept and convert at once. Also know as: ADC Blit A special form of copy operation; it copies a rectangular area of pixels from one framebuffer to another. It is used in MicroPython when doing drawing to a display such as an OLED display. BOOTSEL A button on the pico that when pressed during power up will allow you to mount the device as a USB drive. You can then drag-and-drop any uf2 image file to reset or update the runtime libraries. Also known as: Boot Selection Castellated Edge Plated through holes or vias located in the edges of a printed circuit board that make it easier to solder onto another circuit board. The word \"Castellated\" means having grooves or slots on an edge and is derived from the turrets of a castle. Dupont Connectors Pre-made low-cost used and used to connect breadboards to hardware such as sensors and displays. The connectors are available in male and female ends and are typically sold in lengths of 10 or 20cm. They have a with a 2.54mm (100mill) pitch so they are easy to align with our standard breadboards. They are typically sold in a ribbon of mixed colors for around $2.00 US for 40 connectors. Also known as: Jumper Wires Sample eBay Search for Jumper Wires Formatted Strings The ability to use a simplified syntax to format strings by added the letter \"f\" before the string. Values within curly braces are formatted from variables. 1 2 3 name = \"Lisa\" age = 12 f \"Hello, { name } . You are { age } .\" returns 1 Hello, Lisa. You are 12. Formatted string support was added to MicroPython in release 1.17 Also known as: f-strings Also known as: Literal String Interpolation From Python Enhancement Proposal: PEP 498 Link to Formatted Strings Docs ESP32 A series of low-cost, low-power system on a chip microcontrollers with integrated Wi-Fi and dual-mode Bluetooth. Typical costs for the ESP32 is are around $10 US on eBay. Sample on eBay $5 Sample on Amazon $11 Sample on Sparkfun $21 ESP32 Quick Reference Sample eBay Search for ESP32 from $5 to $20 Framebuffer A region of your microcontroller RAM that stores a bitmap image of your display. For a 128X64 monochrome display this would be 128 * 64 = 8,192 bits or 1,024 bytes (1K). Color displays must store up to 8 bytes per color for each color (red, green and blue). Wikipedia page on Framebuffer MicroPython Documentation on FrameBuffer ] I2C A communications protocol common in microcontroller-based systems, particularly for interfacing with sensors, memory devices and liquid crystal displays. I2C is similar to SPI, it's a synchronous protocol because it uses a clock line. Also Known as: Inter-integrated Circuit See also: SPI Micropython A set of Python libraries and tools developed specifically for microcontrollers. Micropython was originally developed by Damien George and first released in 2014. It includes many of the features of mainstream Python, while adding a range of new ones designed to take advantage of the facilities available on Raspberry Pi Pico and other microcontroller boards like the ESP32. See also: CircuitPython MPG Shell A simple micropython shell based file explorer for ESP8266 and WiPy Micropython based devices. The shell is a helper for up/downloading files to the ESP8266 (over serial line and Websockets) and WiPy (serial line and telnet). It basically offers commands to list and upload/download files on the flash FS of the device. GitHub Repo for MPFShell OLED Organic polymer light emitting diode. Raspberry Pi Foundation The company that builds the Raspberry Pi hardware and provides some software. Raspberry Pi Pico A microcontroller designed by the Raspberry Pi foundation for doing real-time control systems. The Pico was introduces in 2020 with a retail list price of $4. It was a key development because it used a custom chip that had 100 times the RAM of an Arduino Nano. Pico Pinout The Pico pinout has Pinout PDF RP2040 chip A custom chip created by the Raspberry Pi Foundation to power the Raspberry Pi Pico . rshell A simple micropython shell which runs on the host and uses MicroPython's raw-REPL to send python snippets to the pyboard in order to get filesystem information, and to copy files to and from MicroPython's filesystem. It also has the ability to invoke the regular REPL, so rshell can be used as a terminal emulator as well. Note: With rshell you can disable USB Mass Storage and still copy files into and out of your pyboard. RShell GitHub Repo SPI An interface bus commonly used to send data between microcontrollers and small peripherals such as sensors, displays and SD cards. SPI uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Also known as: Serial Peripheral Interface See also: I2C Thonny A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny runs on Mac, Windows and Linux. Thonny web site UF2 File The file that must be uploaded into the Raspberry Pi Pico folder to allow it to be used. The file name format looks like this: rp2-pico-20210205-unstable-v1.14-8-g1f800cac3.uf2 Unicorn MicroPython on Unicorn is completely open source Micropython emulator Github Repo: https://github.com/micropython/micropython-unicorn","title":"Glossary"},{"location":"misc/glossary/#micropython-glossary-of-terms","text":"","title":"Micropython Glossary of Terms"},{"location":"misc/glossary/#ampy","text":"An obsolete MicroPython support tool created by Adafruit but no longer supported. Check out other MicroPython tools like rshell or mpfshell for more advanced interaction with boards.","title":"Ampy"},{"location":"misc/glossary/#analog-to-digital-converter","text":"A component that takes an analogue signal and changes it to a digital one. Every ADC has two parameters, its resolution , measured in digital bits, and its channels , or how many analogue signals it can accept and convert at once. Also know as: ADC","title":"Analog to Digital Converter"},{"location":"misc/glossary/#blit","text":"A special form of copy operation; it copies a rectangular area of pixels from one framebuffer to another. It is used in MicroPython when doing drawing to a display such as an OLED display.","title":"Blit"},{"location":"misc/glossary/#bootsel","text":"A button on the pico that when pressed during power up will allow you to mount the device as a USB drive. You can then drag-and-drop any uf2 image file to reset or update the runtime libraries. Also known as: Boot Selection","title":"BOOTSEL"},{"location":"misc/glossary/#castellated-edge","text":"Plated through holes or vias located in the edges of a printed circuit board that make it easier to solder onto another circuit board. The word \"Castellated\" means having grooves or slots on an edge and is derived from the turrets of a castle.","title":"Castellated Edge"},{"location":"misc/glossary/#dupont-connectors","text":"Pre-made low-cost used and used to connect breadboards to hardware such as sensors and displays. The connectors are available in male and female ends and are typically sold in lengths of 10 or 20cm. They have a with a 2.54mm (100mill) pitch so they are easy to align with our standard breadboards. They are typically sold in a ribbon of mixed colors for around $2.00 US for 40 connectors. Also known as: Jumper Wires Sample eBay Search for Jumper Wires","title":"Dupont Connectors"},{"location":"misc/glossary/#formatted-strings","text":"The ability to use a simplified syntax to format strings by added the letter \"f\" before the string. Values within curly braces are formatted from variables. 1 2 3 name = \"Lisa\" age = 12 f \"Hello, { name } . You are { age } .\" returns 1 Hello, Lisa. You are 12. Formatted string support was added to MicroPython in release 1.17 Also known as: f-strings Also known as: Literal String Interpolation From Python Enhancement Proposal: PEP 498 Link to Formatted Strings Docs","title":"Formatted Strings"},{"location":"misc/glossary/#esp32","text":"A series of low-cost, low-power system on a chip microcontrollers with integrated Wi-Fi and dual-mode Bluetooth. Typical costs for the ESP32 is are around $10 US on eBay. Sample on eBay $5 Sample on Amazon $11 Sample on Sparkfun $21 ESP32 Quick Reference Sample eBay Search for ESP32 from $5 to $20","title":"ESP32"},{"location":"misc/glossary/#framebuffer","text":"A region of your microcontroller RAM that stores a bitmap image of your display. For a 128X64 monochrome display this would be 128 * 64 = 8,192 bits or 1,024 bytes (1K). Color displays must store up to 8 bytes per color for each color (red, green and blue). Wikipedia page on Framebuffer MicroPython Documentation on FrameBuffer ]","title":"Framebuffer"},{"location":"misc/glossary/#i2c","text":"A communications protocol common in microcontroller-based systems, particularly for interfacing with sensors, memory devices and liquid crystal displays. I2C is similar to SPI, it's a synchronous protocol because it uses a clock line. Also Known as: Inter-integrated Circuit See also: SPI","title":"I2C"},{"location":"misc/glossary/#micropython","text":"A set of Python libraries and tools developed specifically for microcontrollers. Micropython was originally developed by Damien George and first released in 2014. It includes many of the features of mainstream Python, while adding a range of new ones designed to take advantage of the facilities available on Raspberry Pi Pico and other microcontroller boards like the ESP32. See also: CircuitPython","title":"Micropython"},{"location":"misc/glossary/#mpg-shell","text":"A simple micropython shell based file explorer for ESP8266 and WiPy Micropython based devices. The shell is a helper for up/downloading files to the ESP8266 (over serial line and Websockets) and WiPy (serial line and telnet). It basically offers commands to list and upload/download files on the flash FS of the device. GitHub Repo for MPFShell","title":"MPG Shell"},{"location":"misc/glossary/#oled","text":"Organic polymer light emitting diode.","title":"OLED"},{"location":"misc/glossary/#raspberry-pi-foundation","text":"The company that builds the Raspberry Pi hardware and provides some software.","title":"Raspberry Pi Foundation"},{"location":"misc/glossary/#raspberry-pi-pico","text":"A microcontroller designed by the Raspberry Pi foundation for doing real-time control systems. The Pico was introduces in 2020 with a retail list price of $4. It was a key development because it used a custom chip that had 100 times the RAM of an Arduino Nano.","title":"Raspberry Pi Pico"},{"location":"misc/glossary/#pico-pinout","text":"The Pico pinout has Pinout PDF","title":"Pico Pinout"},{"location":"misc/glossary/#rp2040-chip","text":"A custom chip created by the Raspberry Pi Foundation to power the Raspberry Pi Pico .","title":"RP2040 chip"},{"location":"misc/glossary/#rshell","text":"A simple micropython shell which runs on the host and uses MicroPython's raw-REPL to send python snippets to the pyboard in order to get filesystem information, and to copy files to and from MicroPython's filesystem. It also has the ability to invoke the regular REPL, so rshell can be used as a terminal emulator as well. Note: With rshell you can disable USB Mass Storage and still copy files into and out of your pyboard. RShell GitHub Repo","title":"rshell"},{"location":"misc/glossary/#spi","text":"An interface bus commonly used to send data between microcontrollers and small peripherals such as sensors, displays and SD cards. SPI uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Also known as: Serial Peripheral Interface See also: I2C","title":"SPI"},{"location":"misc/glossary/#thonny","text":"A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny runs on Mac, Windows and Linux. Thonny web site","title":"Thonny"},{"location":"misc/glossary/#uf2-file","text":"The file that must be uploaded into the Raspberry Pi Pico folder to allow it to be used. The file name format looks like this: rp2-pico-20210205-unstable-v1.14-8-g1f800cac3.uf2","title":"UF2 File"},{"location":"misc/glossary/#unicorn","text":"MicroPython on Unicorn is completely open source Micropython emulator Github Repo: https://github.com/micropython/micropython-unicorn","title":"Unicorn"},{"location":"misc/mermaid-test/","text":"1 2 3 4 5 6 7 graph LR p[Pico] -->|ADC_VREF 36 row=6| pos(Positive) p[Pico] -->|AGND 33 row=8| neg(Negative) p[Pico] -->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) 1 2 3 graph LR MyApp --> DB(<font color=white>fa:fa-database MySQL) style DB fill:#00758f","title":"Render Test"},{"location":"misc/projects/","text":"CoderDojo MicroPython Projects Projects are groups lesson plans that need to work together and frequently build on other projects. Key project areas include: Sensors - find low cost sensors and create a lesson around them Robot Extensions - build extensions to our Base robot Sound and Music - add labs that generate sound and play music OLED Displays and Graphics - leverage the new low-cost OLED displays Debugging - build lesson plans to help student learn how to debug MicroPython programs and use logic analyzers Advanced Labs - using multiple cores, programming the IP processors, integrating C and assembly code Projects that a In Development Please connect with Dan McCreary if you are interested in helping out with these projects. Name Status Description Ping HC-SR04 50%) Create an OLED ping lab Motion Sensor 0% Create a lesson that uses a motion sensor. Use an OLED to display motion vs. time Photosensor 0% Create a lesson that will monitor light on a photo sensor DS18B Temp Sensor 0% Create a lesson that will read and display a waterproof temperature sensor JoyStick 0% Create a lesson that will read the X, Y and button of a JoyStick OLED JoyStick 0% Use a Joystick to move a ball around an OLED and paint pixels OLED Game of Life 0% Write a Game of Life with an OLED. Add a Joystick to paint initial conditions","title":"Projects"},{"location":"misc/projects/#coderdojo-micropython-projects","text":"Projects are groups lesson plans that need to work together and frequently build on other projects. Key project areas include: Sensors - find low cost sensors and create a lesson around them Robot Extensions - build extensions to our Base robot Sound and Music - add labs that generate sound and play music OLED Displays and Graphics - leverage the new low-cost OLED displays Debugging - build lesson plans to help student learn how to debug MicroPython programs and use logic analyzers Advanced Labs - using multiple cores, programming the IP processors, integrating C and assembly code","title":"CoderDojo MicroPython Projects"},{"location":"misc/projects/#projects-that-a-in-development","text":"Please connect with Dan McCreary if you are interested in helping out with these projects. Name Status Description Ping HC-SR04 50%) Create an OLED ping lab Motion Sensor 0% Create a lesson that uses a motion sensor. Use an OLED to display motion vs. time Photosensor 0% Create a lesson that will monitor light on a photo sensor DS18B Temp Sensor 0% Create a lesson that will read and display a waterproof temperature sensor JoyStick 0% Create a lesson that will read the X, Y and button of a JoyStick OLED JoyStick 0% Use a Joystick to move a ball around an OLED and paint pixels OLED Game of Life 0% Write a Game of Life with an OLED. Add a Joystick to paint initial conditions","title":"Projects that a In Development"},{"location":"misc/references/","text":"References for MicroPython Micropython References MicroPython Forum - a good place to ask questions about MicroPython. Mostly for hard core developers. MicroPython.org site - We would not recommend the PyBoard for beginners. They are over 10x more expensive than the the Raspberry Pi Pico. Spider Maf Github Repo Pico References MicroPython Firmware for the Raspberry Pi Pico - You will want to bookmark this site. It has the firmware required to run MicroPython on your Raspberry Pi Pico. As of March 2021, they are fixing bugs weekly, so you will want to make sure your firmware is current. Pico Launch Video on YouTube Raspberry Pi Web Site Project Search Pico Data Sheet - you will only need this for detailed information on how to use the Pico hardware. Meet Raspberry Silicon: Raspberry Pi Pico now on sale at $4 - The original Raspberry Pi Pico announcement. The journey to Raspberry Silicon - blog by Liam Fraser - Feb. 8th 2021. Nice story of how the Raspberry Pi Foundation created the custom silicon chip. TensorFlow Lite Micro for the Pico Pico Invaders Video YouTube video of Raspberry Pi driving a full color VGA screen - Full-speed high-fidelity BBC Micro emulation on a (slightly) overclocked Raspberry Pi Pico Raspberry Pi RP2040: Our Microcontroller for the Masses - James Adams, COO and Director of Hardware, Raspberry Pi ARM Blueprint post on TinyML - nice review of the Tiny Machine Learning possible on the ARM processor. Google TensorFlow engineer talking about how ARM and Google are working together on TinyML - short 60 second video clip of Google TensorFlow engineer Ian Nappier talking about how they are working with ARM to create a standard TinyML library for all ARM processors to use. Components Comparison of RP2040 Boards Components References 2.42\" OLED Display from DIY More","title":"References"},{"location":"misc/references/#references-for-micropython","text":"","title":"References for MicroPython"},{"location":"misc/references/#micropython-references","text":"MicroPython Forum - a good place to ask questions about MicroPython. Mostly for hard core developers. MicroPython.org site - We would not recommend the PyBoard for beginners. They are over 10x more expensive than the the Raspberry Pi Pico. Spider Maf Github Repo","title":"Micropython References"},{"location":"misc/references/#pico-references","text":"MicroPython Firmware for the Raspberry Pi Pico - You will want to bookmark this site. It has the firmware required to run MicroPython on your Raspberry Pi Pico. As of March 2021, they are fixing bugs weekly, so you will want to make sure your firmware is current. Pico Launch Video on YouTube Raspberry Pi Web Site Project Search Pico Data Sheet - you will only need this for detailed information on how to use the Pico hardware. Meet Raspberry Silicon: Raspberry Pi Pico now on sale at $4 - The original Raspberry Pi Pico announcement. The journey to Raspberry Silicon - blog by Liam Fraser - Feb. 8th 2021. Nice story of how the Raspberry Pi Foundation created the custom silicon chip. TensorFlow Lite Micro for the Pico Pico Invaders Video YouTube video of Raspberry Pi driving a full color VGA screen - Full-speed high-fidelity BBC Micro emulation on a (slightly) overclocked Raspberry Pi Pico Raspberry Pi RP2040: Our Microcontroller for the Masses - James Adams, COO and Director of Hardware, Raspberry Pi ARM Blueprint post on TinyML - nice review of the Tiny Machine Learning possible on the ARM processor. Google TensorFlow engineer talking about how ARM and Google are working together on TinyML - short 60 second video clip of Google TensorFlow engineer Ian Nappier talking about how they are working with ARM to create a standard TinyML library for all ARM processors to use.","title":"Pico References"},{"location":"misc/references/#components","text":"Comparison of RP2040 Boards","title":"Components"},{"location":"misc/references/#components-references","text":"2.42\" OLED Display from DIY More","title":"Components References"},{"location":"motors/01-intro/","text":"Using MicroPython to Control Motors and Servos Controlling motors are one of the funnest ways to learn how to program! They give us quick hand-on feedback on what are programs are doing. Motors are used in almost all our robot project. Robots are used in many STEM courses and coding clubs around the world. Programs like the AI Racing League allow students to learn topics like Machine Learning, Computer Vision and AI. These programs all depend on our understanding of how motors work and how to control them. Motor Types There are three types of motors we will learn how to control: DC Motors Servos Stepper Motors Outline of Labs Lab 1: Using and Transistor to Control a Motor In this lab we will use MicroPython to turn a motor on and off. We will use the digital output from the Raspberry Pi Pico to control a transistor as a switch to control the current to a motor. We will also learn how to use a diode to to protect the transistor from flyback current. Theory: What is an H-Bridge Circuit? This lab shows a sample circuit with four switches arranged in the shape of the letter \"H\" with the motor at the center of the letter. By closing switches in opposite corners we can make the motor reverse direction. Lab 2: Controlling a Motor Speed with the L293 H-Bridge Chip In this lab we will use a PWM signal to control the speed of a motor. Lab 3: Changing Motor Direction In this lab we will make a motor go both forward and backward and change the speed.","title":"Introduction"},{"location":"motors/01-intro/#using-micropython-to-control-motors-and-servos","text":"Controlling motors are one of the funnest ways to learn how to program! They give us quick hand-on feedback on what are programs are doing. Motors are used in almost all our robot project. Robots are used in many STEM courses and coding clubs around the world. Programs like the AI Racing League allow students to learn topics like Machine Learning, Computer Vision and AI. These programs all depend on our understanding of how motors work and how to control them.","title":"Using MicroPython to Control Motors and Servos"},{"location":"motors/01-intro/#motor-types","text":"There are three types of motors we will learn how to control: DC Motors Servos Stepper Motors","title":"Motor Types"},{"location":"motors/01-intro/#outline-of-labs","text":"","title":"Outline of Labs"},{"location":"motors/01-intro/#lab-1-using-and-transistor-to-control-a-motor","text":"In this lab we will use MicroPython to turn a motor on and off. We will use the digital output from the Raspberry Pi Pico to control a transistor as a switch to control the current to a motor. We will also learn how to use a diode to to protect the transistor from flyback current.","title":"Lab 1: Using and Transistor to Control a Motor"},{"location":"motors/01-intro/#theory-what-is-an-h-bridge-circuit","text":"This lab shows a sample circuit with four switches arranged in the shape of the letter \"H\" with the motor at the center of the letter. By closing switches in opposite corners we can make the motor reverse direction.","title":"Theory: What is an H-Bridge Circuit?"},{"location":"motors/01-intro/#lab-2-controlling-a-motor-speed-with-the-l293-h-bridge-chip","text":"In this lab we will use a PWM signal to control the speed of a motor.","title":"Lab 2: Controlling a Motor Speed with the L293 H-Bridge Chip"},{"location":"motors/01-intro/#lab-3-changing-motor-direction","text":"In this lab we will make a motor go both forward and backward and change the speed.","title":"Lab 3: Changing Motor Direction"},{"location":"motors/02-transistor/","text":"Using an Transistor to Control a Motor Power Requirements for Motors Motors need about 200 milliamps to work. But a microcontroller like the Raspberry Pi Pico only can switch about 18 milliamps. So we need a way to control more power. The Pico has 26 general purpose input and output pins. However, each pin's power is designed to digitally communicate with other devices and has a limited current capacity of around 17 milliamps according to the Raspberry Pi Pico Datasheet Table 5 . The solution is to either use the digital output signal to turn on and off a switch such as a transistor of to use a motor driver chip such as an L293D chip. Basic Transistor Circuit Transistor NPN 2222A Diode: 1N1448 Motor: 3-6 volt hobby motor PWM Control PWM Frequency Set the frequency to 50Hz (one cycle per 20ms) and the duty value to between 51 (51/1023 * 20ms = 1ms) and 102 (102/1023 * 20ms = 2ms) Sample Coder 1 2 3 4 5 6 7 8 import machine # set the 7th from the bottom on right as our motor pin motor_pin = machine . Pin ( 21 , machine . Pin . OUT ) # allocate a PWM object for controlling the motor speed motor_pwm = machine . PWM ( motor_pin ) motor_pwm . freq ( 50 ) # 50 hertz motor_pwm . duty ( 51 ) References Sparkfun Motor Lab from SIK Kit Nick Zoic MicroPython Motor Control Tutorial","title":"Transistor Lab"},{"location":"motors/02-transistor/#using-an-transistor-to-control-a-motor","text":"","title":"Using an Transistor to Control a Motor"},{"location":"motors/02-transistor/#power-requirements-for-motors","text":"Motors need about 200 milliamps to work. But a microcontroller like the Raspberry Pi Pico only can switch about 18 milliamps. So we need a way to control more power. The Pico has 26 general purpose input and output pins. However, each pin's power is designed to digitally communicate with other devices and has a limited current capacity of around 17 milliamps according to the Raspberry Pi Pico Datasheet Table 5 . The solution is to either use the digital output signal to turn on and off a switch such as a transistor of to use a motor driver chip such as an L293D chip.","title":"Power Requirements for Motors"},{"location":"motors/02-transistor/#basic-transistor-circuit","text":"Transistor NPN 2222A Diode: 1N1448 Motor: 3-6 volt hobby motor","title":"Basic Transistor Circuit"},{"location":"motors/02-transistor/#pwm-control","text":"","title":"PWM Control"},{"location":"motors/02-transistor/#pwm-frequency","text":"Set the frequency to 50Hz (one cycle per 20ms) and the duty value to between 51 (51/1023 * 20ms = 1ms) and 102 (102/1023 * 20ms = 2ms)","title":"PWM Frequency"},{"location":"motors/02-transistor/#sample-coder","text":"1 2 3 4 5 6 7 8 import machine # set the 7th from the bottom on right as our motor pin motor_pin = machine . Pin ( 21 , machine . Pin . OUT ) # allocate a PWM object for controlling the motor speed motor_pwm = machine . PWM ( motor_pin ) motor_pwm . freq ( 50 ) # 50 hertz motor_pwm . duty ( 51 )","title":"Sample Coder"},{"location":"motors/02-transistor/#references","text":"Sparkfun Motor Lab from SIK Kit Nick Zoic MicroPython Motor Control Tutorial","title":"References"},{"location":"motors/03-h-bridge/","text":"H-Bridge Circuits H-Bridge circuits are use to drive a motor both forward and backward. The circuit is called an \"H-Bridge\" because the arrangement of the switches around a motor form the letter \"H\". H-Bridge Circuit Operation If you connect a 5 volt power supply to a motor you will turn the motor in a specific direction such as clockwise. If you reverse the connections to the motor, the motor will turn the opposite direction such as counter-clockwise. In order to turn on the motor, switches 1 and 4 must be closed to allow current to flow through the motor. Switches 2 and 3 must be turned off. To reverse the motor direction you must open switches 1 and 4 and close switches 2 and three in the upper right and lower left portion of the diagram. References Wikipedia Page on H-Bridge Circuits","title":"H-Bridge"},{"location":"motors/03-h-bridge/#h-bridge-circuits","text":"H-Bridge circuits are use to drive a motor both forward and backward. The circuit is called an \"H-Bridge\" because the arrangement of the switches around a motor form the letter \"H\".","title":"H-Bridge Circuits"},{"location":"motors/03-h-bridge/#h-bridge-circuit-operation","text":"If you connect a 5 volt power supply to a motor you will turn the motor in a specific direction such as clockwise. If you reverse the connections to the motor, the motor will turn the opposite direction such as counter-clockwise. In order to turn on the motor, switches 1 and 4 must be closed to allow current to flow through the motor. Switches 2 and 3 must be turned off. To reverse the motor direction you must open switches 1 and 4 and close switches 2 and three in the upper right and lower left portion of the diagram.","title":"H-Bridge Circuit Operation"},{"location":"motors/03-h-bridge/#references","text":"Wikipedia Page on H-Bridge Circuits","title":"References"},{"location":"motors/04-l293d/","text":"Controlling a Motor with the L293D Motor Controller Chip What is an H-Bridge? The L293D Circuit The L293D motor driver IC actually has two power input pins viz. \u2018Vcc1\u2019 and \u2018Vcc2\u2019. Vcc1 is used for driving the internal logic circuitry which should be 5V. From Vcc2 pin the H-Bridge gets its power for driving the motors which can be 4.5V to 36V. And they both sink to a common ground named GND. Sample Program Referenes Last Minute Engineer L293D DC Motor TutoriL (Arduino version)","title":"L293D Chip"},{"location":"motors/04-l293d/#controlling-a-motor-with-the-l293d-motor-controller-chip","text":"","title":"Controlling a Motor with the L293D Motor Controller Chip"},{"location":"motors/04-l293d/#what-is-an-h-bridge","text":"","title":"What is an H-Bridge?"},{"location":"motors/04-l293d/#the-l293d-circuit","text":"The L293D motor driver IC actually has two power input pins viz. \u2018Vcc1\u2019 and \u2018Vcc2\u2019. Vcc1 is used for driving the internal logic circuitry which should be 5V. From Vcc2 pin the H-Bridge gets its power for driving the motors which can be 4.5V to 36V. And they both sink to a common ground named GND.","title":"The L293D Circuit"},{"location":"motors/04-l293d/#sample-program","text":"","title":"Sample Program"},{"location":"motors/04-l293d/#referenes","text":"Last Minute Engineer L293D DC Motor TutoriL (Arduino version)","title":"Referenes"},{"location":"motors/05-controller-board/","text":"","title":"Controller Board"},{"location":"motors/06-servos/","text":"Controlling a Servo Motor with MicroPython Types of Servos Although there are may types of servos you can purchase, in our labs there are two main types of servos that we use: SG90 Micro Servo, 9 grams, 180 degree, plastic gears - $4 MG90S Micro Servo, 9 grams, 180 degree, metal gears - $5 There are other variations that have 360 degree or continuous rotation servos. Servo Connections Almost all servos have a three pin connector that are spaced 1/10th of an inch apart so they will work with our breadboards. Ground (black or brown wire) 5 volt power (always red) Data (orange or yellow) references SparkFun Servos Page SparkFun Category for Servos eBay Servo Plastic Servo eBay Servo Metal Gear Servo","title":"Servos"},{"location":"motors/06-servos/#controlling-a-servo-motor-with-micropython","text":"","title":"Controlling a Servo Motor with MicroPython"},{"location":"motors/06-servos/#types-of-servos","text":"Although there are may types of servos you can purchase, in our labs there are two main types of servos that we use: SG90 Micro Servo, 9 grams, 180 degree, plastic gears - $4 MG90S Micro Servo, 9 grams, 180 degree, metal gears - $5 There are other variations that have 360 degree or continuous rotation servos.","title":"Types of Servos"},{"location":"motors/06-servos/#servo-connections","text":"Almost all servos have a three pin connector that are spaced 1/10th of an inch apart so they will work with our breadboards. Ground (black or brown wire) 5 volt power (always red) Data (orange or yellow)","title":"Servo Connections"},{"location":"motors/06-servos/#references","text":"SparkFun Servos Page SparkFun Category for Servos eBay Servo Plastic Servo eBay Servo Metal Gear Servo","title":"references"},{"location":"motors/07-stepper-motors/","text":"Controlling a Stepper Motor with MicroPython Stepper motors are specialized motors that precisely control the angle of rotation of the shaft of a motor. They are often used to carefully position items that move along an axis. For example you can use stepper motors to control the position the printing head of a 3D printer. Stepper motors are also quite a bit more expensive than our DC hobby motors and mini servos, so we don't use them frequently in our classes. Sample Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Code example from YoungWorks blog on how to use a stepper motor # https://www.youngwonks.com/blog/How-to-use-a-stepper-motor-with-the-Raspberry-Pi-Pico from machine import Pin import utime pins = [ Pin ( 15 , Pin . Out ), Pin ( 14 , Pin . Out ), Pin ( 16 , Pin . Out ), Pin ( 17 , Pin . Out ), ] # one hot encoding vectors full_step_sequence = [ [ 1.0 . 0.0 ], [ 0.1 . 0.0 ], [ 0.0 . 1.0 ], [ 0.0 . 0.1 ] ] while True : for step in full_step_sequence : for i in rang ( len ( pins )): pins [ i ] . value ( step [ i ]) utime . sleep ( 0.001 ) References Wikipedia Page on Stepper Motors Raspberry Pi L293D Example Young Wonks Stepper Motor Example with a","title":"Stepper Motors"},{"location":"motors/07-stepper-motors/#controlling-a-stepper-motor-with-micropython","text":"Stepper motors are specialized motors that precisely control the angle of rotation of the shaft of a motor. They are often used to carefully position items that move along an axis. For example you can use stepper motors to control the position the printing head of a 3D printer. Stepper motors are also quite a bit more expensive than our DC hobby motors and mini servos, so we don't use them frequently in our classes.","title":"Controlling a Stepper Motor with MicroPython"},{"location":"motors/07-stepper-motors/#sample-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Code example from YoungWorks blog on how to use a stepper motor # https://www.youngwonks.com/blog/How-to-use-a-stepper-motor-with-the-Raspberry-Pi-Pico from machine import Pin import utime pins = [ Pin ( 15 , Pin . Out ), Pin ( 14 , Pin . Out ), Pin ( 16 , Pin . Out ), Pin ( 17 , Pin . Out ), ] # one hot encoding vectors full_step_sequence = [ [ 1.0 . 0.0 ], [ 0.1 . 0.0 ], [ 0.0 . 1.0 ], [ 0.0 . 0.1 ] ] while True : for step in full_step_sequence : for i in rang ( len ( pins )): pins [ i ] . value ( step [ i ]) utime . sleep ( 0.001 )","title":"Sample Code"},{"location":"motors/07-stepper-motors/#references","text":"Wikipedia Page on Stepper Motors Raspberry Pi L293D Example Young Wonks Stepper Motor Example with a","title":"References"},{"location":"oled/01-intro/","text":"Introduction to OLED displays We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect** via I2C and SPI. Just four wires for I2C and seven wires for SPI. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. You can program them with Python (our student's favorite language) They are crazy fun! The first step is to find out what type of display graphics chip is used in your OLED. In these lessons we will assume you have a 128X64 or similar OLED display. Many of these displays can be purchased for around $4 on eBay. Many of these displays use the popular SSD1306 chip to drive the displays. There are also to communication options: I2C - simple 2 wire connection (not including power and ground) SPI - five wires but also faster screen refresh rates Updating a 128X64 display using I2C takes around 37ms. When using the SPI interface, updating the display can be reduced to around 2.79ms. These labs will assume these parameters, but you can modify the labs to use different sizes and display driver chips by only modifying a few lines of code. I2C Scanner Because your microcontroller might have multiple displays on it, their must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) If you don't see a return value of \"60\" or similar, then you need to check your wiring and make sure that you have an I2C (not an SPI) device.","title":"Introduction"},{"location":"oled/01-intro/#introduction-to-oled-displays","text":"We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect** via I2C and SPI. Just four wires for I2C and seven wires for SPI. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. You can program them with Python (our student's favorite language) They are crazy fun! The first step is to find out what type of display graphics chip is used in your OLED. In these lessons we will assume you have a 128X64 or similar OLED display. Many of these displays can be purchased for around $4 on eBay. Many of these displays use the popular SSD1306 chip to drive the displays. There are also to communication options: I2C - simple 2 wire connection (not including power and ground) SPI - five wires but also faster screen refresh rates Updating a 128X64 display using I2C takes around 37ms. When using the SPI interface, updating the display can be reduced to around 2.79ms. These labs will assume these parameters, but you can modify the labs to use different sizes and display driver chips by only modifying a few lines of code.","title":"Introduction to OLED displays"},{"location":"oled/01-intro/#i2c-scanner","text":"Because your microcontroller might have multiple displays on it, their must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) If you don't see a return value of \"60\" or similar, then you need to check your wiring and make sure that you have an I2C (not an SPI) device.","title":"I2C Scanner"},{"location":"oled/02-oled-setup/","text":"OLED Setup At the beginning of of your Python programs there is usually a few lines of setup instruction to tell the system which libraries to use, what pins to assign and what devices to initialize. We will first look at the simple I2C setup. Then we will look at the SPI setup. I2C Scanner Because your microcontroller might have multiple I2C devices and displays on it, there must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) returns: [60] returns: [60] SSD1306 Examples SSD1306 I2C Setup 1 2 3 4 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show () SSD1306 SPI Setup Back connections: Front labels on OLED with SPI: Here is the connection diagram: Here is the code: 1 2 3 4 5 6 7 8 9 10 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show () SSH1106 I2C Setup 1 2 3 4 5 6 7 8 9 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) oled = SH1106_I2C ( 128 , 64 , i2c ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show () References https://github.com/micropython/micropython/blob/master/drivers/display/ssd1306.py","title":"OLED Setup"},{"location":"oled/02-oled-setup/#oled-setup","text":"At the beginning of of your Python programs there is usually a few lines of setup instruction to tell the system which libraries to use, what pins to assign and what devices to initialize. We will first look at the simple I2C setup. Then we will look at the SPI setup.","title":"OLED Setup"},{"location":"oled/02-oled-setup/#i2c-scanner","text":"Because your microcontroller might have multiple I2C devices and displays on it, there must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) returns: [60] returns: [60]","title":"I2C Scanner"},{"location":"oled/02-oled-setup/#ssd1306-examples","text":"","title":"SSD1306 Examples"},{"location":"oled/02-oled-setup/#ssd1306-i2c-setup","text":"1 2 3 4 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show ()","title":"SSD1306 I2C Setup"},{"location":"oled/02-oled-setup/#ssd1306-spi-setup","text":"Back connections: Front labels on OLED with SPI: Here is the connection diagram: Here is the code: 1 2 3 4 5 6 7 8 9 10 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show ()","title":"SSD1306 SPI Setup"},{"location":"oled/02-oled-setup/#ssh1106-i2c-setup","text":"1 2 3 4 5 6 7 8 9 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) oled = SH1106_I2C ( 128 , 64 , i2c ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show ()","title":"SSH1106 I2C Setup"},{"location":"oled/02-oled-setup/#references","text":"https://github.com/micropython/micropython/blob/master/drivers/display/ssd1306.py","title":"References"},{"location":"oled/03-bitmaps/","text":"Drawing Bitmaps with MicroPython Framebuffers A Framebuffer is the core data structure we use when drawing bitmaps. Block Image Transfers (blit) The basic function we use to draw a rectangular region of the screen is called the blit() function: 1 display . blit ( frame_buffer , x , y ) This function moves all the data within any frame buffer to the given (x,y) position of the display. The function will check the dimensions of the frame buffer to know how much data to move to the display. You just need to tell the function where to start drawing. Blit Functions Are Efficient Blit operations can be much more efficient then the display.show() function when you are just updating a small region of the screen. This is because the display.show() function transfers the entire screen image each time it is called. Using blit functions can be written to only update the area of the screen that changes. For example, if you are writing a video game that has a ball moving across the screen, you only need to update the pixels around the ball, not the entire screen image. The exact performance difference between show() and blit() operations will depend on the size of the screen, the size of the blit update and the speed of the transfer of data from the framebuffer to the display device. The key disadvantage of using blit() functions is that you must consider what other artifacts there are on the screen that you might overwrite. Keeping track of the differences requires more computation by the microcontroller. The more powerful your microcontroller is relative to the communication speed, the more difference computations you can do. Not all display drivers will let you write directly from the microcontroller resident image directly to a region of the display. Sometimes you must follow your blit() operations with a show() to transfer the entire framebuffer to the display. Working with ByteArrays MicroPython blit operations use a data representation format for images called a ByteArray. These are sequences of the bytes that will be sent in a blit operation. They are coded using the following notation: 1 my_bytearray = ( b \" \\xFF\\xFF\\xFF\\xBF\\xDF\\xEF\\xF7\\xFF\\xFB\\xFF\\xFD \" ) Note that the letter b begins the parameter to show the Python interpreter that the all the characters between the double quotes are byte array values. The characters \\x indicate that there are hexadecimals useds to encode the bit values. Image Encoding Options There are several alternate methods to encode the bits of an image into a byte array. The bits can be coded left to right or top to bottom. You can also put the bits in most-significant bit first or least-significant bit first. All these options and controlled when you interface with a framebuffer. Vertical Least Significant Bit Layout framebuf.MONO_VLSB Monochrome (1-bit) color format This defines a mapping where the bits in a byte are vertically mapped with bit 0 being nearest the top of the screen. Consequently each byte occupies 8 vertical pixels. Subsequent bytes appear at successive horizontal locations until the rightmost edge is reached. Further bytes are rendered at locations starting at the leftmost edge, 8 pixels lower. References MicroPython Bitmap Tool Video - this video created by Lucky Resistor is a good overview of the image formats used by MicroPython.","title":"Drawing Bitmaps with MicroPython"},{"location":"oled/03-bitmaps/#drawing-bitmaps-with-micropython","text":"","title":"Drawing Bitmaps with MicroPython"},{"location":"oled/03-bitmaps/#framebuffers","text":"A Framebuffer is the core data structure we use when drawing bitmaps.","title":"Framebuffers"},{"location":"oled/03-bitmaps/#block-image-transfers-blit","text":"The basic function we use to draw a rectangular region of the screen is called the blit() function: 1 display . blit ( frame_buffer , x , y ) This function moves all the data within any frame buffer to the given (x,y) position of the display. The function will check the dimensions of the frame buffer to know how much data to move to the display. You just need to tell the function where to start drawing.","title":"Block Image Transfers (blit)"},{"location":"oled/03-bitmaps/#blit-functions-are-efficient","text":"Blit operations can be much more efficient then the display.show() function when you are just updating a small region of the screen. This is because the display.show() function transfers the entire screen image each time it is called. Using blit functions can be written to only update the area of the screen that changes. For example, if you are writing a video game that has a ball moving across the screen, you only need to update the pixels around the ball, not the entire screen image. The exact performance difference between show() and blit() operations will depend on the size of the screen, the size of the blit update and the speed of the transfer of data from the framebuffer to the display device. The key disadvantage of using blit() functions is that you must consider what other artifacts there are on the screen that you might overwrite. Keeping track of the differences requires more computation by the microcontroller. The more powerful your microcontroller is relative to the communication speed, the more difference computations you can do. Not all display drivers will let you write directly from the microcontroller resident image directly to a region of the display. Sometimes you must follow your blit() operations with a show() to transfer the entire framebuffer to the display.","title":"Blit Functions Are Efficient"},{"location":"oled/03-bitmaps/#working-with-bytearrays","text":"MicroPython blit operations use a data representation format for images called a ByteArray. These are sequences of the bytes that will be sent in a blit operation. They are coded using the following notation: 1 my_bytearray = ( b \" \\xFF\\xFF\\xFF\\xBF\\xDF\\xEF\\xF7\\xFF\\xFB\\xFF\\xFD \" ) Note that the letter b begins the parameter to show the Python interpreter that the all the characters between the double quotes are byte array values. The characters \\x indicate that there are hexadecimals useds to encode the bit values.","title":"Working with ByteArrays"},{"location":"oled/03-bitmaps/#image-encoding-options","text":"There are several alternate methods to encode the bits of an image into a byte array. The bits can be coded left to right or top to bottom. You can also put the bits in most-significant bit first or least-significant bit first. All these options and controlled when you interface with a framebuffer.","title":"Image Encoding Options"},{"location":"oled/03-bitmaps/#vertical-least-significant-bit-layout","text":"framebuf.MONO_VLSB Monochrome (1-bit) color format This defines a mapping where the bits in a byte are vertically mapped with bit 0 being nearest the top of the screen. Consequently each byte occupies 8 vertical pixels. Subsequent bytes appear at successive horizontal locations until the rightmost edge is reached. Further bytes are rendered at locations starting at the leftmost edge, 8 pixels lower.","title":"Vertical Least Significant Bit Layout"},{"location":"oled/03-bitmaps/#references","text":"MicroPython Bitmap Tool Video - this video created by Lucky Resistor is a good overview of the image formats used by MicroPython.","title":"References"},{"location":"oled/03-oled-drawing/","text":"Basic Draw Functions For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function. Initializing the Framebuffer Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following: Full list of Drawing Functions Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state or color is 0=off (black) and 1=on (white). Function Description Example blit(fbuf, x, y, color) Bit Level Transfer blit(fbuf, 1, 1) fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x, x, length, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert() invert the display Filp the orientation of the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel(x,y, color) Draw a single point on the screen rect(x, y, width, height) Draw an empty rectangle scroll(x,y) Scroll the display text(x,y,color) Write text at a point vline(x,y,length, color) Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display() Initialize the display write_cmd Write a command to the display show() Update the display from the frame buffer poweroff() poweron() contrast() write_data() Pixel Drawing Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ICON = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], ] display . fill ( 0 ) # Clear the display for y , row in enumerate ( ICON ): for x , c in enumerate ( row ): display . pixel ( x , y , c ) display . show () Drawing Tutorial and Primitives Taken from the MicroPython site: Using a SSD1306 OLED display - although the path name imply the ESP8266, these functions also run on the Raspberry Pi Pico. 1 2 3 4 5 6 7 8 9 display . poweroff () # power off the display, pixels persist in memory display . poweron () # power on the display, pixels redrawn display . contrast ( 0 ) # dim display . contrast ( 255 ) # bright display . invert ( 1 ) # display inverted display . invert ( 0 ) # display normal display . rotate ( True ) # rotate 180 degrees display . rotate ( False ) # rotate 0 degrees display . show () # write the contents of the FrameBuffer to display memory 1 2 3 4 5 6 7 8 9 10 display . fill ( 0 ) # fill entire screen with colour=0 display . pixel ( 0 , 10 ) # get pixel at x=0, y=10 display . pixel ( 0 , 10 , 1 ) # set pixel at x=0, y=10 to colour=1 display . hline ( 0 , 8 , 4 , 1 ) # draw horizontal line x=0, y=8, width=4, colour=1 display . vline ( 0 , 8 , 4 , 1 ) # draw vertical line x=0, y=8, height=4, colour=1 display . line ( 0 , 0 , 127 , 63 , 1 ) # draw a line from 0,0 to 127,63 display . rect ( 10 , 10 , 107 , 43 , 1 ) # draw a rectangle outline 10,10 to 107,43, colour=1 display . fill_rect ( 10 , 10 , 107 , 43 , 1 ) # draw a solid rectangle 10,10 to 107,43, colour=1 display . text ( 'Hello World' , 0 , 0 , 1 ) # draw some text at x=0, y=0, colour=1 display . scroll ( 20 , 0 ) # scroll 20 pixels to the right Working with the framebuf A frame buffer is a region of RAM that holds an exact image of what is on the display. The data can be copied from the framebuffer memory with the blit() (BLock Transfer) operation that copies a rectangular area of one framebuffer to another framebuffer. Here is an example of the blit() function: 1 oled . blit ( my_frame_buf , 10 , 10 , 0 ) 1 2 3 4 5 6 # draw another FrameBuffer on top of the current one at the given coordinates import framebuf fbuf = framebuf . FrameBuffer ( bytearray ( 8 * 8 * 1 ), 8 , 8 , framebuf . MONO_VLSB ) fbuf . line ( 0 , 0 , 7 , 7 , 1 ) display . blit ( fbuf , 10 , 10 , 0 ) # draw on top at x=10, y=10, key=0 display . show () References MicroPython Documentation on FrameBuffer Drawing Primitive Shapes Driving I2C OLED displays with MicroPython - by Martin Fitzpatrick ST7735 Micropython Driver by Anthony Norman","title":"Basic Drawing"},{"location":"oled/03-oled-drawing/#basic-draw-functions","text":"For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function.","title":"Basic Draw Functions"},{"location":"oled/03-oled-drawing/#initializing-the-framebuffer","text":"Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following:","title":"Initializing the Framebuffer"},{"location":"oled/03-oled-drawing/#full-list-of-drawing-functions","text":"Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state or color is 0=off (black) and 1=on (white). Function Description Example blit(fbuf, x, y, color) Bit Level Transfer blit(fbuf, 1, 1) fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x, x, length, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert() invert the display Filp the orientation of the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel(x,y, color) Draw a single point on the screen rect(x, y, width, height) Draw an empty rectangle scroll(x,y) Scroll the display text(x,y,color) Write text at a point vline(x,y,length, color) Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display() Initialize the display write_cmd Write a command to the display show() Update the display from the frame buffer poweroff() poweron() contrast() write_data()","title":"Full list of Drawing Functions"},{"location":"oled/03-oled-drawing/#pixel-drawing-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ICON = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], ] display . fill ( 0 ) # Clear the display for y , row in enumerate ( ICON ): for x , c in enumerate ( row ): display . pixel ( x , y , c ) display . show ()","title":"Pixel Drawing Example"},{"location":"oled/03-oled-drawing/#drawing-tutorial-and-primitives","text":"Taken from the MicroPython site: Using a SSD1306 OLED display - although the path name imply the ESP8266, these functions also run on the Raspberry Pi Pico. 1 2 3 4 5 6 7 8 9 display . poweroff () # power off the display, pixels persist in memory display . poweron () # power on the display, pixels redrawn display . contrast ( 0 ) # dim display . contrast ( 255 ) # bright display . invert ( 1 ) # display inverted display . invert ( 0 ) # display normal display . rotate ( True ) # rotate 180 degrees display . rotate ( False ) # rotate 0 degrees display . show () # write the contents of the FrameBuffer to display memory 1 2 3 4 5 6 7 8 9 10 display . fill ( 0 ) # fill entire screen with colour=0 display . pixel ( 0 , 10 ) # get pixel at x=0, y=10 display . pixel ( 0 , 10 , 1 ) # set pixel at x=0, y=10 to colour=1 display . hline ( 0 , 8 , 4 , 1 ) # draw horizontal line x=0, y=8, width=4, colour=1 display . vline ( 0 , 8 , 4 , 1 ) # draw vertical line x=0, y=8, height=4, colour=1 display . line ( 0 , 0 , 127 , 63 , 1 ) # draw a line from 0,0 to 127,63 display . rect ( 10 , 10 , 107 , 43 , 1 ) # draw a rectangle outline 10,10 to 107,43, colour=1 display . fill_rect ( 10 , 10 , 107 , 43 , 1 ) # draw a solid rectangle 10,10 to 107,43, colour=1 display . text ( 'Hello World' , 0 , 0 , 1 ) # draw some text at x=0, y=0, colour=1 display . scroll ( 20 , 0 ) # scroll 20 pixels to the right","title":"Drawing Tutorial and Primitives"},{"location":"oled/03-oled-drawing/#working-with-the-framebuf","text":"A frame buffer is a region of RAM that holds an exact image of what is on the display. The data can be copied from the framebuffer memory with the blit() (BLock Transfer) operation that copies a rectangular area of one framebuffer to another framebuffer. Here is an example of the blit() function: 1 oled . blit ( my_frame_buf , 10 , 10 , 0 ) 1 2 3 4 5 6 # draw another FrameBuffer on top of the current one at the given coordinates import framebuf fbuf = framebuf . FrameBuffer ( bytearray ( 8 * 8 * 1 ), 8 , 8 , framebuf . MONO_VLSB ) fbuf . line ( 0 , 0 , 7 , 7 , 1 ) display . blit ( fbuf , 10 , 10 , 0 ) # draw on top at x=10, y=10, key=0 display . show ()","title":"Working with the framebuf"},{"location":"oled/03-oled-drawing/#references","text":"MicroPython Documentation on FrameBuffer Drawing Primitive Shapes Driving I2C OLED displays with MicroPython - by Martin Fitzpatrick ST7735 Micropython Driver by Anthony Norman","title":"References"},{"location":"oled/10-oled-bounce/","text":"OLED Bounce In this lesson, we will draw a box around the edge of the display using the commands that draw horizontal and vertical lines: hline and vline . Then we will draw a ball that bounces off these edges. Draw a border 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge oled . show () Make a Ball Bounce Around Inside the Wall 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 2 # start in the middle of the screen current_x = int ( width / 2 ) current_y = int ( height / 2 ) # start going down to the right direction_x = 1 direction_y = - 1 # delay_time = .0001 # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 2 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y","title":"OLED Bounce"},{"location":"oled/10-oled-bounce/#oled-bounce","text":"In this lesson, we will draw a box around the edge of the display using the commands that draw horizontal and vertical lines: hline and vline . Then we will draw a ball that bounces off these edges.","title":"OLED Bounce"},{"location":"oled/10-oled-bounce/#draw-a-border","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge oled . show ()","title":"Draw a border"},{"location":"oled/10-oled-bounce/#make-a-ball-bounce-around-inside-the-wall","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 2 # start in the middle of the screen current_x = int ( width / 2 ) current_y = int ( height / 2 ) # start going down to the right direction_x = 1 direction_y = - 1 # delay_time = .0001 # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 2 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y","title":"Make a Ball Bounce Around Inside the Wall"},{"location":"oled/11-oled-ping/","text":"OLED PING Circuit Coder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from machine import Pin , I2C , Timer from ssd1306 import SSD1306_I2C import utime # global toggle button variable measure_on = False # debounce for button def debounce ( pin ): timer . init ( mode = Timer . ONE_SHOT , period = 200 , callback = on_pressed ) # if button pressed, toggle measure_on def on_pressed ( timer ): global measure_on measure_on = not measure_on # Init button button = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) timer = Timer () button . irq ( debounce , Pin . IRQ_RISING ) # Init Display i2c = I2C ( 0 , sda = Pin ( 0 ), scl = Pin ( 1 ), freq = 40000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) # Init HC-SR04 pins trigger = Pin ( 14 , Pin . OUT ) echo = Pin ( 13 , Pin . IN ) def ultra (): trigger . low () utime . sleep_us ( 2 ) trigger . high () utime . sleep_us ( 5 ) trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance try : while True : oled . fill ( 0 ) if measure_on : result = ultra () oled . text ( \"Distance:\" , 0 , 0 ) oled . text ( str ( result ) + \" cm\" , 0 , 10 ) oled . show () utime . sleep ( 1 ) except KeyboardInterrupt : pass","title":"OLED Ping"},{"location":"oled/11-oled-ping/#oled-ping","text":"","title":"OLED PING"},{"location":"oled/11-oled-ping/#circuit","text":"","title":"Circuit"},{"location":"oled/11-oled-ping/#coder","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from machine import Pin , I2C , Timer from ssd1306 import SSD1306_I2C import utime # global toggle button variable measure_on = False # debounce for button def debounce ( pin ): timer . init ( mode = Timer . ONE_SHOT , period = 200 , callback = on_pressed ) # if button pressed, toggle measure_on def on_pressed ( timer ): global measure_on measure_on = not measure_on # Init button button = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) timer = Timer () button . irq ( debounce , Pin . IRQ_RISING ) # Init Display i2c = I2C ( 0 , sda = Pin ( 0 ), scl = Pin ( 1 ), freq = 40000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) # Init HC-SR04 pins trigger = Pin ( 14 , Pin . OUT ) echo = Pin ( 13 , Pin . IN ) def ultra (): trigger . low () utime . sleep_us ( 2 ) trigger . high () utime . sleep_us ( 5 ) trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance try : while True : oled . fill ( 0 ) if measure_on : result = ultra () oled . text ( \"Distance:\" , 0 , 0 ) oled . text ( str ( result ) + \" cm\" , 0 , 10 ) oled . show () utime . sleep ( 1 ) except KeyboardInterrupt : pass","title":"Coder"},{"location":"oled/11-oled-sh1106-i2c/","text":"OLED SSD1306 I2C Examples We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect via SPI. Just four wires: GND, VCC, Clock and Data. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. The first step is to find out what type of display graphics chip is used in your OLED. SH1106 Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' ) Counter Example In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' ) Animated Box This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) ## note that we can only draw from 0 to 62 display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' ) Bounce on the SH1106 Display using I2C This example is a ball that bounces around the inside of a border rectangle. Is similar to other bounce examples with the exception that you can't draw on the last row of pixels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import machine import utime # from ssd1306 import SSD1306_I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 # we could make this be 63 but the init method should use the full value # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 5 current_x = int ( width / 2 ) current_y = int ( height / 2 ) direction_x = 1 direction_y = - 1 # delay_time = .0001 # oled.line(0, height-2, width-1, height-2, 1) # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 3 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y print ( 'done' ) SH1106 References Robert HH SH1106 Driver GitHub","title":"OLED SH1106 I2C Example"},{"location":"oled/11-oled-sh1106-i2c/#oled-ssd1306-i2c-examples","text":"We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect via SPI. Just four wires: GND, VCC, Clock and Data. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. The first step is to find out what type of display graphics chip is used in your OLED.","title":"OLED SSD1306 I2C Examples"},{"location":"oled/11-oled-sh1106-i2c/#sh1106-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' )","title":"SH1106 Example"},{"location":"oled/11-oled-sh1106-i2c/#counter-example","text":"In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' )","title":"Counter Example"},{"location":"oled/11-oled-sh1106-i2c/#animated-box","text":"This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) ## note that we can only draw from 0 to 62 display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' )","title":"Animated Box"},{"location":"oled/11-oled-sh1106-i2c/#bounce-on-the-sh1106-display-using-i2c","text":"This example is a ball that bounces around the inside of a border rectangle. Is similar to other bounce examples with the exception that you can't draw on the last row of pixels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import machine import utime # from ssd1306 import SSD1306_I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 # we could make this be 63 but the init method should use the full value # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 5 current_x = int ( width / 2 ) current_y = int ( height / 2 ) direction_x = 1 direction_y = - 1 # delay_time = .0001 # oled.line(0, height-2, width-1, height-2, 1) # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 3 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y print ( 'done' )","title":"Bounce on the SH1106 Display using I2C"},{"location":"oled/11-oled-sh1106-i2c/#sh1106-references","text":"Robert HH SH1106 Driver GitHub","title":"SH1106 References"},{"location":"oled/11-oled-ssd1306-i2c/","text":"OLED SSD1306 Examples Using the SSD1306 with I2C Interfaces Add the ssd1306 Python Module You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command. I2C Hello World 1 2 3 4 5 6 7 8 9 10 11 import machine from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () print ( 'Done' ) After this program runs you should see the text on your OLED display. SH1106 Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' ) Counter Example In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' ) Animated Box This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' ) Install SSD1306 Module ssd1306 module SSD1306 Library - click the RAW button and then right click to do a \"Save As\" SSD1306 vs. SH1106 There is only one small difference between SSD1306 and SH1106: The SH1106 controller has an internal RAM of 132x64 pixel. The SSD1306 only has 128x64 pixel. The SPI interface The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy. SPI Baudrate https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__spi.html#ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display: CS - Chip Select - pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin Pico Pins 1 2 3 4 5 6 7 8 9 10 # Sample code sections 28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res SCK is the clock - hook this to the oled SCL MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 SPI0_SCK - pin 6 SPI0_MOSI - pin 7 SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO 1 2 3 spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4) SPI Terms Master Out Slave In (MOSI) We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4) Sample Nonworking SPI Code From the documentation: From spi is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. dc is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. res is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. cs is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import machine import machine import utime import ssd1306 led = machine . Pin ( 25 , machine . Pin . OUT ) # From: https://github.com/robert-hh/SH1106 # display = sh1106.SH1106_SPI(width, height, spi, dc, res, cs) #MOSI=machine.Pin(7) #SCK=machine.Pin(6) #spi = machine.SPI(0, baudrate=400000, sck=SCK, mosi=MOSI) spi_sck = machine . Pin ( 6 ) spi_tx = machine . Pin ( 7 ) # spi_rx=machine.Pin(4) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 8 ) DC = machine . Pin ( 9 ) RES = machine . Pin ( 10 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled . fill ( 1 ) oled . show () utime . sleep ( 0.5 ) oled . fill ( 0 ) oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) oled . show () # flash the LED to show end led . high () utime . sleep ( 0.5 ) led . low () print ( 'Done' ) References MicroPython Tutorial on the SSD1306 robert-hh's SH1106 Driver M Fitzp OLED Display i2c Article Adafruit Stats DIY More OLED Product Description Using I2C Defaults","title":"OLED SSD1306 I2C"},{"location":"oled/11-oled-ssd1306-i2c/#oled-ssd1306-examples","text":"","title":"OLED SSD1306 Examples"},{"location":"oled/11-oled-ssd1306-i2c/#using-the-ssd1306-with-i2c-interfaces","text":"","title":"Using the SSD1306 with I2C Interfaces"},{"location":"oled/11-oled-ssd1306-i2c/#add-the-ssd1306-python-module","text":"You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command.","title":"Add the ssd1306 Python Module"},{"location":"oled/11-oled-ssd1306-i2c/#i2c-hello-world","text":"1 2 3 4 5 6 7 8 9 10 11 import machine from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () print ( 'Done' ) After this program runs you should see the text on your OLED display.","title":"I2C Hello World"},{"location":"oled/11-oled-ssd1306-i2c/#sh1106-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' )","title":"SH1106 Example"},{"location":"oled/11-oled-ssd1306-i2c/#counter-example","text":"In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' )","title":"Counter Example"},{"location":"oled/11-oled-ssd1306-i2c/#animated-box","text":"This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' )","title":"Animated Box"},{"location":"oled/11-oled-ssd1306-i2c/#install-ssd1306-module","text":"","title":"Install SSD1306 Module"},{"location":"oled/11-oled-ssd1306-i2c/#ssd1306-module","text":"SSD1306 Library - click the RAW button and then right click to do a \"Save As\"","title":"ssd1306 module"},{"location":"oled/11-oled-ssd1306-i2c/#ssd1306-vs-sh1106","text":"There is only one small difference between SSD1306 and SH1106: The SH1106 controller has an internal RAM of 132x64 pixel. The SSD1306 only has 128x64 pixel.","title":"SSD1306 vs. SH1106"},{"location":"oled/11-oled-ssd1306-i2c/#the-spi-interface","text":"The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy.","title":"The SPI interface"},{"location":"oled/11-oled-ssd1306-i2c/#spi-baudrate","text":"https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__spi.html#ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display: CS - Chip Select - pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin","title":"SPI Baudrate"},{"location":"oled/11-oled-ssd1306-i2c/#pico-pins","text":"1 2 3 4 5 6 7 8 9 10 # Sample code sections 28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res SCK is the clock - hook this to the oled SCL MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 SPI0_SCK - pin 6 SPI0_MOSI - pin 7 SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO 1 2 3 spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4)","title":"Pico Pins"},{"location":"oled/11-oled-ssd1306-i2c/#spi-terms","text":"Master Out Slave In (MOSI) We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4)","title":"SPI Terms"},{"location":"oled/11-oled-ssd1306-i2c/#sample-nonworking-spi-code","text":"From the documentation: From spi is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. dc is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. res is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. cs is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import machine import machine import utime import ssd1306 led = machine . Pin ( 25 , machine . Pin . OUT ) # From: https://github.com/robert-hh/SH1106 # display = sh1106.SH1106_SPI(width, height, spi, dc, res, cs) #MOSI=machine.Pin(7) #SCK=machine.Pin(6) #spi = machine.SPI(0, baudrate=400000, sck=SCK, mosi=MOSI) spi_sck = machine . Pin ( 6 ) spi_tx = machine . Pin ( 7 ) # spi_rx=machine.Pin(4) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 8 ) DC = machine . Pin ( 9 ) RES = machine . Pin ( 10 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled . fill ( 1 ) oled . show () utime . sleep ( 0.5 ) oled . fill ( 0 ) oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) oled . show () # flash the LED to show end led . high () utime . sleep ( 0.5 ) led . low () print ( 'Done' )","title":"Sample Nonworking SPI Code"},{"location":"oled/11-oled-ssd1306-i2c/#references","text":"MicroPython Tutorial on the SSD1306 robert-hh's SH1106 Driver M Fitzp OLED Display i2c Article Adafruit Stats DIY More OLED Product Description Using I2C Defaults","title":"References"},{"location":"oled/11-oled-ssd1306-spi/","text":"OLED SSD1306 SPI Examples Using the SSD1306 with SPI Interfaces Add the ssd1306 Python Module You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command. Install SSD1306 Module ssd1306 module SSD1306 Library - click the RAW button and then right click to do a \"Save As\" SSD1306 Library Searchable The SPI interface The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy. Displaying SPI Defaults 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from machine import Pin from ssd1306 import SSD1306_SPI # default is data (MOSI) on GP7 and clock (sck) on GP6 spi = machine . SPI ( 0 ) print ( spi ) SPI ( 0 , baudrate = 992063 , polarity = 0 , phase = 0 , bits = 8 , sck = 6 , mosi = 7 , miso = 4 ) ### SPI Baudrate https : // raspberrypi . github . io / pico - sdk - doxygen / group__hardware__spi . html #ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display : ! []( img / oled - back - connections . png ) 1. CS - Chip Select - pin 4 2. DC - Data / Command - pin 5 3. RES - Reset - pin 6 4. SDA - Data - SPIO TX GP7 pin 10 5. SCL - Clock - Connect to SPIO SCK GP6 pin 9 6. VCC - Connect to the 3.3 V Out pin 36 7. GND - pin 38 or 3 any other GND pin ### Pico Pins Sample code sections 28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res 1 2 3 4 5 6 7 8 9 10 11 12 * SCK is the clock - hook this to the oled SCL * MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 1. SPI0_SCK - pin 6 2. SPI0_MOSI - pin 7 3. SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4) ## Sample Nonworking SPI Code From the documentation: !!! From Raspberry Pi Pico Documentation **spi** is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. **dc** is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. **res** is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. **cs** is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. ```py import machine import utime import ssd1306 led = machine.Pin(25, machine.Pin.OUT) spi_sck=machine.Pin(6) spi_tx=machine.Pin(7) # spi_rx=machine.Pin(4) spi=machine.SPI(0,baudrate=100000,sck=spi_sck, mosi=spi_tx) CS = machine.Pin(8) DC = machine.Pin(9) RES = machine.Pin(10) oled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS) # flash all pixels on oled.fill(1) oled.show() utime.sleep(0.5) oled.fill(0) oled.text('CoderDojo Rocks!', 0, 0, 1) oled.show() # flash the LED to show end led.high() utime.sleep(0.5) led.low() print('Done') References robert-hh's SH1106 Driver MicroPython SSD1306 Class https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description SSD1306 https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1306/ SSD1307 https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1307/","title":"OLED SSD1306 SPI V2"},{"location":"oled/11-oled-ssd1306-spi/#oled-ssd1306-spi-examples","text":"","title":"OLED SSD1306 SPI Examples"},{"location":"oled/11-oled-ssd1306-spi/#using-the-ssd1306-with-spi-interfaces","text":"","title":"Using the SSD1306 with SPI Interfaces"},{"location":"oled/11-oled-ssd1306-spi/#add-the-ssd1306-python-module","text":"You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command.","title":"Add the ssd1306 Python Module"},{"location":"oled/11-oled-ssd1306-spi/#install-ssd1306-module","text":"","title":"Install SSD1306 Module"},{"location":"oled/11-oled-ssd1306-spi/#ssd1306-module","text":"SSD1306 Library - click the RAW button and then right click to do a \"Save As\" SSD1306 Library Searchable","title":"ssd1306 module"},{"location":"oled/11-oled-ssd1306-spi/#the-spi-interface","text":"The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy.","title":"The SPI interface"},{"location":"oled/11-oled-ssd1306-spi/#displaying-spi-defaults","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from machine import Pin from ssd1306 import SSD1306_SPI # default is data (MOSI) on GP7 and clock (sck) on GP6 spi = machine . SPI ( 0 ) print ( spi ) SPI ( 0 , baudrate = 992063 , polarity = 0 , phase = 0 , bits = 8 , sck = 6 , mosi = 7 , miso = 4 ) ### SPI Baudrate https : // raspberrypi . github . io / pico - sdk - doxygen / group__hardware__spi . html #ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display : ! []( img / oled - back - connections . png ) 1. CS - Chip Select - pin 4 2. DC - Data / Command - pin 5 3. RES - Reset - pin 6 4. SDA - Data - SPIO TX GP7 pin 10 5. SCL - Clock - Connect to SPIO SCK GP6 pin 9 6. VCC - Connect to the 3.3 V Out pin 36 7. GND - pin 38 or 3 any other GND pin ### Pico Pins","title":"Displaying SPI Defaults"},{"location":"oled/11-oled-ssd1306-spi/#sample-code-sections","text":"28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res 1 2 3 4 5 6 7 8 9 10 11 12 * SCK is the clock - hook this to the oled SCL * MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 1. SPI0_SCK - pin 6 2. SPI0_MOSI - pin 7 3. SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4) ## Sample Nonworking SPI Code From the documentation: !!! From Raspberry Pi Pico Documentation **spi** is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. **dc** is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. **res** is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. **cs** is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. ```py import machine import utime import ssd1306 led = machine.Pin(25, machine.Pin.OUT) spi_sck=machine.Pin(6) spi_tx=machine.Pin(7) # spi_rx=machine.Pin(4) spi=machine.SPI(0,baudrate=100000,sck=spi_sck, mosi=spi_tx) CS = machine.Pin(8) DC = machine.Pin(9) RES = machine.Pin(10) oled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS) # flash all pixels on oled.fill(1) oled.show() utime.sleep(0.5) oled.fill(0) oled.text('CoderDojo Rocks!', 0, 0, 1) oled.show() # flash the LED to show end led.high() utime.sleep(0.5) led.low() print('Done')","title":"Sample code sections"},{"location":"oled/11-oled-ssd1306-spi/#references","text":"robert-hh's SH1106 Driver MicroPython SSD1306 Class https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description","title":"References"},{"location":"oled/11-oled-ssd1306-spi/#ssd1306","text":"https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1306/","title":"SSD1306"},{"location":"oled/11-oled-ssd1306-spi/#ssd1307","text":"https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1307/","title":"SSD1307"},{"location":"oled/11-pong/","text":"Pong Using a low-cost OLED device you can write a pong game. If you use a small 128X64 OLED the price can be around $12. Part list Part Name Price Link Description Raspberry Pi Pico $4 Microcenter With 264K RAM it has plenty of room for storing the framebuffer 1/2 Size Solderless Breadboard $2 link 400 tie breadboard 128X64 OLED $5 eBay You can also get larger 2.42\" displays for around $20 2 10K Potentiometers $1.5 each eBay You can purchase these in QTY 10 for less. Use the part number B10K to narrow your search. Clear Plastic Box $4 The Container Store Shallow Narrow Stackable Rectangle Clear with Lids 8-1/4\" x 3-1/2\" x 1-7/8\" h. The link is to the white lids. Raspberry Pi Pico for $4. OLED with I2C Interface. Note the pins are VCC, GND, SCL (clock), SDA (data). 1/2 size 400 connector solderless breadboard 10K potentiometer with pre-soldered connectors. You will need two of these. You can use a male-to-male header to connect it to the breadboard. Connections Connect the GND of the OLED to GND of the Pico Connect the VCC of the OLED to 3V3 OUT (physical pin 36) Connect the SDA (data) of the OLED to the Pico GP0 (physical pin 1 on the top left with USB up) Connect the SCL (clock) of the OLED to GP1 (physical pin 2) Connect the center tap of both potentiometers to ADC0 (GP26 - pin 31) and ADC1 (GP27 - pin 32) Connect the outer connectors of the potentiometers to VCC and GND Getting the Right Python Libraries To run this program, you will need a MicroPython display driver. Our display in this example is the popular SSD1306 driver chip. Your OLED might have a slightly different driver type. Here is the line that must be customized for your display: 1 from ssd1306 import SSD1306_I2C Testing the OLED This test will verify that your OLED connections are correct. 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show () Drawing the Border 1 2 def border(WIDTH, HEIGHT): oled.rect(0, 0, WIDTH, HEIGHT, 1) Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 # Pong game on Raspberry Pi Pico with a OLED and two Potentimeters from machine import Pin , PWM , SPI import ssd1306 from utime import sleep import random # random direction for new ball spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # connect the center tops of the potentiometers to ADC0 and ADC1 pot_pin_1 = machine . ADC ( 26 ) pot_pin_2 = machine . ADC ( 26 ) # make them the same for testing # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # globals variables # static variables are constants are uppercase variable names WIDTH = 128 HALF_WIDTH = int ( WIDTH / 2 ) HEIGHT = 64 HALF_HEIGHT = HEIGHT BALL_SIZE = 3 # 2X2 pixels PAD_WIDTH = 2 PAD_HEIGHT = 8 HALF_PAD_WIDTH = int ( PAD_WIDTH / 2 ) HALF_PAD_HEIGHT = int ( PAD_HEIGHT / 2 ) POT_MIN = 3000 POT_MAX = 65534 MAX_ADC_VALUE = 65534 # Maximum value from the Analog to Digital Converter is 2^16 - 1 # dynamic global variables use lowercase paddle1_vel = 0 paddle2_vel = 0 l_score = 0 r_score = 0 # continiuous update of the paddle and ball # play_startup_sound() # start with the ball in the center ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) # set the initial directinon to down to the right ball_x_dir = 1 ball_y_dir = 1 def play_startup_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 25 ) speaker . freq ( 800 ) sleep ( . 25 ) speaker . freq ( 1200 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) def play_bounce_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 900 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) def play_score_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 25 ) speaker . freq ( 800 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( WIDTH , HEIGHT ): oled . rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a vertical bar def draw_paddle ( paddle_no , paddle_center ): if paddle_no == 1 : x = 0 else : x = WIDTH - 2 y = paddle_center - HALF_PAD_HEIGHT oled . fill_rect ( x , y , PAD_WIDTH , PAD_HEIGHT , 1 ) # fill with 1s def draw_ball (): oled . fill_rect ( ball_x , ball_y , BALL_SIZE , BALL_SIZE , 1 ) # square balls for now # The main event loop while True : oled . fill ( 0 ) # clear screen oled . vline ( int ( WIDTH / 2 ), 0 , HEIGHT , 1 ) # border(WIDTH, HEIGHT) # read both the pot values pot_val_1 = pot_pin_1 . read_u16 () pot_val_2 = pot_pin_1 . read_u16 () # print(pot_val_1) # scale the values from the max value of the input is a 2^16 or 65536 to 0 to HEIGHT - PAD_HEIGHT # ideally, it should range from 5 to 58 pot_val_1 = valmap ( pot_val_1 , POT_MIN , POT_MAX , HALF_PAD_HEIGHT , HEIGHT - HALF_PAD_HEIGHT - 2 ) pot_val_2 = valmap ( pot_val_2 , POT_MIN , POT_MAX , HALF_PAD_HEIGHT , HEIGHT - HALF_PAD_HEIGHT - 2 ) # print(pot_val, pot_scaled) draw_paddle ( 1 , pot_val_1 + HALF_PAD_HEIGHT ) draw_paddle ( 2 , pot_val_2 + HALF_PAD_HEIGHT ) draw_ball () #update ball position with the current directions ball_x = ball_x + ball_x_dir ball_y = ball_y + ball_y_dir # update the ball direction if we are at the top or bottom edge if ball_y < 0 : ball_y_dir = 1 #play_bounce_sound() if ball_y > HEIGHT - 3 : ball_y_dir = - 1 #play_bounce_sound() # if it hits the paddle bounce else score if ball_x < 1 : top_paddle = pot_val_1 - HALF_PAD_HEIGHT bottom_paddle = pot_val_1 + HALF_PAD_HEIGHT if ball_y > top_paddle and ball_y < bottom_paddle : # we have a hit ball_x_dir = 1 ball_x = 2 play_bounce_sound () print ( 'paddle hit on left edge' , pot_val_1 , top_paddle , bottom_paddle ) else : # we have a score for the right player play_score_sound () r_score += 1 ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) ball_x_dir = random . randint ( - 1 , 2 ) if ball_x_dir == 0 : ball_x_dir = 1 ball_y_dir = random . randint ( - 1 , 2 ) print ( 'score on left edge' , pot_val_1 , top_paddle , bottom_paddle ) sleep ( . 25 ) if ball_x > WIDTH - 3 : ball_x = WIDTH - 4 top_paddle = pot_val_2 - HALF_PAD_HEIGHT bottom_paddle = pot_val_2 + HALF_PAD_HEIGHT if ball_y > top_paddle and ball_y < bottom_paddle : ball_x_dir = - 1 print ( 'bounce on right paddle' , pot_val_1 , top_paddle , bottom_paddle ) else : l_score += 1 play_score_sound () ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) ball_x_dir = random . randint ( - 1 , 2 ) if ball_x_dir == 0 : ball_x_dir = 1 ball_y_dir = random . randint ( - 1 , 2 ) play_bounce_sound () print ( 'score on right edge' , pot_val_1 , top_paddle , bottom_paddle ) sleep ( . 25 ) oled . text ( str ( l_score ), HALF_WIDTH - 20 , 5 , 1 ) oled . text ( str ( r_score ), HALF_WIDTH + 5 , 5 , 1 ) oled . show () YouTube Video","title":"OLED Pong"},{"location":"oled/11-pong/#pong","text":"Using a low-cost OLED device you can write a pong game. If you use a small 128X64 OLED the price can be around $12.","title":"Pong"},{"location":"oled/11-pong/#part-list","text":"Part Name Price Link Description Raspberry Pi Pico $4 Microcenter With 264K RAM it has plenty of room for storing the framebuffer 1/2 Size Solderless Breadboard $2 link 400 tie breadboard 128X64 OLED $5 eBay You can also get larger 2.42\" displays for around $20 2 10K Potentiometers $1.5 each eBay You can purchase these in QTY 10 for less. Use the part number B10K to narrow your search. Clear Plastic Box $4 The Container Store Shallow Narrow Stackable Rectangle Clear with Lids 8-1/4\" x 3-1/2\" x 1-7/8\" h. The link is to the white lids. Raspberry Pi Pico for $4. OLED with I2C Interface. Note the pins are VCC, GND, SCL (clock), SDA (data). 1/2 size 400 connector solderless breadboard 10K potentiometer with pre-soldered connectors. You will need two of these. You can use a male-to-male header to connect it to the breadboard.","title":"Part list"},{"location":"oled/11-pong/#connections","text":"Connect the GND of the OLED to GND of the Pico Connect the VCC of the OLED to 3V3 OUT (physical pin 36) Connect the SDA (data) of the OLED to the Pico GP0 (physical pin 1 on the top left with USB up) Connect the SCL (clock) of the OLED to GP1 (physical pin 2) Connect the center tap of both potentiometers to ADC0 (GP26 - pin 31) and ADC1 (GP27 - pin 32) Connect the outer connectors of the potentiometers to VCC and GND","title":"Connections"},{"location":"oled/11-pong/#getting-the-right-python-libraries","text":"To run this program, you will need a MicroPython display driver. Our display in this example is the popular SSD1306 driver chip. Your OLED might have a slightly different driver type. Here is the line that must be customized for your display: 1 from ssd1306 import SSD1306_I2C","title":"Getting the Right Python Libraries"},{"location":"oled/11-pong/#testing-the-oled","text":"This test will verify that your OLED connections are correct. 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show ()","title":"Testing the OLED"},{"location":"oled/11-pong/#drawing-the-border","text":"1 2 def border(WIDTH, HEIGHT): oled.rect(0, 0, WIDTH, HEIGHT, 1)","title":"Drawing the Border"},{"location":"oled/11-pong/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 # Pong game on Raspberry Pi Pico with a OLED and two Potentimeters from machine import Pin , PWM , SPI import ssd1306 from utime import sleep import random # random direction for new ball spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # connect the center tops of the potentiometers to ADC0 and ADC1 pot_pin_1 = machine . ADC ( 26 ) pot_pin_2 = machine . ADC ( 26 ) # make them the same for testing # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # globals variables # static variables are constants are uppercase variable names WIDTH = 128 HALF_WIDTH = int ( WIDTH / 2 ) HEIGHT = 64 HALF_HEIGHT = HEIGHT BALL_SIZE = 3 # 2X2 pixels PAD_WIDTH = 2 PAD_HEIGHT = 8 HALF_PAD_WIDTH = int ( PAD_WIDTH / 2 ) HALF_PAD_HEIGHT = int ( PAD_HEIGHT / 2 ) POT_MIN = 3000 POT_MAX = 65534 MAX_ADC_VALUE = 65534 # Maximum value from the Analog to Digital Converter is 2^16 - 1 # dynamic global variables use lowercase paddle1_vel = 0 paddle2_vel = 0 l_score = 0 r_score = 0 # continiuous update of the paddle and ball # play_startup_sound() # start with the ball in the center ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) # set the initial directinon to down to the right ball_x_dir = 1 ball_y_dir = 1 def play_startup_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 25 ) speaker . freq ( 800 ) sleep ( . 25 ) speaker . freq ( 1200 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) def play_bounce_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 900 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) def play_score_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 25 ) speaker . freq ( 800 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( WIDTH , HEIGHT ): oled . rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a vertical bar def draw_paddle ( paddle_no , paddle_center ): if paddle_no == 1 : x = 0 else : x = WIDTH - 2 y = paddle_center - HALF_PAD_HEIGHT oled . fill_rect ( x , y , PAD_WIDTH , PAD_HEIGHT , 1 ) # fill with 1s def draw_ball (): oled . fill_rect ( ball_x , ball_y , BALL_SIZE , BALL_SIZE , 1 ) # square balls for now # The main event loop while True : oled . fill ( 0 ) # clear screen oled . vline ( int ( WIDTH / 2 ), 0 , HEIGHT , 1 ) # border(WIDTH, HEIGHT) # read both the pot values pot_val_1 = pot_pin_1 . read_u16 () pot_val_2 = pot_pin_1 . read_u16 () # print(pot_val_1) # scale the values from the max value of the input is a 2^16 or 65536 to 0 to HEIGHT - PAD_HEIGHT # ideally, it should range from 5 to 58 pot_val_1 = valmap ( pot_val_1 , POT_MIN , POT_MAX , HALF_PAD_HEIGHT , HEIGHT - HALF_PAD_HEIGHT - 2 ) pot_val_2 = valmap ( pot_val_2 , POT_MIN , POT_MAX , HALF_PAD_HEIGHT , HEIGHT - HALF_PAD_HEIGHT - 2 ) # print(pot_val, pot_scaled) draw_paddle ( 1 , pot_val_1 + HALF_PAD_HEIGHT ) draw_paddle ( 2 , pot_val_2 + HALF_PAD_HEIGHT ) draw_ball () #update ball position with the current directions ball_x = ball_x + ball_x_dir ball_y = ball_y + ball_y_dir # update the ball direction if we are at the top or bottom edge if ball_y < 0 : ball_y_dir = 1 #play_bounce_sound() if ball_y > HEIGHT - 3 : ball_y_dir = - 1 #play_bounce_sound() # if it hits the paddle bounce else score if ball_x < 1 : top_paddle = pot_val_1 - HALF_PAD_HEIGHT bottom_paddle = pot_val_1 + HALF_PAD_HEIGHT if ball_y > top_paddle and ball_y < bottom_paddle : # we have a hit ball_x_dir = 1 ball_x = 2 play_bounce_sound () print ( 'paddle hit on left edge' , pot_val_1 , top_paddle , bottom_paddle ) else : # we have a score for the right player play_score_sound () r_score += 1 ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) ball_x_dir = random . randint ( - 1 , 2 ) if ball_x_dir == 0 : ball_x_dir = 1 ball_y_dir = random . randint ( - 1 , 2 ) print ( 'score on left edge' , pot_val_1 , top_paddle , bottom_paddle ) sleep ( . 25 ) if ball_x > WIDTH - 3 : ball_x = WIDTH - 4 top_paddle = pot_val_2 - HALF_PAD_HEIGHT bottom_paddle = pot_val_2 + HALF_PAD_HEIGHT if ball_y > top_paddle and ball_y < bottom_paddle : ball_x_dir = - 1 print ( 'bounce on right paddle' , pot_val_1 , top_paddle , bottom_paddle ) else : l_score += 1 play_score_sound () ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) ball_x_dir = random . randint ( - 1 , 2 ) if ball_x_dir == 0 : ball_x_dir = 1 ball_y_dir = random . randint ( - 1 , 2 ) play_bounce_sound () print ( 'score on right edge' , pot_val_1 , top_paddle , bottom_paddle ) sleep ( . 25 ) oled . text ( str ( l_score ), HALF_WIDTH - 20 , 5 , 1 ) oled . text ( str ( r_score ), HALF_WIDTH + 5 , 5 , 1 ) oled . show () YouTube Video","title":"Full Program"},{"location":"oled/12-oled-pot/","text":"OLED Potentiometer Example In this lesson, we will use a potentiometer to change the value of an OLED display. We will use a small SSD1306 OLED with an I2C interface. A potentiometer has three wires. The two outside wires connect to GND and the 3.3 volt output. The center wire, called the \"tap\" wire will connect to the pin that converts an continuous analog voltage value into a digital number. Wikipedia Page on Potentiometer Circuit Diagram Sample Code Testing the POT Our first task is to find what pin to use for our first Analog to Digital concerter. GP26 is the same as ADC0. This is pin number 31 on the Pico. 1 2 3 4 5 6 import machine import utime pot = machine . ADC ( 26 ) while True : print ( pot . read_u16 ()) utime . sleep ( . 2 ) Sample 16 bit output A 16-bit integer can store 216 (or 65,536) distinct values. In an unsigned representation, these values are the integers between 0 and 65,535. So we are expecting numbers from 0 to 65,535. Sample results as we move the potentiometer from the minimum to the maximum values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 65535 52844 31047 7745 256 352 19140 41114 62239 65535 57277 33384 10114 352 288 19940 28086 Testing the OLED Getting the defaults 1 2 3 4 5 from machine import Pin , I2C # i2c=machine.I2C(0) i2c = machine . I2C ( 0 ) print ( \"Device found at decimal\" , i2c . scan ()) print ( i2c ) Results: This tells you the default pins and frequency that the I2C bus is running at. 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=9, sda=8) 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=1, sda=0) This tells us that the default pins are GP9 (row 12) for clock and GP8 (row 11) for data. 1 2 3 4 5 6 7 8 9 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show () Continuous Text Display on OLED 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 32 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) POT_PIN = machine . ADC ( 26 ) while True : oled . fill ( 0 ) oled . text ( POT_PIN . read_u16 ()) oled . show () utime . sleep ( . 2 ) Barchart and Text Display of Pot Value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import machine import utime import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) pot_pin = machine . ADC ( 26 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 half_height = int ( height / 2 ) # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a horizontal bar def draw_hbar ( inval , height , state ): oled . fill ( 0 ) # clear screen border ( width , height ) # draw a border oled . fill_rect ( 0 , 1 , inval , height , 1 ) # fill with 1 utime . sleep ( . 1 ) # wait a bit # continuous update while True : pot_val = int ( pot_pin . read_u16 ()) # the max value of the input is a 2^16 or 65536 pot_scaled = valmap ( pot_val , 0 , 65536 , 0 , 127 ) print ( pot_val , pot_scaled ) draw_hbar ( pot_scaled , half_height , 1 ) oled . text ( 'raw:' , 0 , half_height + 5 , 1 ) oled . text ( str ( pot_val ), 30 , half_height + 5 , 1 ) oled . text ( 'scaled:' , 0 , half_height + 15 , 1 ) oled . text ( str ( pot_scaled ), 60 , half_height + 15 , 1 ) oled . show () Gif of OLED Gif of small .96\" OLED Gif of larger 2.42\" OLED","title":"OLED Pot"},{"location":"oled/12-oled-pot/#oled-potentiometer-example","text":"In this lesson, we will use a potentiometer to change the value of an OLED display. We will use a small SSD1306 OLED with an I2C interface. A potentiometer has three wires. The two outside wires connect to GND and the 3.3 volt output. The center wire, called the \"tap\" wire will connect to the pin that converts an continuous analog voltage value into a digital number. Wikipedia Page on Potentiometer","title":"OLED Potentiometer Example"},{"location":"oled/12-oled-pot/#circuit-diagram","text":"","title":"Circuit Diagram"},{"location":"oled/12-oled-pot/#sample-code","text":"","title":"Sample Code"},{"location":"oled/12-oled-pot/#testing-the-pot","text":"Our first task is to find what pin to use for our first Analog to Digital concerter. GP26 is the same as ADC0. This is pin number 31 on the Pico. 1 2 3 4 5 6 import machine import utime pot = machine . ADC ( 26 ) while True : print ( pot . read_u16 ()) utime . sleep ( . 2 )","title":"Testing the POT"},{"location":"oled/12-oled-pot/#sample-16-bit-output","text":"A 16-bit integer can store 216 (or 65,536) distinct values. In an unsigned representation, these values are the integers between 0 and 65,535. So we are expecting numbers from 0 to 65,535. Sample results as we move the potentiometer from the minimum to the maximum values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 65535 52844 31047 7745 256 352 19140 41114 62239 65535 57277 33384 10114 352 288 19940 28086","title":"Sample 16 bit output"},{"location":"oled/12-oled-pot/#testing-the-oled","text":"","title":"Testing the OLED"},{"location":"oled/12-oled-pot/#getting-the-defaults","text":"1 2 3 4 5 from machine import Pin , I2C # i2c=machine.I2C(0) i2c = machine . I2C ( 0 ) print ( \"Device found at decimal\" , i2c . scan ()) print ( i2c ) Results: This tells you the default pins and frequency that the I2C bus is running at. 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=9, sda=8) 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=1, sda=0) This tells us that the default pins are GP9 (row 12) for clock and GP8 (row 11) for data. 1 2 3 4 5 6 7 8 9 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show ()","title":"Getting the defaults"},{"location":"oled/12-oled-pot/#continuous-text-display-on-oled","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 32 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) POT_PIN = machine . ADC ( 26 ) while True : oled . fill ( 0 ) oled . text ( POT_PIN . read_u16 ()) oled . show () utime . sleep ( . 2 )","title":"Continuous Text Display on OLED"},{"location":"oled/12-oled-pot/#barchart-and-text-display-of-pot-value","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import machine import utime import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) pot_pin = machine . ADC ( 26 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 half_height = int ( height / 2 ) # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a horizontal bar def draw_hbar ( inval , height , state ): oled . fill ( 0 ) # clear screen border ( width , height ) # draw a border oled . fill_rect ( 0 , 1 , inval , height , 1 ) # fill with 1 utime . sleep ( . 1 ) # wait a bit # continuous update while True : pot_val = int ( pot_pin . read_u16 ()) # the max value of the input is a 2^16 or 65536 pot_scaled = valmap ( pot_val , 0 , 65536 , 0 , 127 ) print ( pot_val , pot_scaled ) draw_hbar ( pot_scaled , half_height , 1 ) oled . text ( 'raw:' , 0 , half_height + 5 , 1 ) oled . text ( str ( pot_val ), 30 , half_height + 5 , 1 ) oled . text ( 'scaled:' , 0 , half_height + 15 , 1 ) oled . text ( str ( pot_scaled ), 60 , half_height + 15 , 1 ) oled . show ()","title":"Barchart and Text Display of Pot Value"},{"location":"oled/12-oled-pot/#gif-of-oled","text":"Gif of small .96\" OLED Gif of larger 2.42\" OLED","title":"Gif of OLED"},{"location":"oled/12-oled-ssd1306-spi-v1/","text":"OLED SPI Demo This code was provide by Jim Tannenbaum (aka Jet) Image Code 1 2 3 4 5 6 7 8 9 10 11 12 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled.fill(0) oled . show () oled . text ( 'Hello Jet' , 0 , 0 , 1 ) oled . show ()","title":"OLED SSD1306 SPI V1"},{"location":"oled/12-oled-ssd1306-spi-v1/#oled-spi-demo","text":"This code was provide by Jim Tannenbaum (aka Jet)","title":"OLED SPI Demo"},{"location":"oled/12-oled-ssd1306-spi-v1/#image","text":"","title":"Image"},{"location":"oled/12-oled-ssd1306-spi-v1/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled.fill(0) oled . show () oled . text ( 'Hello Jet' , 0 , 0 , 1 ) oled . show ()","title":"Code"},{"location":"oled/13-pixel-draw/","text":"Sample Pixel-Based Drawing Program Code example provided by Jim Tannenbaum. This program will act like an Etch-A-Sketch(TM) program. It will use potentiometers with the center tap on GPIO pins GP26 and GP27 and draw as you move the potentiometers to control the X and Y dimensions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from machine import Pin , SPI , ADC import ssd1306 import time # Takes an input number value and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def scaled ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( int ( value ) - istart ) / ( istop - istart ))) # Define the pins for SPI Clock and Transmit spi_sck = Pin ( 2 ) spi_tx = Pin ( 3 ) spi = SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) # Define the pins for Chip Select, DC (Command), and Reset CS = Pin ( 1 ) DC = Pin ( 4 ) RES = Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # Turn all pixels off oled . fill ( 0 ) oled . show () # Provide info to user oled . text ( 'Etch-A-Sketch' , 0 , 0 , 1 ) oled . text ( 'Hit the reset' , 0 , 20 , 1 ) oled . text ( 'button to clear' , 0 , 30 , 1 ) oled . text ( 'the screen' , 0 , 40 , 1 ) oled . show () # Define the pin for the reset button resetButton = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) # Wait unti the user hits the button to clear the screen and start drawing while resetButton . value () != 1 : time . sleep ( . 25 ) oled . fill ( 0 ) oled . show () # Define the Horizontal and Vertical inputs from the Rheostats vert = ADC ( 26 ) horiz = ADC ( 27 ) # Calculate where to start the line x = newX = scaled ( vert . read_u16 (), 0 , 65536 , 0 , 128 ) y = newY = scaled ( horiz . read_u16 (), 0 , 65536 , 0 , 64 ) # Loop forever # Draw the line, look for a reset to clear the screen, and get the new end points for the line while True : oled . line ( x , y , newX , newY , 1 ) x = newX y = newY if resetButton . value (): oled . fill ( 0 ) oled . show () time . sleep ( . 2 ) newX = scaled ( vert . read_u16 (), 0 , 65536 , 0 , 128 ) newY = scaled ( horiz . read_u16 (), 0 , 65536 , 0 , 64 )","title":"OLED Pixel Draw"},{"location":"oled/13-pixel-draw/#sample-pixel-based-drawing-program","text":"Code example provided by Jim Tannenbaum. This program will act like an Etch-A-Sketch(TM) program. It will use potentiometers with the center tap on GPIO pins GP26 and GP27 and draw as you move the potentiometers to control the X and Y dimensions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from machine import Pin , SPI , ADC import ssd1306 import time # Takes an input number value and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def scaled ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( int ( value ) - istart ) / ( istop - istart ))) # Define the pins for SPI Clock and Transmit spi_sck = Pin ( 2 ) spi_tx = Pin ( 3 ) spi = SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) # Define the pins for Chip Select, DC (Command), and Reset CS = Pin ( 1 ) DC = Pin ( 4 ) RES = Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # Turn all pixels off oled . fill ( 0 ) oled . show () # Provide info to user oled . text ( 'Etch-A-Sketch' , 0 , 0 , 1 ) oled . text ( 'Hit the reset' , 0 , 20 , 1 ) oled . text ( 'button to clear' , 0 , 30 , 1 ) oled . text ( 'the screen' , 0 , 40 , 1 ) oled . show () # Define the pin for the reset button resetButton = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) # Wait unti the user hits the button to clear the screen and start drawing while resetButton . value () != 1 : time . sleep ( . 25 ) oled . fill ( 0 ) oled . show () # Define the Horizontal and Vertical inputs from the Rheostats vert = ADC ( 26 ) horiz = ADC ( 27 ) # Calculate where to start the line x = newX = scaled ( vert . read_u16 (), 0 , 65536 , 0 , 128 ) y = newY = scaled ( horiz . read_u16 (), 0 , 65536 , 0 , 64 ) # Loop forever # Draw the line, look for a reset to clear the screen, and get the new end points for the line while True : oled . line ( x , y , newX , newY , 1 ) x = newX y = newY if resetButton . value (): oled . fill ( 0 ) oled . show () time . sleep ( . 2 ) newX = scaled ( vert . read_u16 (), 0 , 65536 , 0 , 128 ) newY = scaled ( horiz . read_u16 (), 0 , 65536 , 0 , 64 )","title":"Sample Pixel-Based Drawing Program"},{"location":"oled/14-random-hearts/","text":"Draw Random Hearts This program uses the MicroPython urandom library to generate random X and Y positions on the display. It then uses an array of binary values to draw a heart icon at that location. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from machine import Pin , PWM , SPI import urandom import ssd1306 from utime import sleep import random # random direction for new ball WIDTH = 128 HEIGHT = 64 CS = machine . Pin ( 1 ) spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) HEART = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], ] def draw_heart ( xofs , yofs ): for y , row in enumerate ( HEART ): for x , c in enumerate ( row ): oled . pixel ( x + xofs , y + yofs , c ) def random_heart (): xofs = urandom . getrandbits ( 7 ) yofs = urandom . getrandbits ( 6 ) print ( xofs , yofs ) draw_heart ( xofs , yofs ) oled . fill ( 0 ) for n in range ( 10 ): random_heart () oled . show ()","title":"Random Hearts"},{"location":"oled/14-random-hearts/#draw-random-hearts","text":"This program uses the MicroPython urandom library to generate random X and Y positions on the display. It then uses an array of binary values to draw a heart icon at that location. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from machine import Pin , PWM , SPI import urandom import ssd1306 from utime import sleep import random # random direction for new ball WIDTH = 128 HEIGHT = 64 CS = machine . Pin ( 1 ) spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) HEART = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], ] def draw_heart ( xofs , yofs ): for y , row in enumerate ( HEART ): for x , c in enumerate ( row ): oled . pixel ( x + xofs , y + yofs , c ) def random_heart (): xofs = urandom . getrandbits ( 7 ) yofs = urandom . getrandbits ( 6 ) print ( xofs , yofs ) draw_heart ( xofs , yofs ) oled . fill ( 0 ) for n in range ( 10 ): random_heart () oled . show ()","title":"Draw Random Hearts"},{"location":"oled/15-oled-patterns/","text":"OLED Patterns In this lesson, we will show how you can display interesting repeating patterns on your OLED screen. Our program will write a pattern into the framebuffer using a simple math equation. The oled.show() will then update the pattern on the display. This lesson was suggested by Parker Erickson. Math Functions We will use a few unusual functions to create repeating patterns: Modulo (%) Bitwise AND (&) The modulo function is written % . It returns the integer remainder after a division. So 7 % 3 is 1 and 7 % 4 is 3. The Power function of X to the Y power is written in python as pow(x,y) . For example pow(7, 2) is seven squared = 49. The bitwise and is written as x & y 1 2 for i in range ( 8 ): 13 & i Function Returns 13 & 0 0 13 & 1 1 13 & 2 0 13 & 3 1 13 & 4 4 13 & 5 5 13 & 6 4 13 & 7 5 13 & 8 8 13 & 9 9 13 & 10 8 13 & 11 9 13 & 12 12 Some Sample Equations x & y x % y (x ^ y) % 9 (x ^ y) % 5 (x ^ y) % 17 (x ^ y) % 33 (x * y) & 64 (x * y) & 24 (x * y) & 47 (x * 2) % y (x * 64) % y (x * 31) % y ((x-128) * 64) % (y-128) (x % y) % 4 (y % x) % 20 40 % (x % y) Note there are other patterns that use the power pow(x,y) or Exponentiation ** function but I can't get these to work with Micropython. Sample Code This program evaluates the function x % (y+1) for each of the pixels on the screen. If the function returns a non-zero the pixel will be off. If the pixel is zero, the pixel will be on. draw-patterns-ssd1306-spi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import machine import ssd1306 WIDTH = 128 HEIGHT = 64 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) oled . fill ( 0 ) # clear display for x in range ( WIDTH ): for y in range ( HEIGHT ): if x % ( y + 1 ): oled . pixel ( x , y , 0 ) else : oled . pixel ( x , y , 1 ) oled . show () Adding a List of Patterns The Eval Function The eval() function takes any string and passes it to the python interpreter for evaluation within the current context of variables that are in scope. We can use eval to pass an expression that should be evaluated to any function. 1 2 3 4 5 6 7 8 list = [ \"x+y\" , \"x-y\" , \"x*y\" , \"x % (y+1)\" ] for i in range ( 0 , 4 ): print ( list [ i ], ': ' , sep = '' , end = '' ) for x in range ( 5 ): for y in range ( 5 ): print ( eval ( list [ i ]), '' , end = '' ) print ( '' ) Output: 1 2 3 4 x+y: 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 x-y: 0 -1 -2 -3 -4 1 0 -1 -2 -3 2 1 0 -1 -2 3 2 1 0 -1 4 3 2 1 0 x*y: 0 0 0 0 0 0 1 2 3 4 0 2 4 6 8 0 3 6 9 12 0 4 8 12 16 x % (y+1): 0 0 0 0 0 0 1 1 1 1 0 0 2 2 2 0 1 0 3 3 0 0 1 0 4 The Command Design Pattern The command pattern holds a list of commands in an array. Each command is executed in the sequence it appears in the list of commands. In the following program we have the equations in a list. The program steps through each item in the list and displays that equation on the OLED display. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import machine import ssd1306 from utime import sleep , time WIDTH = 128 HEIGHT = 64 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) equations = [ '(x * y) & 24' , '(x * y) & 47' , '(x * y) & 64' , 'x & y' , 'x % y' , '(x % y) % 4' , '40 % (x % y+1)' ] for eqn in range ( 0 , len ( equations )): start = time () oled . fill ( 0 ) # clear display oled . text ( 'calculating' , 0 , 0 , 1 ) oled . text ( equations [ eqn ], 0 , 10 , 1 ) oled . show () for x in range ( WIDTH ): for y in range ( 1 , HEIGHT ): if eval ( equations [ eqn ]): oled . pixel ( x , y , 0 ) else : oled . pixel ( x , y , 1 ) oled . show () sleep ( 5 ) end = time () duration = str ( end - start ) print ( equations [ eqn ]) print ( duration , ' seconds' ) oled . text ( 'done' , 0 , 0 , 1 ) oled . show () print ( 'done' ) Sample Screen Images X Modulo Y x % y (x % y) % 4 Sierpinsky Triangles (x & y) Sierpinsky Triangles Bitwise and of x and y (x * y) & 24 (x * y) & 64 40 % x % (y+1) Reference Martin Kleppe Post on Twitter","title":"OLED Patterns"},{"location":"oled/15-oled-patterns/#oled-patterns","text":"In this lesson, we will show how you can display interesting repeating patterns on your OLED screen. Our program will write a pattern into the framebuffer using a simple math equation. The oled.show() will then update the pattern on the display. This lesson was suggested by Parker Erickson.","title":"OLED Patterns"},{"location":"oled/15-oled-patterns/#math-functions","text":"We will use a few unusual functions to create repeating patterns: Modulo (%) Bitwise AND (&) The modulo function is written % . It returns the integer remainder after a division. So 7 % 3 is 1 and 7 % 4 is 3. The Power function of X to the Y power is written in python as pow(x,y) . For example pow(7, 2) is seven squared = 49. The bitwise and is written as x & y 1 2 for i in range ( 8 ): 13 & i Function Returns 13 & 0 0 13 & 1 1 13 & 2 0 13 & 3 1 13 & 4 4 13 & 5 5 13 & 6 4 13 & 7 5 13 & 8 8 13 & 9 9 13 & 10 8 13 & 11 9 13 & 12 12","title":"Math Functions"},{"location":"oled/15-oled-patterns/#some-sample-equations","text":"x & y x % y (x ^ y) % 9 (x ^ y) % 5 (x ^ y) % 17 (x ^ y) % 33 (x * y) & 64 (x * y) & 24 (x * y) & 47 (x * 2) % y (x * 64) % y (x * 31) % y ((x-128) * 64) % (y-128) (x % y) % 4 (y % x) % 20 40 % (x % y) Note there are other patterns that use the power pow(x,y) or Exponentiation ** function but I can't get these to work with Micropython.","title":"Some Sample Equations"},{"location":"oled/15-oled-patterns/#sample-code","text":"This program evaluates the function x % (y+1) for each of the pixels on the screen. If the function returns a non-zero the pixel will be off. If the pixel is zero, the pixel will be on. draw-patterns-ssd1306-spi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import machine import ssd1306 WIDTH = 128 HEIGHT = 64 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) oled . fill ( 0 ) # clear display for x in range ( WIDTH ): for y in range ( HEIGHT ): if x % ( y + 1 ): oled . pixel ( x , y , 0 ) else : oled . pixel ( x , y , 1 ) oled . show ()","title":"Sample Code"},{"location":"oled/15-oled-patterns/#adding-a-list-of-patterns","text":"","title":"Adding a List of Patterns"},{"location":"oled/15-oled-patterns/#the-eval-function","text":"The eval() function takes any string and passes it to the python interpreter for evaluation within the current context of variables that are in scope. We can use eval to pass an expression that should be evaluated to any function. 1 2 3 4 5 6 7 8 list = [ \"x+y\" , \"x-y\" , \"x*y\" , \"x % (y+1)\" ] for i in range ( 0 , 4 ): print ( list [ i ], ': ' , sep = '' , end = '' ) for x in range ( 5 ): for y in range ( 5 ): print ( eval ( list [ i ]), '' , end = '' ) print ( '' ) Output: 1 2 3 4 x+y: 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 x-y: 0 -1 -2 -3 -4 1 0 -1 -2 -3 2 1 0 -1 -2 3 2 1 0 -1 4 3 2 1 0 x*y: 0 0 0 0 0 0 1 2 3 4 0 2 4 6 8 0 3 6 9 12 0 4 8 12 16 x % (y+1): 0 0 0 0 0 0 1 1 1 1 0 0 2 2 2 0 1 0 3 3 0 0 1 0 4","title":"The Eval Function"},{"location":"oled/15-oled-patterns/#the-command-design-pattern","text":"The command pattern holds a list of commands in an array. Each command is executed in the sequence it appears in the list of commands. In the following program we have the equations in a list. The program steps through each item in the list and displays that equation on the OLED display. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import machine import ssd1306 from utime import sleep , time WIDTH = 128 HEIGHT = 64 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) equations = [ '(x * y) & 24' , '(x * y) & 47' , '(x * y) & 64' , 'x & y' , 'x % y' , '(x % y) % 4' , '40 % (x % y+1)' ] for eqn in range ( 0 , len ( equations )): start = time () oled . fill ( 0 ) # clear display oled . text ( 'calculating' , 0 , 0 , 1 ) oled . text ( equations [ eqn ], 0 , 10 , 1 ) oled . show () for x in range ( WIDTH ): for y in range ( 1 , HEIGHT ): if eval ( equations [ eqn ]): oled . pixel ( x , y , 0 ) else : oled . pixel ( x , y , 1 ) oled . show () sleep ( 5 ) end = time () duration = str ( end - start ) print ( equations [ eqn ]) print ( duration , ' seconds' ) oled . text ( 'done' , 0 , 0 , 1 ) oled . show () print ( 'done' )","title":"The Command Design Pattern"},{"location":"oled/15-oled-patterns/#sample-screen-images","text":"","title":"Sample Screen Images"},{"location":"oled/15-oled-patterns/#x-modulo-y","text":"x % y","title":"X Modulo Y"},{"location":"oled/15-oled-patterns/#x-y-4","text":"","title":"(x % y) % 4"},{"location":"oled/15-oled-patterns/#sierpinsky-triangles-x-y","text":"Sierpinsky Triangles Bitwise and of x and y","title":"Sierpinsky Triangles (x &amp; y)"},{"location":"oled/15-oled-patterns/#x-y-24","text":"","title":"(x * y) &amp; 24"},{"location":"oled/15-oled-patterns/#x-y-64","text":"","title":"(x * y) &amp; 64"},{"location":"oled/15-oled-patterns/#40-x-y1","text":"","title":"40 % x % (y+1)"},{"location":"oled/15-oled-patterns/#reference","text":"Martin Kleppe Post on Twitter","title":"Reference"},{"location":"oled/40-oled-references/","text":"OLED References Analysis of OLED drawing performance using SPI interface Analysis of OLED drawing performance using SPI interface Example of displaying a complex animation on an OLED with SPI Video of the Above on YouTube Peter Hinch's MicroPython Nano GUI","title":"OLED References"},{"location":"oled/40-oled-references/#oled-references","text":"Analysis of OLED drawing performance using SPI interface Analysis of OLED drawing performance using SPI interface Example of displaying a complex animation on an OLED with SPI Video of the Above on YouTube Peter Hinch's MicroPython Nano GUI","title":"OLED References"},{"location":"robots/01-intro/","text":"Introduction to CoderDojo Pico Robots Robots are the most powerful learning machines in our CoderDojo projects. They allow our students to control motion with their own programs. Not only are they incredibly fun for our students, they learn computational thinking and enable them to quickly proceed to our advanced AI Racing League projects. The Raspberry Pi Pico and the Maker Pi RP2040 components have truly been transformative for our clubs. Instead of being trapped in the 2K RAM on our Arduino systems and being forced to learn \"C\", our students are programming in their favorite Python language! Robot Journey Map This section of the course takes you on a tour of our base $25 collision avoidance robots. It then builds on this robot by adding an OLED display, programming controls and servos. Here is a Journey Map of these lessons: Note that the $25 price assumes you purchase low-cost parts from suppliers like eBay. You can lower the cost per robot by purchasing the parts in higher quantities for classroom use. You can also purchase older Arduino robot kits and upgrade the processors to use the Raspberry Pi Pico. Our base robot is a collision avoidance robot that is ideal for teaching beginning robotics principals. The robots have one ore more distance sensors on the front and will continue to move forward until they get near an object in front of them. They then will reverse and turn in another direction. We test our robots on the floor in a \"Robot Corral\" that has six inch high walls. Students can adjust various parameters to allow the robot to navigate around the corral without colliding with the walls. Base Bot - This is the foundational robot that the other projects are built on. The base includes a standard Smart Car chassis, two DC hobby motors, a battery pack and wheels. On top of the chassis we add a breadboard, jumpers, a motor controller, a distance sensor, and our $4 Raspberry Pi microcontroller. Rainbow Bot This takes our base robot and adds a low-cost LED strip so that students can change the color of the LED based on what the robot is sensing and doing. For example when the robot is turning right the LEDs can turn red. IR Sensor Bot This takes our base robot and adds a low-cost LED strip so that students can change the color of the LED based on what the robot is sensing and doing. For example when the robot is turning right the LEDs can turn red. Face Bot - We extend the Base Bot by adding a $4 128x64 OLED display. This allows students to see the values of the distance sensor and to hear a sound when a key event occurs. Adjustable Parameter Bot - We extend the face-bot to add some buttons and knobs to allow our users to change the collision avoidance parameters such as forward speed and turning threshold distance. Parts Our beginning Base Bot Chassis SmartCar Chassis Sensors Ping Ultrasonic Distance Sensor IR sensors Motor Controllers","title":"Introduction"},{"location":"robots/01-intro/#introduction-to-coderdojo-pico-robots","text":"Robots are the most powerful learning machines in our CoderDojo projects. They allow our students to control motion with their own programs. Not only are they incredibly fun for our students, they learn computational thinking and enable them to quickly proceed to our advanced AI Racing League projects. The Raspberry Pi Pico and the Maker Pi RP2040 components have truly been transformative for our clubs. Instead of being trapped in the 2K RAM on our Arduino systems and being forced to learn \"C\", our students are programming in their favorite Python language!","title":"Introduction to CoderDojo Pico Robots"},{"location":"robots/01-intro/#robot-journey-map","text":"This section of the course takes you on a tour of our base $25 collision avoidance robots. It then builds on this robot by adding an OLED display, programming controls and servos. Here is a Journey Map of these lessons: Note that the $25 price assumes you purchase low-cost parts from suppliers like eBay. You can lower the cost per robot by purchasing the parts in higher quantities for classroom use. You can also purchase older Arduino robot kits and upgrade the processors to use the Raspberry Pi Pico. Our base robot is a collision avoidance robot that is ideal for teaching beginning robotics principals. The robots have one ore more distance sensors on the front and will continue to move forward until they get near an object in front of them. They then will reverse and turn in another direction. We test our robots on the floor in a \"Robot Corral\" that has six inch high walls. Students can adjust various parameters to allow the robot to navigate around the corral without colliding with the walls. Base Bot - This is the foundational robot that the other projects are built on. The base includes a standard Smart Car chassis, two DC hobby motors, a battery pack and wheels. On top of the chassis we add a breadboard, jumpers, a motor controller, a distance sensor, and our $4 Raspberry Pi microcontroller. Rainbow Bot This takes our base robot and adds a low-cost LED strip so that students can change the color of the LED based on what the robot is sensing and doing. For example when the robot is turning right the LEDs can turn red. IR Sensor Bot This takes our base robot and adds a low-cost LED strip so that students can change the color of the LED based on what the robot is sensing and doing. For example when the robot is turning right the LEDs can turn red. Face Bot - We extend the Base Bot by adding a $4 128x64 OLED display. This allows students to see the values of the distance sensor and to hear a sound when a key event occurs. Adjustable Parameter Bot - We extend the face-bot to add some buttons and knobs to allow our users to change the collision avoidance parameters such as forward speed and turning threshold distance.","title":"Robot Journey Map"},{"location":"robots/01-intro/#parts","text":"Our beginning Base Bot","title":"Parts"},{"location":"robots/01-intro/#chassis","text":"SmartCar Chassis","title":"Chassis"},{"location":"robots/01-intro/#sensors","text":"Ping Ultrasonic Distance Sensor IR sensors","title":"Sensors"},{"location":"robots/01-intro/#motor-controllers","text":"","title":"Motor Controllers"},{"location":"robots/02-base-bot/","text":"Raspberry Pi Pico Micropython Base Robot This lesson describes out base robot kit in the CoderDojo Twin Cities coding club. This is a new robot that in programmed entirely in python to be consistent with our Python Courses . Base Robot Design Our goal is to build a robotics platform for teaching computational thinking. Here are our main design goals: Low cost (under $25) so that most students can afford their own robot Open platform to make it easy to upgrade (sustainably) Interchangeable parts Minimal amount of soldering Video Here is a video of the collision avoidance robot in action: YouTube Video Note that the forward-speed and distance-before-you-turn can be adjusted. You can see I didn't quite get the distance right and the robot bumps into some of the barriers. Connection Diagram Here is a connection diagram of the base robot. Power Regulation Note that the power comes from the battery at 6 volts and is connected to the input voltage of the motor controller board. The motor controller has a voltage regulator that converts any input voltage from 6 to 12 volts down to 5 volts. The output voltage of the motor controller is then connected to the power rail on the left, which is in turn connected to the VSYS input to the Pico. The Pico, in turn, has another voltage regulator that drop the input from VSYS down to 3.3 volts on the 3.3V OUT pin. This voltage is then used to power the distance sensor. One of the downsides to this design is that as the batteries get low, once they drop below around 5 volts the double voltage drops cause the 3.3 OUT to become too low and the sensor becomes unreliable. A better design would be to find a motor controller that produces a stable 3.3 volts as the batteries slowly run down. Let us know if you can find one of these designs that cost under $2. Hardware Description Here is a summary of some of the parts we use in this robot and their approximate prices as of June 2021. Some parts come from China so you might need to wait 2-3 weeks for them to arrive. Here is a Google sheet with these parts: Detailed Parts List Google Sheet Two Wheel Drive Smart Car Chassis Our cars all use a standard Two Wheel Drive (2WD) SmartCar Chassis that is available in many retail outlets online. $5 Cytron 2WD Smart Car Chassis YouTube Video of Assembly - note that he does not remove the backing paper on the Plexiglass and he mounts the battery on the top. We like ours on the bottom. Motor Driver Software All software is written in MicroPython. Time-of-Flight Distance Sensor We are using the VL53L0X time-of-flight distance sensor. This works on an I2C bus. After you have hooked up the Power (VCC to the 3.3 rail and GND) you must hook up the I2C data and clock. 1 2 3 sda = machine . Pin ( 16 ) # Lower right corner of the Pico with the USB on top scl = machine . Pin ( 17 ) # One up from the lower right corner of the Pico i2c = machine . I2C ( 0 , sda = sda , scl = scl ) Many of our older robots used the ultrasonic ping sensors. The are unreliable with voltage drops as our batteries wear down. Testing the Sensor Connections with the I2C Scanner 1 2 3 4 5 import machine sda = machine . Pin ( 16 ) # Lower right corner of the Pico with the USB on top scl = machine . Pin ( 17 ) # One up from the lower right corner of the Pico i2c = machine . I2C ( 0 , sda = sda , scl = scl ) print ( \"Device found at decimal\" , i2c . scan ()) You should see a decimal number returned. By default the I2C address is 41 (decimal) or x29 (hexadecimal). Download the VL53L0X Driver You will need to add a VL53L0X driver file to the file system on the pico. We have a copy here: https://raw.githubusercontent.com/CoderDojoTC/micropython/main/src/drivers/VL53L0X.py Time-of-Flight Sensor Test Once the driver file is loaded we are ready to test the time-of-flight distance sensor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import time from machine import Pin from machine import I2C import VL53L0X sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) tof . start () # startup the sensor while True : # Start ranging dist = tof . read () print ( dist ) time . sleep ( . 1 ) When you run this program a sequence of integers will appear in the console. The numbers usually will range from around 30 if there is an object directly in front of the sensor to a number around 1,300 for a object that is about 1.3 meters away from the sensor. There is a 1/10th of a second pause between each measurement. This can be changed in the last line of the program. Motor Drive Test After we have the four wires connected to the motor driver, we need to make sure we get the right wires to the right motors and motor directions. This program will help you debug this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from machine import Pin , PWM import time # sleep POWER_LEVEL = 65025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse ) One thing to remember is that the \"Right\" refers to our orientation from the rear of the car or if we were sitting inside the car. If the robot is facing you with the sensor in the front, it is the wheel on the left that we call the \"RIGHT\" wheel. Very confusing! Using this naming convention will pay of as we are walking behind larger robots. Sample Drive and Turn Functions We will need a set of function to drive our robot: Forward: both wheels going forward Reverse: both wheels going in reverse Turn Right: The right wheel turning backward and the left going forward Turn Left: The left wheel turning backward and the right wheel going forward Stop: all motors off Our challenge is for each of these operations we must change the value of all four PWM signals. We can never have a motor be going both forward and reverse. Here are some sample drive functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) Turning Logic 1 2 3 4 5 6 7 8 9 10 while True : dist = read_sensor () if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () sleep ( BACKUP_TIME ) turn_right () sleep ( TURN_TIME ) else : forward () Test Motor Connections 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from machine import Pin , PWM import time # sleep POWER_LEVEL = 65025 # usually a number from 30,000 to max of 65,025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse ) After you load this program, watch which wheels turn and in what direction. Drive Functions We will define Python functions for forward, reverse, turn right and turn left. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 POWER_LEVEL = 65025 def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) Stop All Motors Program One other thing to remember is that the PWM signals continue to be generated even after the main loop has stopped. This is because on the Pico, the four PWM signals are being continuously generated by an independent processors. To stop the motors you must run a separate stop program like this: stop-all-motors.py: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from machine import Pin , PWM from time import sleep # lower right pins with USB on top RIGHT_FORWARD_PIN = 19 RIGHT_REVERSE_PIN = 21 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 20 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) right_forward . duty_u16 ( 0 ) right_reverse . duty_u16 ( 0 ) left_forward . duty_u16 ( 0 ) left_reverse . duty_u16 ( 0 ) This can be frustrating at times when you can't find the stop program. I like to bring the stop program up in a separate tab when I am writing robot motor code. To figure out how to write an interrup handler so that when the IDE STOP function is pressed the stop motors (and speaker) are stopped. Collision Avoidance Logic Final Program To get this to work on battery power up you must name the program main.py and save it on the Raspberry Pi Pico. Note Make sure you have the VL53L0X distance sensor driver installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 from machine import Pin , PWM from utime import sleep import VL53L0X # used to blink the onboard LED led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) # driving parameters POWER_LEVEL = 65025 # use a value from 20000 to 65025 TURN_THRESHOLD = 400 # 25 cm TURN_TIME = . 25 # seconds of turning BACKUP_TIME = . 75 # seconds of backing up if obstacle detected # Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 # setup the PWM objects right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) def read_sensor_avg (): total = 0 for i in range ( 10 ): total = total + tof . read () sleep ( . 01 ) return int ( total / 10 ) tof . start () # startup the sensor while True : dist = read_sensor_avg (); print ( dist ) if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () sleep ( BACKUP_TIME ) led_onboard . high () turn_right () sleep ( TURN_TIME ) else : if dist > 1300 : print ( 'no signal' ) led_onboard . low () else : print ( 'Go forward' ) led_onboard . high () forward () More To Explore Labs Can you change the hard-coded parameters at the begging of the program? What happens when you make the POWER_LEVEL go too high and the TURN_THRESHOLD too low? What is the lowest POWER_LEVEL that will allow the robot to move? What if you changed the power from 6 volts to be 9 volts by adding two more AA batteries? Can you randomly turn right or left if you encounter and object? Note you will need to import the random library and generate a random number between 0 and 2 with the random.randint(0,2) function. How would you design a robot that you could adjust the parameters? What parameters would you change? What would their valid ranges be?","title":"Base Bot"},{"location":"robots/02-base-bot/#raspberry-pi-pico-micropython-base-robot","text":"This lesson describes out base robot kit in the CoderDojo Twin Cities coding club. This is a new robot that in programmed entirely in python to be consistent with our Python Courses .","title":"Raspberry Pi Pico Micropython Base Robot"},{"location":"robots/02-base-bot/#base-robot-design","text":"Our goal is to build a robotics platform for teaching computational thinking. Here are our main design goals: Low cost (under $25) so that most students can afford their own robot Open platform to make it easy to upgrade (sustainably) Interchangeable parts Minimal amount of soldering","title":"Base Robot Design"},{"location":"robots/02-base-bot/#video","text":"Here is a video of the collision avoidance robot in action: YouTube Video Note that the forward-speed and distance-before-you-turn can be adjusted. You can see I didn't quite get the distance right and the robot bumps into some of the barriers.","title":"Video"},{"location":"robots/02-base-bot/#connection-diagram","text":"Here is a connection diagram of the base robot.","title":"Connection Diagram"},{"location":"robots/02-base-bot/#power-regulation","text":"Note that the power comes from the battery at 6 volts and is connected to the input voltage of the motor controller board. The motor controller has a voltage regulator that converts any input voltage from 6 to 12 volts down to 5 volts. The output voltage of the motor controller is then connected to the power rail on the left, which is in turn connected to the VSYS input to the Pico. The Pico, in turn, has another voltage regulator that drop the input from VSYS down to 3.3 volts on the 3.3V OUT pin. This voltage is then used to power the distance sensor. One of the downsides to this design is that as the batteries get low, once they drop below around 5 volts the double voltage drops cause the 3.3 OUT to become too low and the sensor becomes unreliable. A better design would be to find a motor controller that produces a stable 3.3 volts as the batteries slowly run down. Let us know if you can find one of these designs that cost under $2.","title":"Power Regulation"},{"location":"robots/02-base-bot/#hardware-description","text":"Here is a summary of some of the parts we use in this robot and their approximate prices as of June 2021. Some parts come from China so you might need to wait 2-3 weeks for them to arrive. Here is a Google sheet with these parts: Detailed Parts List Google Sheet","title":"Hardware Description"},{"location":"robots/02-base-bot/#two-wheel-drive-smart-car-chassis","text":"Our cars all use a standard Two Wheel Drive (2WD) SmartCar Chassis that is available in many retail outlets online. $5 Cytron 2WD Smart Car Chassis YouTube Video of Assembly - note that he does not remove the backing paper on the Plexiglass and he mounts the battery on the top. We like ours on the bottom.","title":"Two Wheel Drive Smart Car Chassis"},{"location":"robots/02-base-bot/#motor-driver","text":"","title":"Motor Driver"},{"location":"robots/02-base-bot/#software","text":"All software is written in MicroPython.","title":"Software"},{"location":"robots/02-base-bot/#time-of-flight-distance-sensor","text":"We are using the VL53L0X time-of-flight distance sensor. This works on an I2C bus. After you have hooked up the Power (VCC to the 3.3 rail and GND) you must hook up the I2C data and clock. 1 2 3 sda = machine . Pin ( 16 ) # Lower right corner of the Pico with the USB on top scl = machine . Pin ( 17 ) # One up from the lower right corner of the Pico i2c = machine . I2C ( 0 , sda = sda , scl = scl ) Many of our older robots used the ultrasonic ping sensors. The are unreliable with voltage drops as our batteries wear down.","title":"Time-of-Flight Distance Sensor"},{"location":"robots/02-base-bot/#testing-the-sensor-connections-with-the-i2c-scanner","text":"1 2 3 4 5 import machine sda = machine . Pin ( 16 ) # Lower right corner of the Pico with the USB on top scl = machine . Pin ( 17 ) # One up from the lower right corner of the Pico i2c = machine . I2C ( 0 , sda = sda , scl = scl ) print ( \"Device found at decimal\" , i2c . scan ()) You should see a decimal number returned. By default the I2C address is 41 (decimal) or x29 (hexadecimal).","title":"Testing the Sensor Connections with the I2C Scanner"},{"location":"robots/02-base-bot/#download-the-vl53l0x-driver","text":"You will need to add a VL53L0X driver file to the file system on the pico. We have a copy here: https://raw.githubusercontent.com/CoderDojoTC/micropython/main/src/drivers/VL53L0X.py","title":"Download the VL53L0X Driver"},{"location":"robots/02-base-bot/#time-of-flight-sensor-test","text":"Once the driver file is loaded we are ready to test the time-of-flight distance sensor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import time from machine import Pin from machine import I2C import VL53L0X sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) tof . start () # startup the sensor while True : # Start ranging dist = tof . read () print ( dist ) time . sleep ( . 1 ) When you run this program a sequence of integers will appear in the console. The numbers usually will range from around 30 if there is an object directly in front of the sensor to a number around 1,300 for a object that is about 1.3 meters away from the sensor. There is a 1/10th of a second pause between each measurement. This can be changed in the last line of the program.","title":"Time-of-Flight Sensor Test"},{"location":"robots/02-base-bot/#motor-drive-test","text":"After we have the four wires connected to the motor driver, we need to make sure we get the right wires to the right motors and motor directions. This program will help you debug this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from machine import Pin , PWM import time # sleep POWER_LEVEL = 65025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse ) One thing to remember is that the \"Right\" refers to our orientation from the rear of the car or if we were sitting inside the car. If the robot is facing you with the sensor in the front, it is the wheel on the left that we call the \"RIGHT\" wheel. Very confusing! Using this naming convention will pay of as we are walking behind larger robots.","title":"Motor Drive Test"},{"location":"robots/02-base-bot/#sample-drive-and-turn-functions","text":"We will need a set of function to drive our robot: Forward: both wheels going forward Reverse: both wheels going in reverse Turn Right: The right wheel turning backward and the left going forward Turn Left: The left wheel turning backward and the right wheel going forward Stop: all motors off Our challenge is for each of these operations we must change the value of all four PWM signals. We can never have a motor be going both forward and reverse. Here are some sample drive functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse )","title":"Sample Drive and Turn Functions"},{"location":"robots/02-base-bot/#turning-logic","text":"1 2 3 4 5 6 7 8 9 10 while True : dist = read_sensor () if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () sleep ( BACKUP_TIME ) turn_right () sleep ( TURN_TIME ) else : forward ()","title":"Turning Logic"},{"location":"robots/02-base-bot/#test-motor-connections","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from machine import Pin , PWM import time # sleep POWER_LEVEL = 65025 # usually a number from 30,000 to max of 65,025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse ) After you load this program, watch which wheels turn and in what direction.","title":"Test Motor Connections"},{"location":"robots/02-base-bot/#drive-functions","text":"We will define Python functions for forward, reverse, turn right and turn left. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 POWER_LEVEL = 65025 def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse )","title":"Drive Functions"},{"location":"robots/02-base-bot/#stop-all-motors-program","text":"One other thing to remember is that the PWM signals continue to be generated even after the main loop has stopped. This is because on the Pico, the four PWM signals are being continuously generated by an independent processors. To stop the motors you must run a separate stop program like this: stop-all-motors.py: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from machine import Pin , PWM from time import sleep # lower right pins with USB on top RIGHT_FORWARD_PIN = 19 RIGHT_REVERSE_PIN = 21 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 20 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) right_forward . duty_u16 ( 0 ) right_reverse . duty_u16 ( 0 ) left_forward . duty_u16 ( 0 ) left_reverse . duty_u16 ( 0 ) This can be frustrating at times when you can't find the stop program. I like to bring the stop program up in a separate tab when I am writing robot motor code. To figure out how to write an interrup handler so that when the IDE STOP function is pressed the stop motors (and speaker) are stopped.","title":"Stop All Motors Program"},{"location":"robots/02-base-bot/#collision-avoidance-logic","text":"","title":"Collision Avoidance Logic"},{"location":"robots/02-base-bot/#final-program","text":"To get this to work on battery power up you must name the program main.py and save it on the Raspberry Pi Pico. Note Make sure you have the VL53L0X distance sensor driver installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 from machine import Pin , PWM from utime import sleep import VL53L0X # used to blink the onboard LED led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) # driving parameters POWER_LEVEL = 65025 # use a value from 20000 to 65025 TURN_THRESHOLD = 400 # 25 cm TURN_TIME = . 25 # seconds of turning BACKUP_TIME = . 75 # seconds of backing up if obstacle detected # Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 # setup the PWM objects right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) def read_sensor_avg (): total = 0 for i in range ( 10 ): total = total + tof . read () sleep ( . 01 ) return int ( total / 10 ) tof . start () # startup the sensor while True : dist = read_sensor_avg (); print ( dist ) if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () sleep ( BACKUP_TIME ) led_onboard . high () turn_right () sleep ( TURN_TIME ) else : if dist > 1300 : print ( 'no signal' ) led_onboard . low () else : print ( 'Go forward' ) led_onboard . high () forward ()","title":"Final Program"},{"location":"robots/02-base-bot/#more-to-explore-labs","text":"Can you change the hard-coded parameters at the begging of the program? What happens when you make the POWER_LEVEL go too high and the TURN_THRESHOLD too low? What is the lowest POWER_LEVEL that will allow the robot to move? What if you changed the power from 6 volts to be 9 volts by adding two more AA batteries? Can you randomly turn right or left if you encounter and object? Note you will need to import the random library and generate a random number between 0 and 2 with the random.randint(0,2) function. How would you design a robot that you could adjust the parameters? What parameters would you change? What would their valid ranges be?","title":"More To Explore Labs"},{"location":"robots/03-ir-sensor-bot/","text":"IR Collision Avoidance Bot Instead of our time-of-flight sensor used in our base robot, this robot uses three low-cost IR distance sensors. Purchasing IR Distance Sensors Connecting the IR Sensors 1 2 3 4 # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) Connecting the Speaker This robot has an optional speaker connected to GPIO Pin 21. This allows us to \"hear\" what signals are coming into the robot It will generate a different tone if the left, center or right sensor is detecting an object and an different tone for going straight, reversing and turning. The speaker is a small buzzer or a Piezoelectric speaker that can be purchased for around $1. It has one wire connected to the GPIO pin and the other connected to any GND pin or GND rail on the breadboard. Here are the lines related to setting up the speaker code. 1 2 3 SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) Drive Logic The three IR sensors go LOW if there is an item in front of them. So the statement: 1 center . value () will normally be HIGH if there is nothing in front of the robot. Our main logic look will look like the following: 1 2 3 4 5 6 7 8 9 while True : if left . value () == 0 : turn_right () if center . value () == 0 : reverse () if right . value () == 0 : turn_left () if left . value () and center . value () and right . value (): forward () Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 from machine import Pin , PWM from utime import sleep import ssd1306 # Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 17 RIGHT_REVERSE_PIN = 16 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) WIDTH = 128 HEIGHT = 64 CS = machine . Pin ( 1 ) SCL = machine . Pin ( 2 ) SDA = machine . Pin ( 3 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) spi = machine . SPI ( 0 , sck = SCL , mosi = SDA ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) def turn_motor_on ( pwm ): pwm . duty_u16 ( 65025 ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) def sound_off (): speaker . duty_u16 ( 0 ) def left_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 700 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second sound_off () def center_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 900 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 5 ) sound_off () def forward_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 1 ) speaker . freq ( 900 ) sleep ( . 1 ) speaker . freq ( 1200 ) sleep ( . 1 ) sound_off () def update_oled (): oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks!\" , 0 , 0 , 1 ) oled . text ( \"Left:\" , 0 , 10 , 1 ) oled . text ( str ( left . value ()), 50 , 10 , 1 ) oled . text ( \"Center:\" , 0 , 20 , 1 ) oled . text ( str ( center . value ()), 60 , 20 , 1 ) oled . text ( \"Right:\" , 0 , 30 , 1 ) oled . text ( str ( right . value ()), 55 , 30 , 1 ) BAR_WIDTH = 40 BAR_HEIGHT = 20 if left . value (): oled . fill_rect ( WIDTH - 40 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( WIDTH - 40 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) if center . value (): oled . fill_rect ( 50 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( 50 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) if right . value (): oled . fill_rect ( 0 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( 0 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) oled . show () # 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 counter = 0 while True : if left . value () == 0 : print ( 'Left' ) #left_tone() turn_right () update_oled () drive_state = 2 if center . value () == 0 : print ( 'Center' ) center_tone () reverse () update_oled () drive_state = 0 if right . value () == 0 : print ( 'Right' ) #right_tone() turn_left () update_oled () drive_state = 3 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left . value () and center . value () and right . value (): print ( 'Go forward!' ) drive_state = 1 # forward_tone() forward () update_oled () print ( \"counter: \" , counter ) counter += 1 sleep ( . 25 ) Pins GP6, 7, 8 and 9","title":"IR Sensor Bot"},{"location":"robots/03-ir-sensor-bot/#ir-collision-avoidance-bot","text":"Instead of our time-of-flight sensor used in our base robot, this robot uses three low-cost IR distance sensors.","title":"IR Collision Avoidance Bot"},{"location":"robots/03-ir-sensor-bot/#purchasing-ir-distance-sensors","text":"","title":"Purchasing IR Distance Sensors"},{"location":"robots/03-ir-sensor-bot/#connecting-the-ir-sensors","text":"1 2 3 4 # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN )","title":"Connecting the IR Sensors"},{"location":"robots/03-ir-sensor-bot/#connecting-the-speaker","text":"This robot has an optional speaker connected to GPIO Pin 21. This allows us to \"hear\" what signals are coming into the robot It will generate a different tone if the left, center or right sensor is detecting an object and an different tone for going straight, reversing and turning. The speaker is a small buzzer or a Piezoelectric speaker that can be purchased for around $1. It has one wire connected to the GPIO pin and the other connected to any GND pin or GND rail on the breadboard. Here are the lines related to setting up the speaker code. 1 2 3 SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN ))","title":"Connecting the Speaker"},{"location":"robots/03-ir-sensor-bot/#drive-logic","text":"The three IR sensors go LOW if there is an item in front of them. So the statement: 1 center . value () will normally be HIGH if there is nothing in front of the robot. Our main logic look will look like the following: 1 2 3 4 5 6 7 8 9 while True : if left . value () == 0 : turn_right () if center . value () == 0 : reverse () if right . value () == 0 : turn_left () if left . value () and center . value () and right . value (): forward ()","title":"Drive Logic"},{"location":"robots/03-ir-sensor-bot/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 from machine import Pin , PWM from utime import sleep import ssd1306 # Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 17 RIGHT_REVERSE_PIN = 16 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) WIDTH = 128 HEIGHT = 64 CS = machine . Pin ( 1 ) SCL = machine . Pin ( 2 ) SDA = machine . Pin ( 3 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) spi = machine . SPI ( 0 , sck = SCL , mosi = SDA ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) def turn_motor_on ( pwm ): pwm . duty_u16 ( 65025 ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) def sound_off (): speaker . duty_u16 ( 0 ) def left_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 700 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second sound_off () def center_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 900 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 5 ) sound_off () def forward_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 1 ) speaker . freq ( 900 ) sleep ( . 1 ) speaker . freq ( 1200 ) sleep ( . 1 ) sound_off () def update_oled (): oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks!\" , 0 , 0 , 1 ) oled . text ( \"Left:\" , 0 , 10 , 1 ) oled . text ( str ( left . value ()), 50 , 10 , 1 ) oled . text ( \"Center:\" , 0 , 20 , 1 ) oled . text ( str ( center . value ()), 60 , 20 , 1 ) oled . text ( \"Right:\" , 0 , 30 , 1 ) oled . text ( str ( right . value ()), 55 , 30 , 1 ) BAR_WIDTH = 40 BAR_HEIGHT = 20 if left . value (): oled . fill_rect ( WIDTH - 40 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( WIDTH - 40 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) if center . value (): oled . fill_rect ( 50 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( 50 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) if right . value (): oled . fill_rect ( 0 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( 0 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) oled . show () # 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 counter = 0 while True : if left . value () == 0 : print ( 'Left' ) #left_tone() turn_right () update_oled () drive_state = 2 if center . value () == 0 : print ( 'Center' ) center_tone () reverse () update_oled () drive_state = 0 if right . value () == 0 : print ( 'Right' ) #right_tone() turn_left () update_oled () drive_state = 3 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left . value () and center . value () and right . value (): print ( 'Go forward!' ) drive_state = 1 # forward_tone() forward () update_oled () print ( \"counter: \" , counter ) counter += 1 sleep ( . 25 ) Pins GP6, 7, 8 and 9","title":"Full Program"},{"location":"robots/03-rainbow-bot/","text":"Rainbow Bot This robot takes our base robot and adds an LED strip arranged in a 12X6 pixel grid to display colors and patterns based on what the robot is doing or thinking about. We use the same materials as our Base Robot but we add a low-cost addressable LED strips that are easy to hook up with just power, ground and data wires added to our breadboard. The LED is known as an addressable LED strip since you can individually program each LED. The standard is called the WS-2812B LED strip and is often called a NeoPixel LED strip (The Adafruit Term). We also used a Python library called a Neopixel micropython library, although the library is not created or maintained by Adafruit. Of course, you can also add longer LED strips and program the patterns in interesting ways. Part 1: Ordering The LED Strip The LED strips come in a variety of lengths, density and packing. We use the 1 meter long strips that have 60 pixels/meter. These strips are easy to cut apart and solder. We like the black backgrounds but they also come with white. The LED strips come with three packaging options: No waterproofing - these are fine for our indoor robots Waterproofing with the strips coated in silicon rubber called IP65 waterproofing Waterproofing with the strips encased in a flexible rubber sleeve The waterproofing options tend to be a little more expensive but can also provide a bit more protection for the components on the strips. Waterproofing keeps moisture and dust out of the circuits, but does not mean that they can be submerged under water. A sample place to purchase them is here We can take a $3 strip of 60 LEDs and cut them up into six segments of 10 LEDs each for a cost of around 50 cents per strip. We solder stranded wire to the segments and then put 22 gauge solid wire to make them easy to put in the breadboards. Connecting the LED Strips Adding a Standoff Upgrading to 9 Volt Power Our base robot only needed power for the motors. This robot has 72 RGB LEDs so it might draw more power. So we upgraded the 6 volt battery pack with 4 AA batteries to two packs of 3 batteries for a total of 9 volts. This allows the robot to continue to run even when the batteries are partially drained. The battery packs must be wired in series to deliver the full 9 volts to the input of the motor controller where it powers the motors and also runs though a voltage regulator to power the reset of the robot. 72 Pixel Configuration Here is the top view of the LEDs shining through the clear plexiglass. You can see the individual LEDs in this configuration. By adding a small space between the plexiglass and a diffusion layer you can get a much more uniform color distribution over the top surface of the robot. Part 2: Making The Connections The LED strips use 5 volts of power and have a GND and a data connector. To make the connections we connect the center pin to Pin 0 (upper left corner of the Pico), the GND to the ground rail and the 5 volt to the 5 volt power rail. Part 3: Adding the Neopixel Library Part 4: Testing Your Code In our first test, we will just make the first pixel on the LED strip blink bright red. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import machine , neopixel , time # Set the pin number and number of pixels LED_PIN = machine . Pin ( 4 ) NUMBER_PIXELS = 12 np = neopixel . NeoPixel ( LED_PIN , NUMBER_PIXELS ) # blink the first pixel red while True : np [ 0 ] = ( 255 , 0 , 0 ) np . write () time . sleep ( 1 ) np [ 0 ] = ( 0 , 0 , 0 ) np . write () time . sleep ( 1 ) Functions For Drawing on Matrix The numbering of the pixels is a bit odd. The first 12 are 0 to 11, but the second 12 pixels are in reverse order, so the second row counts from 23 down to 13. Here are some functions that demonstrate this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import time from neopixel import Neopixel numpix = 72 strip = Neopixel ( numpix , 0 , 0 , \"GRB\" ) red = ( 255 , 0 , 0 ) orange = ( 255 , 150 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) colors = ( red , orange , yellow , green , blue , indigo , violet ) strip . brightness ( 255 ) def color_wipe (): for color in colors : for i in range ( numpix ): strip . set_pixel ( i , color ) strip . show () time . sleep ( 0.01 ) def color_wipe_2 (): for color in colors : for i in range ( 12 ): strip . set_pixel ( i , color ) strip . set_pixel ( i + 12 , color ) strip . set_pixel ( i + 24 , color ) strip . set_pixel ( i + 36 , color ) strip . set_pixel ( i + 48 , color ) strip . set_pixel ( i + 60 , color ) strip . show () time . sleep ( 0.01 ) def color_wipe_3 (): for color in colors : for i in range ( 12 ): strip . set_pixel ( i , color ) strip . set_pixel ( 23 - i , color ) strip . set_pixel ( i + 24 , color ) strip . set_pixel ( 47 - i , color ) strip . set_pixel ( 48 + i , color ) strip . set_pixel ( 71 - i , color ) strip . show () time . sleep ( 0.3 ) # offset is the color to start (0 to 6) # dir is 1 for forward and -1 for reverse def color_wipe_4 ( offset , dir ): for i in range ( 12 ): if dir == 1 : this_color = colors [ (( i - offset ) % 7 )] else : this_color = colors [ (( i + offset ) % 7 )] strip . set_pixel ( i , this_color ) strip . set_pixel ( 23 - i , this_color ) strip . set_pixel ( i + 24 , this_color ) strip . set_pixel ( 47 - i , this_color ) strip . set_pixel ( 48 + i , this_color ) strip . set_pixel ( 71 - i , this_color ) strip . show () # time.sleep(0.01) while True : for counter in range ( 100 ): color_wipe_4 ( counter % 7 , 1 ) for counter in range ( 100 ): color_wipe_4 ( counter % 7 , - 1 ) Full Source Code We now combine the motor controls, the distance sensor and the LED functions so that a moving rainbow pattern moves from to back as the robot moves forward. If the robot encounters an obstacle, the robot will backup and change the direction of the rainbow. After it backs up a bit it will turn and move forward again. main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 from machine import Pin , PWM from time import sleep from machine import Pin from machine import I2C import VL53L0X from neopixel import Neopixel # Motor Code # lower right pins with USB on top RIGHT_FORWARD_PIN = 19 RIGHT_REVERSE_PIN = 18 LEFT_FORWARD_PIN = 20 LEFT_REVERSE_PIN = 21 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # Sensor Code sda = machine . Pin ( 16 ) scl = machine . Pin ( 17 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) tof . start () # startup the sensor # used to blink the onboard LED led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) # LED Code numpix = 72 strip = Neopixel ( numpix , 0 , 0 , \"GRB\" ) # we turn the brightness way down to not oversaturate the brightness in the video strip . brightness ( 20 ) # driving parameters POWER_LEVEL = 30000 # use a value from 20000 to 65025 TURN_THRESHOLD = 400 # 25 cm TURN_TIME = . 25 # seconds of turning BACKUP_TIME = . 75 # seconds of backing up if obstacle detected red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) colors = ( red , orange , yellow , green , blue , indigo , violet ) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) #for i in range(numpix): # strip.set_pixel(i, green) #strip.show() def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) #for i in range(numpix): # strip.set_pixel(i, red) #strip.show() def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) #for i in range(numpix): # strip.set_pixel(i, blue) #strip.show() def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) #for i in range(numpix): # strip.set_pixel(i, yellow) #strip.show() def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) for i in range ( numpix ): strip . set_pixel ( i , violet ) strip . show () def read_sensor_avg (): total = 0 for i in range ( 10 ): total = total + tof . read () sleep ( . 01 ) return int ( total / 10 ) # offset is the color to start (0 to 6) # dir is 1 for forward and -1 for reverse def color_wipe_4 ( offset , dir ): for i in range ( 12 ): if dir == 1 : this_color = colors [ (( i - offset ) % 7 )] else : this_color = colors [ (( i + offset ) % 7 )] strip . set_pixel ( i , this_color ) strip . set_pixel ( 23 - i , this_color ) strip . set_pixel ( i + 24 , this_color ) strip . set_pixel ( 47 - i , this_color ) strip . set_pixel ( 48 + i , this_color ) strip . set_pixel ( 71 - i , this_color ) strip . show () # time.sleep(0.01) counter = 0 while True : dist = read_sensor_avg () if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 turn_right () color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 else : forward () color_wipe_4 ( counter % 7 , 1 ) counter += 1 Rainbow Bot Source Code References Micropython NeoPixel Library","title":"Rainbow Bot"},{"location":"robots/03-rainbow-bot/#rainbow-bot","text":"This robot takes our base robot and adds an LED strip arranged in a 12X6 pixel grid to display colors and patterns based on what the robot is doing or thinking about. We use the same materials as our Base Robot but we add a low-cost addressable LED strips that are easy to hook up with just power, ground and data wires added to our breadboard. The LED is known as an addressable LED strip since you can individually program each LED. The standard is called the WS-2812B LED strip and is often called a NeoPixel LED strip (The Adafruit Term). We also used a Python library called a Neopixel micropython library, although the library is not created or maintained by Adafruit. Of course, you can also add longer LED strips and program the patterns in interesting ways.","title":"Rainbow Bot"},{"location":"robots/03-rainbow-bot/#part-1-ordering-the-led-strip","text":"The LED strips come in a variety of lengths, density and packing. We use the 1 meter long strips that have 60 pixels/meter. These strips are easy to cut apart and solder. We like the black backgrounds but they also come with white. The LED strips come with three packaging options: No waterproofing - these are fine for our indoor robots Waterproofing with the strips coated in silicon rubber called IP65 waterproofing Waterproofing with the strips encased in a flexible rubber sleeve The waterproofing options tend to be a little more expensive but can also provide a bit more protection for the components on the strips. Waterproofing keeps moisture and dust out of the circuits, but does not mean that they can be submerged under water. A sample place to purchase them is here We can take a $3 strip of 60 LEDs and cut them up into six segments of 10 LEDs each for a cost of around 50 cents per strip. We solder stranded wire to the segments and then put 22 gauge solid wire to make them easy to put in the breadboards.","title":"Part 1: Ordering The LED Strip"},{"location":"robots/03-rainbow-bot/#connecting-the-led-strips","text":"","title":"Connecting the LED Strips"},{"location":"robots/03-rainbow-bot/#adding-a-standoff","text":"","title":"Adding a Standoff"},{"location":"robots/03-rainbow-bot/#upgrading-to-9-volt-power","text":"Our base robot only needed power for the motors. This robot has 72 RGB LEDs so it might draw more power. So we upgraded the 6 volt battery pack with 4 AA batteries to two packs of 3 batteries for a total of 9 volts. This allows the robot to continue to run even when the batteries are partially drained. The battery packs must be wired in series to deliver the full 9 volts to the input of the motor controller where it powers the motors and also runs though a voltage regulator to power the reset of the robot.","title":"Upgrading to 9 Volt Power"},{"location":"robots/03-rainbow-bot/#72-pixel-configuration","text":"Here is the top view of the LEDs shining through the clear plexiglass. You can see the individual LEDs in this configuration. By adding a small space between the plexiglass and a diffusion layer you can get a much more uniform color distribution over the top surface of the robot.","title":"72 Pixel Configuration"},{"location":"robots/03-rainbow-bot/#part-2-making-the-connections","text":"The LED strips use 5 volts of power and have a GND and a data connector. To make the connections we connect the center pin to Pin 0 (upper left corner of the Pico), the GND to the ground rail and the 5 volt to the 5 volt power rail.","title":"Part 2: Making The Connections"},{"location":"robots/03-rainbow-bot/#part-3-adding-the-neopixel-library","text":"","title":"Part 3: Adding the Neopixel Library"},{"location":"robots/03-rainbow-bot/#part-4-testing-your-code","text":"In our first test, we will just make the first pixel on the LED strip blink bright red. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import machine , neopixel , time # Set the pin number and number of pixels LED_PIN = machine . Pin ( 4 ) NUMBER_PIXELS = 12 np = neopixel . NeoPixel ( LED_PIN , NUMBER_PIXELS ) # blink the first pixel red while True : np [ 0 ] = ( 255 , 0 , 0 ) np . write () time . sleep ( 1 ) np [ 0 ] = ( 0 , 0 , 0 ) np . write () time . sleep ( 1 )","title":"Part 4: Testing Your Code"},{"location":"robots/03-rainbow-bot/#functions-for-drawing-on-matrix","text":"The numbering of the pixels is a bit odd. The first 12 are 0 to 11, but the second 12 pixels are in reverse order, so the second row counts from 23 down to 13. Here are some functions that demonstrate this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import time from neopixel import Neopixel numpix = 72 strip = Neopixel ( numpix , 0 , 0 , \"GRB\" ) red = ( 255 , 0 , 0 ) orange = ( 255 , 150 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) colors = ( red , orange , yellow , green , blue , indigo , violet ) strip . brightness ( 255 ) def color_wipe (): for color in colors : for i in range ( numpix ): strip . set_pixel ( i , color ) strip . show () time . sleep ( 0.01 ) def color_wipe_2 (): for color in colors : for i in range ( 12 ): strip . set_pixel ( i , color ) strip . set_pixel ( i + 12 , color ) strip . set_pixel ( i + 24 , color ) strip . set_pixel ( i + 36 , color ) strip . set_pixel ( i + 48 , color ) strip . set_pixel ( i + 60 , color ) strip . show () time . sleep ( 0.01 ) def color_wipe_3 (): for color in colors : for i in range ( 12 ): strip . set_pixel ( i , color ) strip . set_pixel ( 23 - i , color ) strip . set_pixel ( i + 24 , color ) strip . set_pixel ( 47 - i , color ) strip . set_pixel ( 48 + i , color ) strip . set_pixel ( 71 - i , color ) strip . show () time . sleep ( 0.3 ) # offset is the color to start (0 to 6) # dir is 1 for forward and -1 for reverse def color_wipe_4 ( offset , dir ): for i in range ( 12 ): if dir == 1 : this_color = colors [ (( i - offset ) % 7 )] else : this_color = colors [ (( i + offset ) % 7 )] strip . set_pixel ( i , this_color ) strip . set_pixel ( 23 - i , this_color ) strip . set_pixel ( i + 24 , this_color ) strip . set_pixel ( 47 - i , this_color ) strip . set_pixel ( 48 + i , this_color ) strip . set_pixel ( 71 - i , this_color ) strip . show () # time.sleep(0.01) while True : for counter in range ( 100 ): color_wipe_4 ( counter % 7 , 1 ) for counter in range ( 100 ): color_wipe_4 ( counter % 7 , - 1 )","title":"Functions For Drawing on Matrix"},{"location":"robots/03-rainbow-bot/#full-source-code","text":"We now combine the motor controls, the distance sensor and the LED functions so that a moving rainbow pattern moves from to back as the robot moves forward. If the robot encounters an obstacle, the robot will backup and change the direction of the rainbow. After it backs up a bit it will turn and move forward again. main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 from machine import Pin , PWM from time import sleep from machine import Pin from machine import I2C import VL53L0X from neopixel import Neopixel # Motor Code # lower right pins with USB on top RIGHT_FORWARD_PIN = 19 RIGHT_REVERSE_PIN = 18 LEFT_FORWARD_PIN = 20 LEFT_REVERSE_PIN = 21 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # Sensor Code sda = machine . Pin ( 16 ) scl = machine . Pin ( 17 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) tof . start () # startup the sensor # used to blink the onboard LED led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) # LED Code numpix = 72 strip = Neopixel ( numpix , 0 , 0 , \"GRB\" ) # we turn the brightness way down to not oversaturate the brightness in the video strip . brightness ( 20 ) # driving parameters POWER_LEVEL = 30000 # use a value from 20000 to 65025 TURN_THRESHOLD = 400 # 25 cm TURN_TIME = . 25 # seconds of turning BACKUP_TIME = . 75 # seconds of backing up if obstacle detected red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) colors = ( red , orange , yellow , green , blue , indigo , violet ) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) #for i in range(numpix): # strip.set_pixel(i, green) #strip.show() def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) #for i in range(numpix): # strip.set_pixel(i, red) #strip.show() def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) #for i in range(numpix): # strip.set_pixel(i, blue) #strip.show() def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) #for i in range(numpix): # strip.set_pixel(i, yellow) #strip.show() def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) for i in range ( numpix ): strip . set_pixel ( i , violet ) strip . show () def read_sensor_avg (): total = 0 for i in range ( 10 ): total = total + tof . read () sleep ( . 01 ) return int ( total / 10 ) # offset is the color to start (0 to 6) # dir is 1 for forward and -1 for reverse def color_wipe_4 ( offset , dir ): for i in range ( 12 ): if dir == 1 : this_color = colors [ (( i - offset ) % 7 )] else : this_color = colors [ (( i + offset ) % 7 )] strip . set_pixel ( i , this_color ) strip . set_pixel ( 23 - i , this_color ) strip . set_pixel ( i + 24 , this_color ) strip . set_pixel ( 47 - i , this_color ) strip . set_pixel ( 48 + i , this_color ) strip . set_pixel ( 71 - i , this_color ) strip . show () # time.sleep(0.01) counter = 0 while True : dist = read_sensor_avg () if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 turn_right () color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 else : forward () color_wipe_4 ( counter % 7 , 1 ) counter += 1 Rainbow Bot Source Code","title":"Full Source Code"},{"location":"robots/03-rainbow-bot/#references","text":"Micropython NeoPixel Library","title":"References"},{"location":"robots/04-face-bot/","text":"MicroPython FaceBot This lesson will allow you to draw simple faces on the display on the front of our robots. The faces can reflect the emotions of your robot. We are inspired by the faces on the","title":"Face Bot"},{"location":"robots/04-face-bot/#micropython-facebot","text":"This lesson will allow you to draw simple faces on the display on the front of our robots. The faces can reflect the emotions of your robot. We are inspired by the faces on the","title":"MicroPython FaceBot"},{"location":"robots/05-ajusta-bot/","text":"Adjusta Bot This robot uses buttons and a rotary encoder to allow the user to reprogram the Pico and adjust the collision avoidance parameters.","title":"Ajusta Bot"},{"location":"robots/05-ajusta-bot/#adjusta-bot","text":"This robot uses buttons and a rotary encoder to allow the user to reprogram the Pico and adjust the collision avoidance parameters.","title":"Adjusta Bot"},{"location":"robots/20-faqs/","text":"Robots Frequently Asked Questions Why a two-motor three wheel robot, not four motor four wheel robot? We evaluated both the two-motor three wheel robot and the four motor four wheel robots and found that we could achieve all our learning objectives with the two-motor three wheel version. The kits are lower cost, have a simpler assembly process and have plenty of power for our projects. Why do we use the L293D vs L298N Motor Driver? Both of these popular motor driver chips are commonly used in robot kits. Our focus is teaching the principals of computational thinking using low-cost parts. Since the L293D is lower cost and has plenty of power for our two-motor robots we chose that. There is a detailed side-by-side comparison [here] (https://www.etechnophiles.com/l293d-vs-l298n-motor-driver-differences-specifications-and-pinouts/) Why don't we just create a remote control robot car? Remote control cars are very fun to play with. But we find that it often detracts from our mission of learning how to code. So we try to minimize the time students spend just driving their cars around our tracks.","title":"FAQs"},{"location":"robots/20-faqs/#robots-frequently-asked-questions","text":"","title":"Robots Frequently Asked Questions"},{"location":"robots/20-faqs/#why-a-two-motor-three-wheel-robot-not-four-motor-four-wheel-robot","text":"We evaluated both the two-motor three wheel robot and the four motor four wheel robots and found that we could achieve all our learning objectives with the two-motor three wheel version. The kits are lower cost, have a simpler assembly process and have plenty of power for our projects.","title":"Why a two-motor three wheel robot, not four motor four wheel robot?"},{"location":"robots/20-faqs/#why-do-we-use-the-l293d-vs-l298n-motor-driver","text":"Both of these popular motor driver chips are commonly used in robot kits. Our focus is teaching the principals of computational thinking using low-cost parts. Since the L293D is lower cost and has plenty of power for our two-motor robots we chose that. There is a detailed side-by-side comparison [here] (https://www.etechnophiles.com/l293d-vs-l298n-motor-driver-differences-specifications-and-pinouts/)","title":"Why do we use the L293D vs L298N Motor Driver?"},{"location":"robots/20-faqs/#why-dont-we-just-create-a-remote-control-robot-car","text":"Remote control cars are very fun to play with. But we find that it often detracts from our mission of learning how to code. So we try to minimize the time students spend just driving their cars around our tracks.","title":"Why don't we just create a remote control robot car?"},{"location":"sensors/01-intro/","text":"Sensors in MicroPython Light Sensor Ping Temperature","title":"Introduction"},{"location":"sensors/01-intro/#sensors-in-micropython","text":"","title":"Sensors in MicroPython"},{"location":"sensors/01-intro/#light-sensor","text":"","title":"Light Sensor"},{"location":"sensors/01-intro/#ping","text":"","title":"Ping"},{"location":"sensors/01-intro/#temperature","text":"","title":"Temperature"},{"location":"sensors/02-photosensor/","text":"Light Sensor with Raspberry Pi Pico in MicroPython A photoresistor is a sensor that decreases resistance when light is shined on its surface. With no light a photoresistor has high resistance in the range of megaohms. As light shines on the surface the resistance drops to kiloohms. We can use this effect as a light sensor. To convert the variable resistance of a photoresistor to something we can measure with our microcontroller we will need to build a small circuit that includes a 10K ohm resistor. We then measure the voltage between the photoresistor and the 10K resistor as light falls on the sensor. The top and bottom of the circuit are tied to ground and a power rail. This will move the voltage of the midpoint of the circuit. Circuit We want to make sure that we use the stable analog ground (AGND) and analog to reference voltage at either end of the circuit to protect the circuit from all the noise of the power in our processor. Using other power and ground pins will work, but power fluctuations will make the result noisy. Sample Code Our program will first use the Analog to Digital Circuit (ADC0) as an input. On the Pico this is on pin 26. 1 2 3 4 5 6 7 8 import machine import time photo_pin = machine . ADC ( 26 ) while True : val = photo_pin . read_u16 () print ( val ) time . sleep ( . 2 ) When you run the program a series of print values is displayed in the shell every 1/5th of a second. You can also use the Thonny plot window to see how the numbers change and you cover and uncover detector from a light source. Experiments What types of devices could use a light detector? How does a night-light work? How could you add an LED to the circuit so that the LED would turn on if the light level got too low? Could you automatically adjust the brightness of LEDs on a costume to get brighter in a sunny room and dim if you enter a dark room? What would that code look like? References Wikipedia Page on Photoresistor","title":"Photosensor"},{"location":"sensors/02-photosensor/#light-sensor-with-raspberry-pi-pico-in-micropython","text":"A photoresistor is a sensor that decreases resistance when light is shined on its surface. With no light a photoresistor has high resistance in the range of megaohms. As light shines on the surface the resistance drops to kiloohms. We can use this effect as a light sensor. To convert the variable resistance of a photoresistor to something we can measure with our microcontroller we will need to build a small circuit that includes a 10K ohm resistor. We then measure the voltage between the photoresistor and the 10K resistor as light falls on the sensor. The top and bottom of the circuit are tied to ground and a power rail. This will move the voltage of the midpoint of the circuit.","title":"Light Sensor with Raspberry Pi Pico in MicroPython"},{"location":"sensors/02-photosensor/#circuit","text":"We want to make sure that we use the stable analog ground (AGND) and analog to reference voltage at either end of the circuit to protect the circuit from all the noise of the power in our processor. Using other power and ground pins will work, but power fluctuations will make the result noisy.","title":"Circuit"},{"location":"sensors/02-photosensor/#sample-code","text":"Our program will first use the Analog to Digital Circuit (ADC0) as an input. On the Pico this is on pin 26. 1 2 3 4 5 6 7 8 import machine import time photo_pin = machine . ADC ( 26 ) while True : val = photo_pin . read_u16 () print ( val ) time . sleep ( . 2 ) When you run the program a series of print values is displayed in the shell every 1/5th of a second. You can also use the Thonny plot window to see how the numbers change and you cover and uncover detector from a light source.","title":"Sample Code"},{"location":"sensors/02-photosensor/#experiments","text":"What types of devices could use a light detector? How does a night-light work? How could you add an LED to the circuit so that the LED would turn on if the light level got too low? Could you automatically adjust the brightness of LEDs on a costume to get brighter in a sunny room and dim if you enter a dark room? What would that code look like?","title":"Experiments"},{"location":"sensors/02-photosensor/#references","text":"Wikipedia Page on Photoresistor","title":"References"},{"location":"sensors/02-pot/","text":"Reading a Potentiometer ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin. 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins. Sampling data Sometimes the data coming from your Potentiometer is noisy. You can sample the value multiple times and then average the values. Here is a sample program. Just pass in the pin and a count and it will return the average values. This version waits 5 milliseconds between samples. 1 2 3 4 5 6 def sample_pot ( pin , count ): total = 0 for i in range ( count ): total += int ( pin . read_u16 ()) utime . sleep_ms ( 5 ) return int ( total / count ) 1 2 3 pot_pin_1 = machine . ADC ( 26 ) # return a value after sampling 10 times sample_pot ( pot_pin_1 , 10 )","title":"Potentiometer"},{"location":"sensors/02-pot/#reading-a-potentiometer","text":"ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin. 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins.","title":"Reading a Potentiometer"},{"location":"sensors/02-pot/#sampling-data","text":"Sometimes the data coming from your Potentiometer is noisy. You can sample the value multiple times and then average the values. Here is a sample program. Just pass in the pin and a count and it will return the average values. This version waits 5 milliseconds between samples. 1 2 3 4 5 6 def sample_pot ( pin , count ): total = 0 for i in range ( count ): total += int ( pin . read_u16 ()) utime . sleep_ms ( 5 ) return int ( total / count ) 1 2 3 pot_pin_1 = machine . ADC ( 26 ) # return a value after sampling 10 times sample_pot ( pot_pin_1 , 10 )","title":"Sampling data"},{"location":"sensors/03-ping/","text":"Ultrasonic Ping Sensor The HC-SR04 is a low cost ($4) sensor that measures the distance to an object in front of it. Wiring Diagram Connect GND to any GND pin on the Pico Connnect VCC to VBUS or 5 Volt power Connect Trigger to pin 15. With USB on the top, this pin is the bottom left corner. Connect Echo to pin 14. One up from bottom left corner. Sample Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # Sample code to test HC-SR04 Ultrasonice Ping Sensor # Connect GND to any GND pin on the Pico # Connnect VCC to VBUS or 5 Volt power from machine import Pin , Timer import utime TRIGGER_PIN = 15 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 14 # One up from bottom left corner # Init HC-SR04 pins trigger = Pin ( TRIGGER_PIN , Pin . OUT ) # send trigger out to sensor echo = Pin ( ECHO_PIN , Pin . IN ) # get the delay interval back def ping (): trigger . low () utime . sleep_us ( 2 ) # Wait 2 microseconds low trigger . high () utime . sleep_us ( 5 ) # Stay high for 5 miroseconds trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance while True : print ( \"Distance:\" , ping (), \" cm\" ) utime . sleep ( . 25 ) OLED See the OLED example here: OLED Ping Example","title":"Ping Distance"},{"location":"sensors/03-ping/#ultrasonic-ping-sensor","text":"The HC-SR04 is a low cost ($4) sensor that measures the distance to an object in front of it.","title":"Ultrasonic Ping Sensor"},{"location":"sensors/03-ping/#wiring-diagram","text":"Connect GND to any GND pin on the Pico Connnect VCC to VBUS or 5 Volt power Connect Trigger to pin 15. With USB on the top, this pin is the bottom left corner. Connect Echo to pin 14. One up from bottom left corner.","title":"Wiring Diagram"},{"location":"sensors/03-ping/#sample-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # Sample code to test HC-SR04 Ultrasonice Ping Sensor # Connect GND to any GND pin on the Pico # Connnect VCC to VBUS or 5 Volt power from machine import Pin , Timer import utime TRIGGER_PIN = 15 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 14 # One up from bottom left corner # Init HC-SR04 pins trigger = Pin ( TRIGGER_PIN , Pin . OUT ) # send trigger out to sensor echo = Pin ( ECHO_PIN , Pin . IN ) # get the delay interval back def ping (): trigger . low () utime . sleep_us ( 2 ) # Wait 2 microseconds low trigger . high () utime . sleep_us ( 5 ) # Stay high for 5 miroseconds trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance while True : print ( \"Distance:\" , ping (), \" cm\" ) utime . sleep ( . 25 )","title":"Sample Code"},{"location":"sensors/03-ping/#oled","text":"See the OLED example here: OLED Ping Example","title":"OLED"},{"location":"sensors/05-temp-dsb20/","text":"Temp with DS18B20 https://randomnerdtutorials.com/micropython-ds18b20-esp32-esp8266/ ```py Complete project details at https://RandomNerdTutorials.com import machine, onewire, ds18x20, time ds_pin = machine.Pin(4) ds_sensor = ds18x20.DS18X20(onewire.OneWire(ds_pin)) roms = ds_sensor.scan() print('Found DS devices: ', roms) while True: ds_sensor.convert_temp() time.sleep_ms(750) for rom in roms: print(rom) print(ds_sensor.read_temp(rom)) time.sleep(5) ```","title":"Temperature"},{"location":"sensors/05-temp-dsb20/#temp-with-ds18b20","text":"https://randomnerdtutorials.com/micropython-ds18b20-esp32-esp8266/ ```py","title":"Temp with DS18B20"},{"location":"sensors/05-temp-dsb20/#complete-project-details-at-httpsrandomnerdtutorialscom","text":"import machine, onewire, ds18x20, time ds_pin = machine.Pin(4) ds_sensor = ds18x20.DS18X20(onewire.OneWire(ds_pin)) roms = ds_sensor.scan() print('Found DS devices: ', roms) while True: ds_sensor.convert_temp() time.sleep_ms(750) for rom in roms: print(rom) print(ds_sensor.read_temp(rom)) time.sleep(5) ```","title":"Complete project details at https://RandomNerdTutorials.com"},{"location":"sensors/06-accelerometer-compass/","text":"MPU-9250 Accelerometer Gyroscope Compass The MPU-9250 by InvenSense is a nine-axis motion tracking device. It includes: A MPU-6500, which contains a 3-axis accelerometer and a 3-axis gyroscope and A AK8963, the market leading 3-axis digital compass that senses magnetic fields (Gyro + Accelerometer + Compass) MEMS MotionTracking\u2122 Device 1PCS GY-91 10DOF Accelerometer Gyroscope Compass Temp/Pressure MPU-9250 BMP-280 Art of Circuits Pinouts VIN: Voltage Supply Pin 3V3: 3.3v Regulator output GND: 0V Power Supply SCL: I2C Clock / SPI Clock SDA: I2C Data or SPI Data Input SDO/SAO: SPI Data output / I2C Slave Address configuration pin NCS: Chip Select for SPI mode only for MPU-9250 CSB: Chip Select for BMP280 You only need to hook the 3.3 to VIN, the GND to GND and the SCL and SDA. The other connections are not needed. I2C Scanner Results 1 2 3 4 5 import machine sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) Device found at decimal [104, 118] MPU9250 Drivers MicroPython Driver 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import utime from machine import I2C , Pin from mpu9250 import MPU9250 i2c = I2C ( scl = Pin ( 22 ), sda = Pin ( 21 )) sensor = MPU9250 ( i2c ) print ( \"MPU9250 id: \" + hex ( sensor . whoami )) while True : print ( sensor . acceleration ) print ( sensor . gyro ) print ( sensor . magnetic ) print ( sensor . temperature ) utime . sleep_ms ( 1000 )","title":"Accelerometer Compass"},{"location":"sensors/06-accelerometer-compass/#mpu-9250-accelerometer-gyroscope-compass","text":"The MPU-9250 by InvenSense is a nine-axis motion tracking device. It includes: A MPU-6500, which contains a 3-axis accelerometer and a 3-axis gyroscope and A AK8963, the market leading 3-axis digital compass that senses magnetic fields (Gyro + Accelerometer + Compass) MEMS MotionTracking\u2122 Device 1PCS GY-91 10DOF Accelerometer Gyroscope Compass Temp/Pressure MPU-9250 BMP-280 Art of Circuits","title":"MPU-9250 Accelerometer Gyroscope Compass"},{"location":"sensors/06-accelerometer-compass/#pinouts","text":"VIN: Voltage Supply Pin 3V3: 3.3v Regulator output GND: 0V Power Supply SCL: I2C Clock / SPI Clock SDA: I2C Data or SPI Data Input SDO/SAO: SPI Data output / I2C Slave Address configuration pin NCS: Chip Select for SPI mode only for MPU-9250 CSB: Chip Select for BMP280 You only need to hook the 3.3 to VIN, the GND to GND and the SCL and SDA. The other connections are not needed.","title":"Pinouts"},{"location":"sensors/06-accelerometer-compass/#i2c-scanner-results","text":"1 2 3 4 5 import machine sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) Device found at decimal [104, 118]","title":"I2C Scanner Results"},{"location":"sensors/06-accelerometer-compass/#mpu9250-drivers","text":"MicroPython Driver 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import utime from machine import I2C , Pin from mpu9250 import MPU9250 i2c = I2C ( scl = Pin ( 22 ), sda = Pin ( 21 )) sensor = MPU9250 ( i2c ) print ( \"MPU9250 id: \" + hex ( sensor . whoami )) while True : print ( sensor . acceleration ) print ( sensor . gyro ) print ( sensor . magnetic ) print ( sensor . temperature ) utime . sleep_ms ( 1000 )","title":"MPU9250 Drivers"},{"location":"sensors/06-bme280/","text":"BME280 Environmental Sensor The Bosch BME280 is a low-cost ($2) temperature, and pressure sensor that has an I2C interface. This is an ideal way to learn how to use an I2C interface. Note mbe280 is different from the BMP280 and does not read humidity. The default address is Hex x76 or decimal 118. Circuit The BME280 has a standard I2C interface with four wires: GND - connect to any of the GND pins VCC - connect this to the 3.3V output of the Pico SCL - clock SDA - data I2C Scanner After you have connected your sensor you can check the connection by running a quick \"I2C Scanner\" to find the address of the sensor. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # This is GP0 on row one of our standard Pico breadboard with the USB on top scl = machine . Pin ( 1 ) # Row two of our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) Results: 1 [118] This is decimal of hex 0x76 If the scanner does not return a number then your connections might not be working. BME280 Driver You should be able to find the BME280 driver by using the Thonny Tool -> Manage Packages... menu. If that does not work you can try a github search: Search GitHub for MBE 280 Python Code Test Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import machine from utime import sleep import BME280 sda = machine . Pin ( 0 ) # This is GP0 on row one of our standard Pico breadboard with the USB on top scl = machine . Pin ( 1 ) # Row two of our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # initialize the bme class using the default address bme = BME280 () ( chip_id , chip_version ) = bme . getID () print ( \"Chip ID:\" , chip_id ) print ( \"Version:\" , chip_version ) while True (): # get new data from the temperature , pressure , humidity = bme . getData () #adj_bar = bme.adj_baro(pressure, temperature) print ( \"Adj {} \" . format ( bme . adj_baro ( pressure , temperature ))) print ( \"Temperature: {} C\" . format ( temperature )) print ( \"Pressure: {} hpa, {} In\" . format ( pressure , round ( pressure * 0.02953 , 2 ))) sleep ( 1 ) Code 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from machine import I2C import BME280 from time import sleep sda = machine . Pin ( 16 ) scl = machine . Pin ( 17 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) bme = BME280 . BME280 ( i2c = i2c ) # print(i2c.scan()) while True : temp = bme . temperature hum = bme . humidity pres = bme . pressure # uncomment for temperature in Fahrenheit temp = ( bme . read_temperature () / 100 ) * ( 9 / 5 ) + 32 #temp = str(round(temp, 2)) + 'F' print ( 'Temperature: ' , temp , end = '' ) print ( ' Humidity:' , hum , end = '' ) print ( ' Pressure:' , pres ) sleep ( 5 ) References Robert HH BME280 Test Page Official Datasheet eBay BME280 Sensor Search Driver Sample code Digital Barometric Pressure Sensor Board Swap I2C/SPI BMP280 BME280 3.3V BME280 4. BME280 logger 5. The Electronics India","title":"Environmental Sensor"},{"location":"sensors/06-bme280/#bme280-environmental-sensor","text":"The Bosch BME280 is a low-cost ($2) temperature, and pressure sensor that has an I2C interface. This is an ideal way to learn how to use an I2C interface. Note mbe280 is different from the BMP280 and does not read humidity. The default address is Hex x76 or decimal 118.","title":"BME280 Environmental Sensor"},{"location":"sensors/06-bme280/#circuit","text":"The BME280 has a standard I2C interface with four wires: GND - connect to any of the GND pins VCC - connect this to the 3.3V output of the Pico SCL - clock SDA - data","title":"Circuit"},{"location":"sensors/06-bme280/#i2c-scanner","text":"After you have connected your sensor you can check the connection by running a quick \"I2C Scanner\" to find the address of the sensor. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # This is GP0 on row one of our standard Pico breadboard with the USB on top scl = machine . Pin ( 1 ) # Row two of our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) Results: 1 [118] This is decimal of hex 0x76 If the scanner does not return a number then your connections might not be working.","title":"I2C Scanner"},{"location":"sensors/06-bme280/#bme280-driver","text":"You should be able to find the BME280 driver by using the Thonny Tool -> Manage Packages... menu. If that does not work you can try a github search: Search GitHub for MBE 280 Python Code","title":"BME280 Driver"},{"location":"sensors/06-bme280/#test-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import machine from utime import sleep import BME280 sda = machine . Pin ( 0 ) # This is GP0 on row one of our standard Pico breadboard with the USB on top scl = machine . Pin ( 1 ) # Row two of our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # initialize the bme class using the default address bme = BME280 () ( chip_id , chip_version ) = bme . getID () print ( \"Chip ID:\" , chip_id ) print ( \"Version:\" , chip_version ) while True (): # get new data from the temperature , pressure , humidity = bme . getData () #adj_bar = bme.adj_baro(pressure, temperature) print ( \"Adj {} \" . format ( bme . adj_baro ( pressure , temperature ))) print ( \"Temperature: {} C\" . format ( temperature )) print ( \"Pressure: {} hpa, {} In\" . format ( pressure , round ( pressure * 0.02953 , 2 ))) sleep ( 1 )","title":"Test Code"},{"location":"sensors/06-bme280/#code-2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from machine import I2C import BME280 from time import sleep sda = machine . Pin ( 16 ) scl = machine . Pin ( 17 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) bme = BME280 . BME280 ( i2c = i2c ) # print(i2c.scan()) while True : temp = bme . temperature hum = bme . humidity pres = bme . pressure # uncomment for temperature in Fahrenheit temp = ( bme . read_temperature () / 100 ) * ( 9 / 5 ) + 32 #temp = str(round(temp, 2)) + 'F' print ( 'Temperature: ' , temp , end = '' ) print ( ' Humidity:' , hum , end = '' ) print ( ' Pressure:' , pres ) sleep ( 5 )","title":"Code 2"},{"location":"sensors/06-bme280/#references","text":"Robert HH BME280 Test Page Official Datasheet eBay BME280 Sensor Search Driver Sample code","title":"References"},{"location":"sensors/06-bme280/#digital-barometric-pressure-sensor-board-swap-i2cspi-bmp280-bme280-33v","text":"BME280 4. BME280 logger 5. The Electronics India","title":"Digital Barometric Pressure Sensor Board Swap I2C/SPI BMP280 BME280 3.3V"},{"location":"sensors/07-VL53L0X_GY/","text":"VL53L0X Time-of-Flight Laser Ranging Module IR Distance Sensor Figure: VL53L0X in the GY-530 package. The VL53L0X is a low-cost ($5) time-of-flight light-based distance sensor that is easy to use. It comes packaged in a I2C board and gives precise distance measurements up to 1.5 meters away. It measures the time that light pulses take to travel to an object and back to estimate distance. Light travels about 1 foot every nanosecond, so the timing inside this little chip must be very accurate. The VL53L0X integrates a group of Single Photon Avalanche Diodes (SPAD) and embeds ST Electronic's second generation FlightSense\u2122 patented technology. The VL53L0X\u2019s 940 nm emitter Vertical Cavity Surface-Emitting Laser (VCSEL), is safe for kids and totally invisible to the human eye. Coupled with internal physical infrared filters, the sensor enables longer ranging distance, higher immunity to ambient light, and better robustness to cover glass optical crosstalk. Circuit Hook the VCC to the 3.3 out of the Pico, the GND of the sensor to andy of the GND pins of the Pico and then connect the Clock and Data to two pins such as GIPO pins 16 and 17. I2C Scanner Test We first run the I2C scanner program to verify that the sensor is connected correct and is responding to the I2C bus scan. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) This should return a single decimal number. Download The VL53L0X Driver If you are using Thonny, you can try to use the \"Manage Packages\" menu and search for the driver. We have a sample of the driver here Create a Test Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Test program for VL53L0X import time from machine import Pin from machine import I2C import VL53L0X sda = machine . Pin ( 16 ) # lower right pin scl = machine . Pin ( 17 ) # one up from lower right pin i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) while True : tof . start () tof . read () print ( tof . read ()) tof . stop () time . sleep ( 0.1 ) Use the Thonny Plot Reference Purchase links ST Microelectronics User Manual Ebay $4 Amazon $12 eBay qty 10 for $25","title":"Time of Flight Distance"},{"location":"sensors/07-VL53L0X_GY/#vl53l0x-time-of-flight-laser-ranging-module-ir-distance-sensor","text":"Figure: VL53L0X in the GY-530 package. The VL53L0X is a low-cost ($5) time-of-flight light-based distance sensor that is easy to use. It comes packaged in a I2C board and gives precise distance measurements up to 1.5 meters away. It measures the time that light pulses take to travel to an object and back to estimate distance. Light travels about 1 foot every nanosecond, so the timing inside this little chip must be very accurate. The VL53L0X integrates a group of Single Photon Avalanche Diodes (SPAD) and embeds ST Electronic's second generation FlightSense\u2122 patented technology. The VL53L0X\u2019s 940 nm emitter Vertical Cavity Surface-Emitting Laser (VCSEL), is safe for kids and totally invisible to the human eye. Coupled with internal physical infrared filters, the sensor enables longer ranging distance, higher immunity to ambient light, and better robustness to cover glass optical crosstalk.","title":"VL53L0X Time-of-Flight Laser Ranging Module IR Distance Sensor"},{"location":"sensors/07-VL53L0X_GY/#circuit","text":"Hook the VCC to the 3.3 out of the Pico, the GND of the sensor to andy of the GND pins of the Pico and then connect the Clock and Data to two pins such as GIPO pins 16 and 17.","title":"Circuit"},{"location":"sensors/07-VL53L0X_GY/#i2c-scanner-test","text":"We first run the I2C scanner program to verify that the sensor is connected correct and is responding to the I2C bus scan. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) This should return a single decimal number.","title":"I2C Scanner Test"},{"location":"sensors/07-VL53L0X_GY/#download-the-vl53l0x-driver","text":"If you are using Thonny, you can try to use the \"Manage Packages\" menu and search for the driver. We have a sample of the driver here","title":"Download The VL53L0X Driver"},{"location":"sensors/07-VL53L0X_GY/#create-a-test-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Test program for VL53L0X import time from machine import Pin from machine import I2C import VL53L0X sda = machine . Pin ( 16 ) # lower right pin scl = machine . Pin ( 17 ) # one up from lower right pin i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) while True : tof . start () tof . read () print ( tof . read ()) tof . stop () time . sleep ( 0.1 )","title":"Create a Test Program"},{"location":"sensors/07-VL53L0X_GY/#use-the-thonny-plot","text":"","title":"Use the Thonny Plot"},{"location":"sensors/07-VL53L0X_GY/#reference-purchase-links","text":"ST Microelectronics User Manual Ebay $4 Amazon $12","title":"Reference Purchase links"},{"location":"sensors/07-VL53L0X_GY/#ebay","text":"qty 10 for $25","title":"eBay"},{"location":"sensors/08-ir-distance-sensor/","text":"IR Distance Sensors IR distance sensors are low cost (five for $3) but may have problems working in rooms with outdoor lighting. They have an adjustable potentiometer on them that can be used to adjust a triggering distance call the threshold distance. The sensors return a HIGH signal if there is no object within the threshold distance and a LOW signal if there is an object within this distance. Since the sensor threshold distance can not be adjusted programmatically they are best suited when you can manually adjust the potentiometer to change the threshold. Connections These sensors have three wires: GND - connect to a ground rail on your breadboard or directly to a GND ping on the Pico. VCC - connect to the 5 volt power rail powered by the motor controller voltage regulator OUT - a 5 volt digital signal that is usually 5 volts but is GND when triggered by an object Sample Python Code 1 2 3 4 # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) The KY-032 The KY-032 obstacle avoidance sensor is a four-wire distance-adjustable, infrared proximity sensor designed for wheeled robots. Also known as AD-032. The sensor detection distance ranges from 2cm to 40cm, it can be adjusted by turning the potentiometer knob. The operating voltage is 3.3V-5V so it is suitable for a variety of microcontrollers like Arduino, ESP32, Teensy, ESP8266, Raspberry Pi, and others. It has strong adaptability to ambient light and it is fairly accurate to sense changes in the surrounding environment. Speaker Test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 from machine import Pin , PWM from utime import sleep left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) def sound_off (): speaker . duty_u16 ( 0 ) def left_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second sound_off () def center_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 25 ) sound_off () def forward_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 1 ) speaker . freq ( 900 ) sleep ( . 1 ) speaker . freq ( 1200 ) sleep ( . 1 ) sound_off () # 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 while True : if left . value () == 0 : print ( 'Left' ) left_tone () drive_state = 2 if center . value () == 0 : print ( 'Center' ) center_tone () drive_state = 0 if right . value () == 0 : print ( 'Right' ) right_tone () drive_state = 3 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left . value () and center . value () and right . value (): print ( 'Go forward!' ) drive_state = 1 forward_tone () sleep ( . 25 ) Full Program ```py from machine import Pin, PWM from utime import sleep import ssd1306 Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 17 RIGHT_REVERSE_PIN = 16 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM(Pin(RIGHT_FORWARD_PIN)) right_reverse = PWM(Pin(RIGHT_REVERSE_PIN)) left_forward = PWM(Pin(LEFT_FORWARD_PIN)) left_reverse = PWM(Pin(LEFT_REVERSE_PIN)) connections to the three IR distance sensors left = Pin(8, Pin.IN, Pin.PULL_DOWN) center = Pin(7, Pin.IN, Pin.PULL_DOWN) right = Pin(6, Pin.IN, Pin.PULL_DOWN) SPEAKER_PIN = 21 create a Pulse Width Modulation Object on this pin speaker = PWM(Pin(SPEAKER_PIN)) WIDTH = 128 HEIGHT = 64 CS = machine.Pin(1) SCL = machine.Pin(2) SDA = machine.Pin(3) DC = machine.Pin(4) RES = machine.Pin(5) spi=machine.SPI(0, sck=SCL, mosi=SDA) oled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS) def turn_motor_on(pwm): pwm.duty_u16(65025) def turn_motor_off(pwm): pwm.duty_u16(0) def forward(): turn_motor_on(right_forward) turn_motor_on(left_forward) def reverse(): turn_motor_on(right_reverse) turn_motor_on(left_reverse) def turn_right(): turn_motor_on(right_forward) turn_motor_on(left_reverse) def turn_left(): turn_motor_on(right_reverse) turn_motor_on(left_forward) def sound_off(): speaker.duty_u16(0) def left_tone(): speaker.duty_u16(1000) speaker.freq(700) # 1 Kilohertz sleep(.5) # wait a 1/4 second sound_off() def center_tone(): speaker.duty_u16(1000) speaker.freq(900) sleep(.5) sound_off() def right_tone(): speaker.duty_u16(1000) speaker.freq(600) sleep(.5) sound_off() def forward_tone(): speaker.duty_u16(1000) speaker.freq(400) sleep(.1) speaker.freq(900) sleep(.1) speaker.freq(1200) sleep(.1) sound_off() def update_oled(): oled.fill(0) oled.text(\"CoderDojo Rocks!\", 0, 0, 1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 oled.text(\"Left:\", 0, 10, 1) oled.text(str(left.value()), 50, 10, 1) oled.text(\"Center:\", 0, 20, 1) oled.text(str(center.value()), 60, 20, 1) oled.text(\"Right:\", 0, 30, 1) oled.text(str(right.value()), 55, 30, 1) BAR_WIDTH = 40 BAR_HEIGHT = 20 if left.value(): oled.fill_rect(WIDTH-40, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(WIDTH-40, 50, BAR_WIDTH, BAR_HEIGHT, 1) if center.value(): oled.fill_rect(50, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(50, 50, BAR_WIDTH, BAR_HEIGHT, 1) if right.value(): oled.fill_rect(0, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(0, 50, BAR_WIDTH, BAR_HEIGHT, 1) oled.show() 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 counter = 0 while True: if left.value()==0: print('Left') #left_tone() turn_right() update_oled() drive_state = 2 if center.value()==0: print('Center') center_tone() reverse() update_oled() drive_state = 0 if right.value()==0: print('Right') #right_tone() turn_left() update_oled() drive_state = 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left.value() and center.value() and right.value(): print('Go forward!') drive_state = 1 # forward_tone() forward() update_oled() print(\"counter: \", counter) counter += 1 sleep(.25) ``` ## More to Explore 1. Try to change the values of the potentiometers on the sensors. What is the minimum and maximum distance you can detect and object? 2. Does the reflectivity of the object impact the distance of the object? 3. If you put a small mirror in front of the sensor what happens to the distance measured? 4. Place the robot near bright sun in a window or try the robot outdoors on both a cloudy day and a sunny day? What is the change is accuracy of the sensors under these conditions? What about running the robot in the dark?","title":"IR Distance Sensor"},{"location":"sensors/08-ir-distance-sensor/#ir-distance-sensors","text":"IR distance sensors are low cost (five for $3) but may have problems working in rooms with outdoor lighting. They have an adjustable potentiometer on them that can be used to adjust a triggering distance call the threshold distance. The sensors return a HIGH signal if there is no object within the threshold distance and a LOW signal if there is an object within this distance. Since the sensor threshold distance can not be adjusted programmatically they are best suited when you can manually adjust the potentiometer to change the threshold.","title":"IR Distance Sensors"},{"location":"sensors/08-ir-distance-sensor/#connections","text":"These sensors have three wires: GND - connect to a ground rail on your breadboard or directly to a GND ping on the Pico. VCC - connect to the 5 volt power rail powered by the motor controller voltage regulator OUT - a 5 volt digital signal that is usually 5 volts but is GND when triggered by an object","title":"Connections"},{"location":"sensors/08-ir-distance-sensor/#sample-python-code","text":"1 2 3 4 # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN )","title":"Sample Python Code"},{"location":"sensors/08-ir-distance-sensor/#the-ky-032","text":"The KY-032 obstacle avoidance sensor is a four-wire distance-adjustable, infrared proximity sensor designed for wheeled robots. Also known as AD-032. The sensor detection distance ranges from 2cm to 40cm, it can be adjusted by turning the potentiometer knob. The operating voltage is 3.3V-5V so it is suitable for a variety of microcontrollers like Arduino, ESP32, Teensy, ESP8266, Raspberry Pi, and others. It has strong adaptability to ambient light and it is fairly accurate to sense changes in the surrounding environment.","title":"The KY-032"},{"location":"sensors/08-ir-distance-sensor/#speaker-test","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 from machine import Pin , PWM from utime import sleep left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) def sound_off (): speaker . duty_u16 ( 0 ) def left_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second sound_off () def center_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 25 ) sound_off () def forward_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 1 ) speaker . freq ( 900 ) sleep ( . 1 ) speaker . freq ( 1200 ) sleep ( . 1 ) sound_off () # 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 while True : if left . value () == 0 : print ( 'Left' ) left_tone () drive_state = 2 if center . value () == 0 : print ( 'Center' ) center_tone () drive_state = 0 if right . value () == 0 : print ( 'Right' ) right_tone () drive_state = 3 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left . value () and center . value () and right . value (): print ( 'Go forward!' ) drive_state = 1 forward_tone () sleep ( . 25 )","title":"Speaker Test"},{"location":"sensors/08-ir-distance-sensor/#full-program","text":"```py from machine import Pin, PWM from utime import sleep import ssd1306","title":"Full Program"},{"location":"sensors/08-ir-distance-sensor/#motor-pins-to-the-l293-h-bridge","text":"RIGHT_FORWARD_PIN = 17 RIGHT_REVERSE_PIN = 16 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM(Pin(RIGHT_FORWARD_PIN)) right_reverse = PWM(Pin(RIGHT_REVERSE_PIN)) left_forward = PWM(Pin(LEFT_FORWARD_PIN)) left_reverse = PWM(Pin(LEFT_REVERSE_PIN))","title":"Motor pins to the L293 H-Bridge"},{"location":"sensors/08-ir-distance-sensor/#connections-to-the-three-ir-distance-sensors","text":"left = Pin(8, Pin.IN, Pin.PULL_DOWN) center = Pin(7, Pin.IN, Pin.PULL_DOWN) right = Pin(6, Pin.IN, Pin.PULL_DOWN) SPEAKER_PIN = 21","title":"connections to the three IR distance sensors"},{"location":"sensors/08-ir-distance-sensor/#create-a-pulse-width-modulation-object-on-this-pin","text":"speaker = PWM(Pin(SPEAKER_PIN)) WIDTH = 128 HEIGHT = 64 CS = machine.Pin(1) SCL = machine.Pin(2) SDA = machine.Pin(3) DC = machine.Pin(4) RES = machine.Pin(5) spi=machine.SPI(0, sck=SCL, mosi=SDA) oled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS) def turn_motor_on(pwm): pwm.duty_u16(65025) def turn_motor_off(pwm): pwm.duty_u16(0) def forward(): turn_motor_on(right_forward) turn_motor_on(left_forward) def reverse(): turn_motor_on(right_reverse) turn_motor_on(left_reverse) def turn_right(): turn_motor_on(right_forward) turn_motor_on(left_reverse) def turn_left(): turn_motor_on(right_reverse) turn_motor_on(left_forward) def sound_off(): speaker.duty_u16(0) def left_tone(): speaker.duty_u16(1000) speaker.freq(700) # 1 Kilohertz sleep(.5) # wait a 1/4 second sound_off() def center_tone(): speaker.duty_u16(1000) speaker.freq(900) sleep(.5) sound_off() def right_tone(): speaker.duty_u16(1000) speaker.freq(600) sleep(.5) sound_off() def forward_tone(): speaker.duty_u16(1000) speaker.freq(400) sleep(.1) speaker.freq(900) sleep(.1) speaker.freq(1200) sleep(.1) sound_off() def update_oled(): oled.fill(0) oled.text(\"CoderDojo Rocks!\", 0, 0, 1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 oled.text(\"Left:\", 0, 10, 1) oled.text(str(left.value()), 50, 10, 1) oled.text(\"Center:\", 0, 20, 1) oled.text(str(center.value()), 60, 20, 1) oled.text(\"Right:\", 0, 30, 1) oled.text(str(right.value()), 55, 30, 1) BAR_WIDTH = 40 BAR_HEIGHT = 20 if left.value(): oled.fill_rect(WIDTH-40, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(WIDTH-40, 50, BAR_WIDTH, BAR_HEIGHT, 1) if center.value(): oled.fill_rect(50, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(50, 50, BAR_WIDTH, BAR_HEIGHT, 1) if right.value(): oled.fill_rect(0, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(0, 50, BAR_WIDTH, BAR_HEIGHT, 1) oled.show()","title":"create a Pulse Width Modulation Object on this pin"},{"location":"sensors/08-ir-distance-sensor/#0stopped-1forward-2turing-right-3turning-left","text":"drive_state = 0 counter = 0 while True: if left.value()==0: print('Left') #left_tone() turn_right() update_oled() drive_state = 2 if center.value()==0: print('Center') center_tone() reverse() update_oled() drive_state = 0 if right.value()==0: print('Right') #right_tone() turn_left() update_oled() drive_state = 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left.value() and center.value() and right.value(): print('Go forward!') drive_state = 1 # forward_tone() forward() update_oled() print(\"counter: \", counter) counter += 1 sleep(.25) ``` ## More to Explore 1. Try to change the values of the potentiometers on the sensors. What is the minimum and maximum distance you can detect and object? 2. Does the reflectivity of the object impact the distance of the object? 3. If you put a small mirror in front of the sensor what happens to the distance measured? 4. Place the robot near bright sun in a window or try the robot outdoors on both a cloudy day and a sunny day? What is the change is accuracy of the sensors under these conditions? What about running the robot in the dark?","title":"0=stopped, 1=forward, 2=turing right, 3=turning left"},{"location":"sensors/10-rotary-encoder/","text":"Rotary Encoder A rotary encoder, or more specifically a directional rotary encoder, may look similar to a potentiometer in some ways. Both have a knob that you turn to adjust a value. But unlike a potentiometer, an rotary encoder is far more flexible in the range and precision of values it can control. Our students love to use them in their projects. Rotary encoders can be thought of as two concentric rings of switches that go on and off as you turn the knob. The switches are placed so that you can tell the direction of rotation by the order that two switches get turned on and off. They turn on and off quickly so we need a high-quality function to quickly detect their changes. And as we learned in the Button lab, switches can be noisy and have a complex state transition that must be \"debounced\" to get a good quality signal. Learning How to Monitor the Rotary Switch Transitions We will be using a low-cost ($1 USD) encoder that has five connectors, three for the direction and one for a momentary switch that is closed when you press the knob in. Here is the circuit that we will be using: We hooked up the outer pins of the encoder to GPIO pins 16 and 17 in the lower right corner of the Pico. Then we hooked the center pin to the 3.3 volt rail. The Pico likes to pull switches down from the 3.3 volt rail. This means that we will not be connecting any of the pins to GND. We also hooked up the central press button to GPIO 22 and the 3.3 volt rail. We then ran this code and turned the knob: 1 2 3 4 5 6 7 8 9 10 import time from machine import Pin rotaryA = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) rotaryB = Pin ( 17 , Pin . IN , Pin . PULL_DOWN ) while True : print ( rotaryA . value (), end = '' ) print ( rotaryB . value ()) time . sleep ( . 1 ) the results look like the following lines: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 00 00 00 10 01 00 00 00 11 00 00 00 01 11 00 Note that the bit values the encoders switches (on or off as 0 and 1) are place next to each other on the same line. We did this by making the end of the first print statement be the null string not the default newline character. This program prints out a LONG stream of numbers, mostly of the value 00 . The values are printed 10 times each second. Now let's take a closer look at only the values that change. What we would like to do is now only print numbers if there is a change. To do this we will \"pack\" binary values into a two bit number by shifting the A pin value to the left: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import time from machine import Pin rotaryA = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) rotaryB = Pin ( 17 , Pin . IN , Pin . PULL_DOWN ) # we set the old value to zero for both bits being off old_combined = 0 while True : A_val = rotaryA . value () B_val = rotaryB . value () # a sifts by one bit and then is ORed with the B calue new_combined = ( A_val << 1 ) | B_val if new_combined != old_combined : print ( A_val , end = '' ) print ( B_val ) old_combined = new_combined time . sleep ( . 1 ) Now we get values that look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 01 11 00 01 11 00 01 11 10 00 10 00 01 11 00 10 Turning the knob clockwise we see the 01 before the 11 frequently Turning the know counterclockwise: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 00 10 11 00 10 11 00 11 00 10 00 10 01 00 Here we see the reverse 10 pattern occur more frequently. But there is noise in the switches as they open and close due to small variations in the contacts as they move. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import time from machine import Pin rotaryA = Pin(16, Pin.IN, Pin.PULL_DOWN) rotaryB = Pin(17, Pin.IN, Pin.PULL_DOWN) # we set the old value to zero for both bits being off old_combined = 0 while True: A_val = rotaryA.value() B_val = rotaryB.value() # a sifts by one bit and then is ORed with the B calue new_combined = (A_val << 1) | B_val if new_combined != old_combined: #print(A_val, end='') #print(B_val) old_combined = new_combined if A_val == 0 and B_val == 1: print('clock') elif A_val == 1 and B_val == 0: print('counter clock') time.sleep(.1) The Rotory Class I started with this rotary class . However, my setup did not work with the one she created. The numbers incremented, but they didn't decrement. I had to change the pins to use the PULL_DOWN settings in the init method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import machine import utime as time from machine import Pin import micropython class Rotary : ROT_CW = 1 ROT_CCW = 2 SW_PRESS = 4 SW_RELEASE = 8 def __init__ ( self , dt , clk , sw ): self . dt_pin = Pin ( dt , Pin . IN , Pin . PULL_DOWN ) self . clk_pin = Pin ( clk , Pin . IN , Pin . PULL_DOWN ) self . sw_pin = Pin ( sw , Pin . IN , Pin . PULL_DOWN ) self . last_status = ( self . dt_pin . value () << 1 ) | self . clk_pin . value () self . dt_pin . irq ( handler = self . rotary_change , trigger = Pin . IRQ_FALLING | Pin . IRQ_RISING ) self . clk_pin . irq ( handler = self . rotary_change , trigger = Pin . IRQ_FALLING | Pin . IRQ_RISING ) self . sw_pin . irq ( handler = self . switch_detect , trigger = Pin . IRQ_FALLING | Pin . IRQ_RISING ) self . handlers = [] self . last_button_status = self . sw_pin . value () def rotary_change ( self , pin ): new_status = ( self . dt_pin . value () << 1 ) | self . clk_pin . value () if new_status == self . last_status : return transition = ( self . last_status << 2 ) | new_status if transition == 0b1110 : micropython . schedule ( self . call_handlers , Rotary . ROT_CW ) elif transition == 0b1101 : micropython . schedule ( self . call_handlers , Rotary . ROT_CCW ) self . last_status = new_status def switch_detect ( self , pin ): if self . last_button_status == self . sw_pin . value (): return self . last_button_status = self . sw_pin . value () if self . sw_pin . value (): micropython . schedule ( self . call_handlers , Rotary . SW_RELEASE ) else : micropython . schedule ( self . call_handlers , Rotary . SW_PRESS ) def add_handler ( self , handler ): self . handlers . append ( handler ) def call_handlers ( self , type ): for handler in self . handlers : handler ( type ) The following were the lines that I changed: 1 2 3 self . dt_pin = Pin ( dt , Pin . IN , Pin . PULL_DOWN ) self . clk_pin = Pin ( clk , Pin . IN , Pin . PULL_DOWN ) self . sw_pin = Pin ( sw , Pin . IN , Pin . PULL_DOWN ) Testing Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from rotary import Rotary import utime as time from machine import Pin # GPIO Pins 16 and 17 are for the encoder pins. 22 is the button press switch. rotary = Rotary ( 16 , 17 , 22 ) val = 0 def rotary_changed ( change ): global val if change == Rotary . ROT_CW : val = val + 1 print ( val ) elif change == Rotary . ROT_CCW : val = val - 1 print ( val ) elif change == Rotary . SW_PRESS : print ( 'PRESS' ) elif change == Rotary . SW_RELEASE : print ( 'RELEASE' ) rotary . add_handler ( rotary_changed ) while True : time . sleep ( 0.1 ) Adding Plot Now I can move the knob back and forth and get consistent values that go up and down. You can turn on the plot function of Thonny to see the values consistently go up and down. Mysterious Runtime Error on Scheduling Queue I did notice that the Shell output did register the following errors: 1 2 3 Traceback (most recent call last): File \"rotary.py\", line 30, in rotary_change RuntimeError: schedule queue full The error also occurred on line 32. The following lines generated this error: 1 2 micropython . schedule ( self . call_handlers , Rotary . ROT_CW ) micropython . schedule ( self . call_handlers , Rotary . ROT_CCW ) This error did not seem to impact the execution of the code. My suspicion is that this is a bug in the Micropython firmware. References Counter get stuck on \"schedule queue full\"","title":"Rotary Encoder"},{"location":"sensors/10-rotary-encoder/#rotary-encoder","text":"A rotary encoder, or more specifically a directional rotary encoder, may look similar to a potentiometer in some ways. Both have a knob that you turn to adjust a value. But unlike a potentiometer, an rotary encoder is far more flexible in the range and precision of values it can control. Our students love to use them in their projects. Rotary encoders can be thought of as two concentric rings of switches that go on and off as you turn the knob. The switches are placed so that you can tell the direction of rotation by the order that two switches get turned on and off. They turn on and off quickly so we need a high-quality function to quickly detect their changes. And as we learned in the Button lab, switches can be noisy and have a complex state transition that must be \"debounced\" to get a good quality signal.","title":"Rotary Encoder"},{"location":"sensors/10-rotary-encoder/#learning-how-to-monitor-the-rotary-switch-transitions","text":"We will be using a low-cost ($1 USD) encoder that has five connectors, three for the direction and one for a momentary switch that is closed when you press the knob in. Here is the circuit that we will be using: We hooked up the outer pins of the encoder to GPIO pins 16 and 17 in the lower right corner of the Pico. Then we hooked the center pin to the 3.3 volt rail. The Pico likes to pull switches down from the 3.3 volt rail. This means that we will not be connecting any of the pins to GND. We also hooked up the central press button to GPIO 22 and the 3.3 volt rail. We then ran this code and turned the knob: 1 2 3 4 5 6 7 8 9 10 import time from machine import Pin rotaryA = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) rotaryB = Pin ( 17 , Pin . IN , Pin . PULL_DOWN ) while True : print ( rotaryA . value (), end = '' ) print ( rotaryB . value ()) time . sleep ( . 1 ) the results look like the following lines: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 00 00 00 10 01 00 00 00 11 00 00 00 01 11 00 Note that the bit values the encoders switches (on or off as 0 and 1) are place next to each other on the same line. We did this by making the end of the first print statement be the null string not the default newline character. This program prints out a LONG stream of numbers, mostly of the value 00 . The values are printed 10 times each second. Now let's take a closer look at only the values that change. What we would like to do is now only print numbers if there is a change. To do this we will \"pack\" binary values into a two bit number by shifting the A pin value to the left: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import time from machine import Pin rotaryA = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) rotaryB = Pin ( 17 , Pin . IN , Pin . PULL_DOWN ) # we set the old value to zero for both bits being off old_combined = 0 while True : A_val = rotaryA . value () B_val = rotaryB . value () # a sifts by one bit and then is ORed with the B calue new_combined = ( A_val << 1 ) | B_val if new_combined != old_combined : print ( A_val , end = '' ) print ( B_val ) old_combined = new_combined time . sleep ( . 1 ) Now we get values that look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 01 11 00 01 11 00 01 11 10 00 10 00 01 11 00 10 Turning the knob clockwise we see the 01 before the 11 frequently Turning the know counterclockwise: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 00 10 11 00 10 11 00 11 00 10 00 10 01 00 Here we see the reverse 10 pattern occur more frequently. But there is noise in the switches as they open and close due to small variations in the contacts as they move. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import time from machine import Pin rotaryA = Pin(16, Pin.IN, Pin.PULL_DOWN) rotaryB = Pin(17, Pin.IN, Pin.PULL_DOWN) # we set the old value to zero for both bits being off old_combined = 0 while True: A_val = rotaryA.value() B_val = rotaryB.value() # a sifts by one bit and then is ORed with the B calue new_combined = (A_val << 1) | B_val if new_combined != old_combined: #print(A_val, end='') #print(B_val) old_combined = new_combined if A_val == 0 and B_val == 1: print('clock') elif A_val == 1 and B_val == 0: print('counter clock') time.sleep(.1)","title":"Learning How to Monitor the Rotary Switch Transitions"},{"location":"sensors/10-rotary-encoder/#the-rotory-class","text":"I started with this rotary class . However, my setup did not work with the one she created. The numbers incremented, but they didn't decrement. I had to change the pins to use the PULL_DOWN settings in the init method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import machine import utime as time from machine import Pin import micropython class Rotary : ROT_CW = 1 ROT_CCW = 2 SW_PRESS = 4 SW_RELEASE = 8 def __init__ ( self , dt , clk , sw ): self . dt_pin = Pin ( dt , Pin . IN , Pin . PULL_DOWN ) self . clk_pin = Pin ( clk , Pin . IN , Pin . PULL_DOWN ) self . sw_pin = Pin ( sw , Pin . IN , Pin . PULL_DOWN ) self . last_status = ( self . dt_pin . value () << 1 ) | self . clk_pin . value () self . dt_pin . irq ( handler = self . rotary_change , trigger = Pin . IRQ_FALLING | Pin . IRQ_RISING ) self . clk_pin . irq ( handler = self . rotary_change , trigger = Pin . IRQ_FALLING | Pin . IRQ_RISING ) self . sw_pin . irq ( handler = self . switch_detect , trigger = Pin . IRQ_FALLING | Pin . IRQ_RISING ) self . handlers = [] self . last_button_status = self . sw_pin . value () def rotary_change ( self , pin ): new_status = ( self . dt_pin . value () << 1 ) | self . clk_pin . value () if new_status == self . last_status : return transition = ( self . last_status << 2 ) | new_status if transition == 0b1110 : micropython . schedule ( self . call_handlers , Rotary . ROT_CW ) elif transition == 0b1101 : micropython . schedule ( self . call_handlers , Rotary . ROT_CCW ) self . last_status = new_status def switch_detect ( self , pin ): if self . last_button_status == self . sw_pin . value (): return self . last_button_status = self . sw_pin . value () if self . sw_pin . value (): micropython . schedule ( self . call_handlers , Rotary . SW_RELEASE ) else : micropython . schedule ( self . call_handlers , Rotary . SW_PRESS ) def add_handler ( self , handler ): self . handlers . append ( handler ) def call_handlers ( self , type ): for handler in self . handlers : handler ( type ) The following were the lines that I changed: 1 2 3 self . dt_pin = Pin ( dt , Pin . IN , Pin . PULL_DOWN ) self . clk_pin = Pin ( clk , Pin . IN , Pin . PULL_DOWN ) self . sw_pin = Pin ( sw , Pin . IN , Pin . PULL_DOWN )","title":"The Rotory Class"},{"location":"sensors/10-rotary-encoder/#testing-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from rotary import Rotary import utime as time from machine import Pin # GPIO Pins 16 and 17 are for the encoder pins. 22 is the button press switch. rotary = Rotary ( 16 , 17 , 22 ) val = 0 def rotary_changed ( change ): global val if change == Rotary . ROT_CW : val = val + 1 print ( val ) elif change == Rotary . ROT_CCW : val = val - 1 print ( val ) elif change == Rotary . SW_PRESS : print ( 'PRESS' ) elif change == Rotary . SW_RELEASE : print ( 'RELEASE' ) rotary . add_handler ( rotary_changed ) while True : time . sleep ( 0.1 )","title":"Testing Script"},{"location":"sensors/10-rotary-encoder/#adding-plot","text":"Now I can move the knob back and forth and get consistent values that go up and down. You can turn on the plot function of Thonny to see the values consistently go up and down.","title":"Adding Plot"},{"location":"sensors/10-rotary-encoder/#mysterious-runtime-error-on-scheduling-queue","text":"I did notice that the Shell output did register the following errors: 1 2 3 Traceback (most recent call last): File \"rotary.py\", line 30, in rotary_change RuntimeError: schedule queue full The error also occurred on line 32. The following lines generated this error: 1 2 micropython . schedule ( self . call_handlers , Rotary . ROT_CW ) micropython . schedule ( self . call_handlers , Rotary . ROT_CCW ) This error did not seem to impact the execution of the code. My suspicion is that this is a bug in the Micropython firmware.","title":"Mysterious Runtime Error on Scheduling Queue"},{"location":"sensors/10-rotary-encoder/#references","text":"Counter get stuck on \"schedule queue full\"","title":"References"},{"location":"sensors/dht11-temp-humidity/","text":"The DHT22 (AM2302) Temperature and Humidity Sensor The DHT22 is a low-cost ($2) digital temperature and humidity sensor. It uses a capacitive humidity sensor and a thermistor to measure the surrounding air, and transmits a digital signal on the data pin. These devices are easy to use since they have an internal analog to digital conversion. They are good for 20-80% humidity readings with 5% accuracy and 0-50\u00b0C temperature readings with \u00b12\u00b0C accuracy. They are designed to be polled about once every two seconds. Circuit References DHT22 Datasheet (PDF)","title":"DH11 Temp and Humidity"},{"location":"sensors/dht11-temp-humidity/#the-dht22-am2302-temperature-and-humidity-sensor","text":"The DHT22 is a low-cost ($2) digital temperature and humidity sensor. It uses a capacitive humidity sensor and a thermistor to measure the surrounding air, and transmits a digital signal on the data pin. These devices are easy to use since they have an internal analog to digital conversion. They are good for 20-80% humidity readings with 5% accuracy and 0-50\u00b0C temperature readings with \u00b12\u00b0C accuracy. They are designed to be polled about once every two seconds.","title":"The DHT22 (AM2302) Temperature and Humidity Sensor"},{"location":"sensors/dht11-temp-humidity/#circuit","text":"","title":"Circuit"},{"location":"sensors/dht11-temp-humidity/#references","text":"DHT22 Datasheet (PDF)","title":"References"},{"location":"sound/01-intro/","text":"Introduction to Sound and Music in MicroPython How Microcontrollers Generate Sound Microcontrollers are really great at generating digital outputs on their GPIO pins. These digital signals that quickly switch between zero and a positive voltage like 3.3 or 5 volts. However, they are not designed to create \"analog\" output of a continuous varying voltage. However, we can use a technique called \"Pulse Width Modulation\" to simulate the various frequencies of sound using digital only outputs. Pulse Width Modulation is the process of changing not the height of a electrical signal, but the width between the pulses of digital signals. By changing the distance of the spaces between the digital signals we can generate a signal that will sound like it has a higher or lower frequency or pitch. MicroPython provides a powerful library of tools for you to easily generate pulses of different shapes. This is called the PWM library. Will will use this in our sound and music programs. Here is a sample of how this is called in our code: Duty Cycle The Duty Cycle is what percent of time a pulse is high. For working with sound, we want to generate smooth sound waves that are on 1/2 of the time and off 1/2 of the time. So our duty cycles will be set to be 50%. On the Raspberry Pi Pico we can achieve this by the following function: 1 speaker.duty_u16(1000) When we are done playing a tone, we must always explicitly turn the duty cycle back to 0. 1 speaker.duty_u16(0) If we forget to add this line, the tone will continue to play despite the main program stopping. This shows you that the part of the chip that generates the tone pulses is an independent processor that is not dependant on the main program running! 1 2 from machine import Pin , PWM from utime import sleep Note that we will also need to pause between notes, so will use the sleep library to pause execution of our sound generation. Connecting a Sound Device There are several different ways that you can connect a sound device to you MicroController. Here are three options: Buzzers - These are small inexpensive devices that can mount directly on your breadboard. Piezoelectric Speaker - Wikipedia Page on Piezoelectric Speaker Speaker - A magnetic speaker with our without an amplifier is another way to hear sound. You can also purchase a small amplifier to increase the volume. Amplifier - For about $1.20 you can purchase a small amplifier for your speaker. eBay LM386 DC 5V-12V Mini Micro Audio Amplifier Module Board References https://electronics.stackexchange.com/questions/288930/what-is-the-difference-between-a-buzzer-and-a-speaker-and-are-there-any-other-ba","title":"Introduction"},{"location":"sound/01-intro/#introduction-to-sound-and-music-in-micropython","text":"","title":"Introduction to Sound and Music in MicroPython"},{"location":"sound/01-intro/#how-microcontrollers-generate-sound","text":"Microcontrollers are really great at generating digital outputs on their GPIO pins. These digital signals that quickly switch between zero and a positive voltage like 3.3 or 5 volts. However, they are not designed to create \"analog\" output of a continuous varying voltage. However, we can use a technique called \"Pulse Width Modulation\" to simulate the various frequencies of sound using digital only outputs. Pulse Width Modulation is the process of changing not the height of a electrical signal, but the width between the pulses of digital signals. By changing the distance of the spaces between the digital signals we can generate a signal that will sound like it has a higher or lower frequency or pitch. MicroPython provides a powerful library of tools for you to easily generate pulses of different shapes. This is called the PWM library. Will will use this in our sound and music programs. Here is a sample of how this is called in our code:","title":"How Microcontrollers Generate Sound"},{"location":"sound/01-intro/#duty-cycle","text":"The Duty Cycle is what percent of time a pulse is high. For working with sound, we want to generate smooth sound waves that are on 1/2 of the time and off 1/2 of the time. So our duty cycles will be set to be 50%. On the Raspberry Pi Pico we can achieve this by the following function: 1 speaker.duty_u16(1000) When we are done playing a tone, we must always explicitly turn the duty cycle back to 0. 1 speaker.duty_u16(0) If we forget to add this line, the tone will continue to play despite the main program stopping. This shows you that the part of the chip that generates the tone pulses is an independent processor that is not dependant on the main program running! 1 2 from machine import Pin , PWM from utime import sleep Note that we will also need to pause between notes, so will use the sleep library to pause execution of our sound generation.","title":"Duty Cycle"},{"location":"sound/01-intro/#connecting-a-sound-device","text":"There are several different ways that you can connect a sound device to you MicroController. Here are three options: Buzzers - These are small inexpensive devices that can mount directly on your breadboard. Piezoelectric Speaker - Wikipedia Page on Piezoelectric Speaker Speaker - A magnetic speaker with our without an amplifier is another way to hear sound. You can also purchase a small amplifier to increase the volume. Amplifier - For about $1.20 you can purchase a small amplifier for your speaker. eBay LM386 DC 5V-12V Mini Micro Audio Amplifier Module Board","title":"Connecting a Sound Device"},{"location":"sound/01-intro/#references","text":"https://electronics.stackexchange.com/questions/288930/what-is-the-difference-between-a-buzzer-and-a-speaker-and-are-there-any-other-ba","title":"References"},{"location":"sound/02-play-tone/","text":"Play Tones Using the PWM Since we will be using the sleep function many times, we will import it by name from the Micropthon time library like this: 1 from utime import sleep Now, instead of putting utime.sleep(.5) we can just reference sleep directly like this: 1 sleep ( . 5 ) This will pause for 1/2 a second. This is how long we wait for a tone to stay on or go off. The nice thing about this menthod is that our code is a little smaller. However, you can't run other functions in the utime library. So if you want to add them later you will need to import them also, just like we did for the sleep function. Lab 1: Play A Single Tone 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # set the duty cycle to be 50% speaker . duty_u16 ( 1000 ) speaker . freq ( 1000 ) # 50% on and off sleep ( 1 ) # wait a second speaker . duty_u16 ( 0 ) # turn off the PWM circuits off with a zero duty cycle speaker . duty_u16 ( 0 ) Note The tone will keep sounding until you turn the speaker duty to 0. This shows you that the circuitry that is generating the sound is independent of the main CPU. Experiments Try changing the frequency for the first lab. This is the line speaker.freq(1000) and rerunning the program. Try using values from 10 to 10000. What values seem the loudest to your ear? What happens if you comment out the last line that sets the duty cycle to be 0? Make sure to set it back to zero again or the tone will continue playing until the device is powered off.","title":"Playing a Tone"},{"location":"sound/02-play-tone/#play-tones-using-the-pwm","text":"Since we will be using the sleep function many times, we will import it by name from the Micropthon time library like this: 1 from utime import sleep Now, instead of putting utime.sleep(.5) we can just reference sleep directly like this: 1 sleep ( . 5 ) This will pause for 1/2 a second. This is how long we wait for a tone to stay on or go off. The nice thing about this menthod is that our code is a little smaller. However, you can't run other functions in the utime library. So if you want to add them later you will need to import them also, just like we did for the sleep function.","title":"Play Tones Using the PWM"},{"location":"sound/02-play-tone/#lab-1-play-a-single-tone","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # set the duty cycle to be 50% speaker . duty_u16 ( 1000 ) speaker . freq ( 1000 ) # 50% on and off sleep ( 1 ) # wait a second speaker . duty_u16 ( 0 ) # turn off the PWM circuits off with a zero duty cycle speaker . duty_u16 ( 0 ) Note The tone will keep sounding until you turn the speaker duty to 0. This shows you that the circuitry that is generating the sound is independent of the main CPU.","title":"Lab 1: Play A Single Tone"},{"location":"sound/02-play-tone/#experiments","text":"Try changing the frequency for the first lab. This is the line speaker.freq(1000) and rerunning the program. Try using values from 10 to 10000. What values seem the loudest to your ear? What happens if you comment out the last line that sets the duty cycle to be 0? Make sure to set it back to zero again or the tone will continue playing until the device is powered off.","title":"Experiments"},{"location":"sound/03-play-three-tones/","text":"Play Three Tones In this lesson we will play three consecutive tones. Each tone will have a specific time on and we will put a time between the tones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second speaker . duty_u16 ( 0 ) sleep ( . 25 ) speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 5 ) speaker . duty_u16 ( 0 ) sleep ( . 25 ) speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 5 ) # turn off the PWM speaker . duty_u16 ( 0 ) Using Variables We can also put the time each tone stays on and the space between the tones into variables so it is easier to modify the values in a single place. 1 2 3 4 # set the time each tone will be on ONTIME = . 5 # the time between the tones OFFTIME = . 100 Three Tones With Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # the time each tone will be on ON_TIME = . 25 # the time between the tones OFF_TIME = . 1 # Low tone speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) sleep ( ON_TIME ) speaker . duty_u16 ( 0 ) sleep ( OFF_TIME ) # High tone speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( ON_TIME ) speaker . duty_u16 ( 0 ) sleep ( OFF_TIME ) # Medium tone speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( ON_TIME ) # turn off the PWM speaker . duty_u16 ( 0 ) Experiments Change the ON_TIME in the above program. What is the shortest time that you can still hear? Change the order of the Low, High, Medium around. What is the most pleasing to your ears? What order would you suggest for the start of a game and what order would you like for a \"Game Over\" sound?","title":"Playing Three Tones"},{"location":"sound/03-play-three-tones/#play-three-tones","text":"In this lesson we will play three consecutive tones. Each tone will have a specific time on and we will put a time between the tones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second speaker . duty_u16 ( 0 ) sleep ( . 25 ) speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 5 ) speaker . duty_u16 ( 0 ) sleep ( . 25 ) speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 5 ) # turn off the PWM speaker . duty_u16 ( 0 )","title":"Play Three Tones"},{"location":"sound/03-play-three-tones/#using-variables","text":"We can also put the time each tone stays on and the space between the tones into variables so it is easier to modify the values in a single place. 1 2 3 4 # set the time each tone will be on ONTIME = . 5 # the time between the tones OFFTIME = . 100","title":"Using Variables"},{"location":"sound/03-play-three-tones/#three-tones-with-variables","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # the time each tone will be on ON_TIME = . 25 # the time between the tones OFF_TIME = . 1 # Low tone speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) sleep ( ON_TIME ) speaker . duty_u16 ( 0 ) sleep ( OFF_TIME ) # High tone speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( ON_TIME ) speaker . duty_u16 ( 0 ) sleep ( OFF_TIME ) # Medium tone speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( ON_TIME ) # turn off the PWM speaker . duty_u16 ( 0 )","title":"Three Tones With Variables"},{"location":"sound/03-play-three-tones/#experiments","text":"Change the ON_TIME in the above program. What is the shortest time that you can still hear? Change the order of the Low, High, Medium around. What is the most pleasing to your ears? What order would you suggest for the start of a game and what order would you like for a \"Game Over\" sound?","title":"Experiments"},{"location":"sound/04-play-scale/","text":"Play a Scale In this lesson, we will learn about how to automatically generate various pitches. We will see that the spacing between lower pitches is different from the spacing between higher pitches. Here is a program that plays a scale of notes from a starting frequency of 30 hertz to an upper frequency of around 10,000 hertz. Note that 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) def playtone ( frequency ): speaker . duty_u16 ( 1000 ) speaker . freq ( frequency ) sleep ( 0.3 ) def bequiet (): speaker . duty_u16 ( 0 ) freq = 30 for i in range ( 64 ): print ( freq ) playtone ( freq ) freq = int ( freq * 1.1 ) # Turn off the PWM speaker . duty_u16 ( 0 ) New Frequency Spacing When you run the prior example, note the frequencies printed to the console. Are they evenly spaced? Take a close look at the line that creates a new frequency: 1 freq = int ( freq * 1.1 ) The effect of this line is to create a new frequency that is 10% higher than the prior frequency. Experiments What happens if you change the frequency update to be freq = freq +100","title":"Playing a Scale"},{"location":"sound/04-play-scale/#play-a-scale","text":"In this lesson, we will learn about how to automatically generate various pitches. We will see that the spacing between lower pitches is different from the spacing between higher pitches. Here is a program that plays a scale of notes from a starting frequency of 30 hertz to an upper frequency of around 10,000 hertz. Note that 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) def playtone ( frequency ): speaker . duty_u16 ( 1000 ) speaker . freq ( frequency ) sleep ( 0.3 ) def bequiet (): speaker . duty_u16 ( 0 ) freq = 30 for i in range ( 64 ): print ( freq ) playtone ( freq ) freq = int ( freq * 1.1 ) # Turn off the PWM speaker . duty_u16 ( 0 )","title":"Play a Scale"},{"location":"sound/04-play-scale/#new-frequency-spacing","text":"When you run the prior example, note the frequencies printed to the console. Are they evenly spaced? Take a close look at the line that creates a new frequency: 1 freq = int ( freq * 1.1 ) The effect of this line is to create a new frequency that is 10% higher than the prior frequency.","title":"New Frequency Spacing"},{"location":"sound/04-play-scale/#experiments","text":"What happens if you change the frequency update to be freq = freq +100","title":"Experiments"},{"location":"sound/05-play-mario/","text":"Play Mario on MicroPython This program will play the theme music from the Mario video game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from machine import Pin , PWM from utime import sleep buzzer = PWM ( Pin ( 16 )) tones = { \"B0\" : 31 , \"C1\" : 33 , \"CS1\" : 35 , \"D1\" : 37 , \"DS1\" : 39 , \"E1\" : 41 , \"F1\" : 44 , \"FS1\" : 46 , \"G1\" : 49 , \"GS1\" : 52 , \"A1\" : 55 , \"AS1\" : 58 , \"B1\" : 62 , \"C2\" : 65 , \"CS2\" : 69 , \"D2\" : 73 , \"DS2\" : 78 , \"E2\" : 82 , \"F2\" : 87 , \"FS2\" : 93 , \"G2\" : 98 , \"GS2\" : 104 , \"A2\" : 110 , \"AS2\" : 117 , \"B2\" : 123 , \"C3\" : 131 , \"CS3\" : 139 , \"D3\" : 147 , \"DS3\" : 156 , \"E3\" : 165 , \"F3\" : 175 , \"FS3\" : 185 , \"G3\" : 196 , \"GS3\" : 208 , \"A3\" : 220 , \"AS3\" : 233 , \"B3\" : 247 , \"C4\" : 262 , \"CS4\" : 277 , \"D4\" : 294 , \"DS4\" : 311 , \"E4\" : 330 , \"F4\" : 349 , \"FS4\" : 370 , \"G4\" : 392 , \"GS4\" : 415 , \"A4\" : 440 , \"AS4\" : 466 , \"B4\" : 494 , \"C5\" : 523 , \"CS5\" : 554 , \"D5\" : 587 , \"DS5\" : 622 , \"E5\" : 659 , \"F5\" : 698 , \"FS5\" : 740 , \"G5\" : 784 , \"GS5\" : 831 , \"A5\" : 880 , \"AS5\" : 932 , \"B5\" : 988 , \"C6\" : 1047 , \"CS6\" : 1109 , \"D6\" : 1175 , \"DS6\" : 1245 , \"E6\" : 1319 , \"F6\" : 1397 , \"FS6\" : 1480 , \"G6\" : 1568 , \"GS6\" : 1661 , \"A6\" : 1760 , \"AS6\" : 1865 , \"B6\" : 1976 , \"C7\" : 2093 , \"CS7\" : 2217 , \"D7\" : 2349 , \"DS7\" : 2489 , \"E7\" : 2637 , \"F7\" : 2794 , \"FS7\" : 2960 , \"G7\" : 3136 , \"GS7\" : 3322 , \"A7\" : 3520 , \"AS7\" : 3729 , \"B7\" : 3951 , \"C8\" : 4186 , \"CS8\" : 4435 , \"D8\" : 4699 , \"DS8\" : 4978 } song = [ \"E5\" , \"G5\" , \"A5\" , \"P\" , \"E5\" , \"G5\" , \"B5\" , \"A5\" , \"P\" , \"E5\" , \"G5\" , \"A5\" , \"P\" , \"G5\" , \"E5\" ] mario = [ \"E7\" , \"E7\" , 0 , \"E7\" , 0 , \"C7\" , \"E7\" , 0 , \"G7\" , 0 , 0 , 0 , \"G6\" , 0 , 0 , 0 , \"C7\" , 0 , 0 , \"G6\" , 0 , 0 , \"E6\" , 0 , 0 , \"A6\" , 0 , \"B6\" , 0 , \"AS6\" , \"A6\" , 0 , \"G6\" , \"E7\" , 0 , \"G7\" , \"A7\" , 0 , \"F7\" , \"G7\" , 0 , \"E7\" , 0 , \"C7\" , \"D7\" , \"B6\" , 0 , 0 , \"C7\" , 0 , 0 , \"G6\" , 0 , 0 , \"E6\" , 0 , 0 , \"A6\" , 0 , \"B6\" , 0 , \"AS6\" , \"A6\" , 0 , \"G6\" , \"E7\" , 0 , \"G7\" , \"A7\" , 0 , \"F7\" , \"G7\" , 0 , \"E7\" , 0 , \"C7\" , \"D7\" , \"B6\" , 0 , 0 ] def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) def playsong ( mysong ): for i in range ( len ( mysong )): if ( mysong [ i ] == \"P\" or mysong [ i ] == 0 ): bequiet () else : playtone ( tones [ mysong [ i ]]) sleep ( 0.3 ) bequiet () playsong ( mario )","title":"Play Mario"},{"location":"sound/05-play-mario/#play-mario-on-micropython","text":"This program will play the theme music from the Mario video game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from machine import Pin , PWM from utime import sleep buzzer = PWM ( Pin ( 16 )) tones = { \"B0\" : 31 , \"C1\" : 33 , \"CS1\" : 35 , \"D1\" : 37 , \"DS1\" : 39 , \"E1\" : 41 , \"F1\" : 44 , \"FS1\" : 46 , \"G1\" : 49 , \"GS1\" : 52 , \"A1\" : 55 , \"AS1\" : 58 , \"B1\" : 62 , \"C2\" : 65 , \"CS2\" : 69 , \"D2\" : 73 , \"DS2\" : 78 , \"E2\" : 82 , \"F2\" : 87 , \"FS2\" : 93 , \"G2\" : 98 , \"GS2\" : 104 , \"A2\" : 110 , \"AS2\" : 117 , \"B2\" : 123 , \"C3\" : 131 , \"CS3\" : 139 , \"D3\" : 147 , \"DS3\" : 156 , \"E3\" : 165 , \"F3\" : 175 , \"FS3\" : 185 , \"G3\" : 196 , \"GS3\" : 208 , \"A3\" : 220 , \"AS3\" : 233 , \"B3\" : 247 , \"C4\" : 262 , \"CS4\" : 277 , \"D4\" : 294 , \"DS4\" : 311 , \"E4\" : 330 , \"F4\" : 349 , \"FS4\" : 370 , \"G4\" : 392 , \"GS4\" : 415 , \"A4\" : 440 , \"AS4\" : 466 , \"B4\" : 494 , \"C5\" : 523 , \"CS5\" : 554 , \"D5\" : 587 , \"DS5\" : 622 , \"E5\" : 659 , \"F5\" : 698 , \"FS5\" : 740 , \"G5\" : 784 , \"GS5\" : 831 , \"A5\" : 880 , \"AS5\" : 932 , \"B5\" : 988 , \"C6\" : 1047 , \"CS6\" : 1109 , \"D6\" : 1175 , \"DS6\" : 1245 , \"E6\" : 1319 , \"F6\" : 1397 , \"FS6\" : 1480 , \"G6\" : 1568 , \"GS6\" : 1661 , \"A6\" : 1760 , \"AS6\" : 1865 , \"B6\" : 1976 , \"C7\" : 2093 , \"CS7\" : 2217 , \"D7\" : 2349 , \"DS7\" : 2489 , \"E7\" : 2637 , \"F7\" : 2794 , \"FS7\" : 2960 , \"G7\" : 3136 , \"GS7\" : 3322 , \"A7\" : 3520 , \"AS7\" : 3729 , \"B7\" : 3951 , \"C8\" : 4186 , \"CS8\" : 4435 , \"D8\" : 4699 , \"DS8\" : 4978 } song = [ \"E5\" , \"G5\" , \"A5\" , \"P\" , \"E5\" , \"G5\" , \"B5\" , \"A5\" , \"P\" , \"E5\" , \"G5\" , \"A5\" , \"P\" , \"G5\" , \"E5\" ] mario = [ \"E7\" , \"E7\" , 0 , \"E7\" , 0 , \"C7\" , \"E7\" , 0 , \"G7\" , 0 , 0 , 0 , \"G6\" , 0 , 0 , 0 , \"C7\" , 0 , 0 , \"G6\" , 0 , 0 , \"E6\" , 0 , 0 , \"A6\" , 0 , \"B6\" , 0 , \"AS6\" , \"A6\" , 0 , \"G6\" , \"E7\" , 0 , \"G7\" , \"A7\" , 0 , \"F7\" , \"G7\" , 0 , \"E7\" , 0 , \"C7\" , \"D7\" , \"B6\" , 0 , 0 , \"C7\" , 0 , 0 , \"G6\" , 0 , 0 , \"E6\" , 0 , 0 , \"A6\" , 0 , \"B6\" , 0 , \"AS6\" , \"A6\" , 0 , \"G6\" , \"E7\" , 0 , \"G7\" , \"A7\" , 0 , \"F7\" , \"G7\" , 0 , \"E7\" , 0 , \"C7\" , \"D7\" , \"B6\" , 0 , 0 ] def playtone ( frequency ): buzzer . duty_u16 ( 1000 ) buzzer . freq ( frequency ) def bequiet (): buzzer . duty_u16 ( 0 ) def playsong ( mysong ): for i in range ( len ( mysong )): if ( mysong [ i ] == \"P\" or mysong [ i ] == 0 ): bequiet () else : playtone ( tones [ mysong [ i ]]) sleep ( 0.3 ) bequiet () playsong ( mario )","title":"Play Mario on MicroPython"},{"location":"sound/06-eight-key-piano/","text":"Eight Key Piano In this lab we wire up eight momentary press buttons so that when each one is pressed it will play a different note. To create this project, you will need the following parts: A Raspberry Pi Pico A standard size breadboard or two 1/2 breadboards 8 momentary press buttons A speaker or a Piezo buzzer An optional sound amplifier such as the LM386 DC 5V-12V Mini Micro Audio Amplifier which can be purchased on e-bay for under $2 USD. If you are working in a quiet room you may not need the amplifier. Each \"key\" is a momentary press button that is wired up between a GPIO pin and the +3.3 volt rail on the breadboard connected to 3V3(OUT) pin . We do not need to use any resistors to pull the signals low since we configure the pins to be inputs with the PULL_DOWN resistor like this: 1 button_pin_1 = machine . Pin ( 10 , machine . Pin . IN , machine . Pin . PULL_DOWN ) The Play Tone Functions We will use two Python functions, one for playing a tone of a given frequency and one for turning off the sound. 1 2 3 4 5 6 7 8 def playtone ( frequency ): speaker . duty_u16 ( 1000 ) # turn the PWM duty to 50% speaker . freq ( frequency ) builtin_led . high () # turn builtin LED on def bequiet (): speaker . duty_u16 ( 0 ) # turn off the speaker PWM builtin_led . low () # turn builtin LED off We will also use the .value() method on each pin to detect if it is HIGH (1) like this: 1 2 if button_pin_1 . value () == 1 : playtone ( 220 ) # A3 We will be playing \"notes\" generating square waves with various frequencies from our lowest note of A3 at 220 Hz up to A4 at 440 Hz. Sample Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # play a tone durning button down from machine import Pin , PWM from utime import sleep , ticks_ms SPEAKER_PIN = 22 # pass through a speaker and tie the other end to GND speaker = PWM ( Pin ( SPEAKER_PIN )) builtin_led = machine . Pin ( 25 , Pin . OUT ) # Connect these GP pins through a button to the +3.3 volt rail button_pin_1 = machine . Pin ( 10 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_2 = machine . Pin ( 11 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_3 = machine . Pin ( 12 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_4 = machine . Pin ( 13 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_5 = machine . Pin ( 14 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_6 = machine . Pin ( 15 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_7 = machine . Pin ( 16 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_8 = machine . Pin ( 17 , machine . Pin . IN , machine . Pin . PULL_DOWN ) def playtone ( frequency ): speaker . duty_u16 ( 1000 ) # turn the PWM duty to 50% speaker . freq ( frequency ) builtin_led . high () # turn builtin LED on def bequiet (): speaker . duty_u16 ( 0 ) # turn off the speaker PWM builtin_led . low () # turn builtin LED off while True : if button_pin_1 . value () == 1 : playtone ( 220 ) # A3 elif button_pin_2 . value () == 1 : playtone ( 247 ) # B3 elif button_pin_3 . value () == 1 : playtone ( 262 ) # C4 elif button_pin_4 . value () == 1 : playtone ( 294 ) # D4 elif button_pin_5 . value () == 1 : playtone ( 330 ) # E4 elif button_pin_6 . value () == 1 : playtone ( 349 ) # F4 elif button_pin_7 . value () == 1 : playtone ( 392 ) # G4 elif button_pin_8 . value () == 1 : playtone ( 440 ) # A4 else : bequiet () Exercises Rewrite the code above using lists for the pin numbers and the notes. Try different notes with other scales. Add another button to change the \"octave\" of the notes. Add a display to show the notes as they are being played. Print the time each note is being pressed as well as the length of the pauses between the notes. Write the notes to a recording file. Add a menu system so you can do things like start a new song recording, save a recording and playback a recording. Eight keys are not enough for many songs. Use two full-size breadboards to expand the number of keys on your piano. Look into getting a MIDI keyboard such as the 32-key $40 MIDIPLUS AKM320 USB MIDI Keyboard Controller Read this blog about running MIDI on the Pico: MIDI, MicroPython and the Raspberry Pi Pico","title":"Eight Key Piano"},{"location":"sound/06-eight-key-piano/#eight-key-piano","text":"In this lab we wire up eight momentary press buttons so that when each one is pressed it will play a different note. To create this project, you will need the following parts: A Raspberry Pi Pico A standard size breadboard or two 1/2 breadboards 8 momentary press buttons A speaker or a Piezo buzzer An optional sound amplifier such as the LM386 DC 5V-12V Mini Micro Audio Amplifier which can be purchased on e-bay for under $2 USD. If you are working in a quiet room you may not need the amplifier. Each \"key\" is a momentary press button that is wired up between a GPIO pin and the +3.3 volt rail on the breadboard connected to 3V3(OUT) pin . We do not need to use any resistors to pull the signals low since we configure the pins to be inputs with the PULL_DOWN resistor like this: 1 button_pin_1 = machine . Pin ( 10 , machine . Pin . IN , machine . Pin . PULL_DOWN )","title":"Eight Key Piano"},{"location":"sound/06-eight-key-piano/#the-play-tone-functions","text":"We will use two Python functions, one for playing a tone of a given frequency and one for turning off the sound. 1 2 3 4 5 6 7 8 def playtone ( frequency ): speaker . duty_u16 ( 1000 ) # turn the PWM duty to 50% speaker . freq ( frequency ) builtin_led . high () # turn builtin LED on def bequiet (): speaker . duty_u16 ( 0 ) # turn off the speaker PWM builtin_led . low () # turn builtin LED off We will also use the .value() method on each pin to detect if it is HIGH (1) like this: 1 2 if button_pin_1 . value () == 1 : playtone ( 220 ) # A3 We will be playing \"notes\" generating square waves with various frequencies from our lowest note of A3 at 220 Hz up to A4 at 440 Hz.","title":"The Play Tone Functions"},{"location":"sound/06-eight-key-piano/#sample-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # play a tone durning button down from machine import Pin , PWM from utime import sleep , ticks_ms SPEAKER_PIN = 22 # pass through a speaker and tie the other end to GND speaker = PWM ( Pin ( SPEAKER_PIN )) builtin_led = machine . Pin ( 25 , Pin . OUT ) # Connect these GP pins through a button to the +3.3 volt rail button_pin_1 = machine . Pin ( 10 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_2 = machine . Pin ( 11 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_3 = machine . Pin ( 12 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_4 = machine . Pin ( 13 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_5 = machine . Pin ( 14 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_6 = machine . Pin ( 15 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_7 = machine . Pin ( 16 , machine . Pin . IN , machine . Pin . PULL_DOWN ) button_pin_8 = machine . Pin ( 17 , machine . Pin . IN , machine . Pin . PULL_DOWN ) def playtone ( frequency ): speaker . duty_u16 ( 1000 ) # turn the PWM duty to 50% speaker . freq ( frequency ) builtin_led . high () # turn builtin LED on def bequiet (): speaker . duty_u16 ( 0 ) # turn off the speaker PWM builtin_led . low () # turn builtin LED off while True : if button_pin_1 . value () == 1 : playtone ( 220 ) # A3 elif button_pin_2 . value () == 1 : playtone ( 247 ) # B3 elif button_pin_3 . value () == 1 : playtone ( 262 ) # C4 elif button_pin_4 . value () == 1 : playtone ( 294 ) # D4 elif button_pin_5 . value () == 1 : playtone ( 330 ) # E4 elif button_pin_6 . value () == 1 : playtone ( 349 ) # F4 elif button_pin_7 . value () == 1 : playtone ( 392 ) # G4 elif button_pin_8 . value () == 1 : playtone ( 440 ) # A4 else : bequiet ()","title":"Sample Code"},{"location":"sound/06-eight-key-piano/#exercises","text":"Rewrite the code above using lists for the pin numbers and the notes. Try different notes with other scales. Add another button to change the \"octave\" of the notes. Add a display to show the notes as they are being played. Print the time each note is being pressed as well as the length of the pauses between the notes. Write the notes to a recording file. Add a menu system so you can do things like start a new song recording, save a recording and playback a recording. Eight keys are not enough for many songs. Use two full-size breadboards to expand the number of keys on your piano. Look into getting a MIDI keyboard such as the 32-key $40 MIDIPLUS AKM320 USB MIDI Keyboard Controller Read this blog about running MIDI on the Pico: MIDI, MicroPython and the Raspberry Pi Pico","title":"Exercises"},{"location":"sound/07-play-audio-file/","text":"Playing an Audio File Note This lesson is still a work in progress. The wavePlayer is in an early draft form and has unpredictable interactions with other components. See the wav file test results section below. We also are having problems when different GPIO pins are used. If you stick to pins for GPIO 2 and 3 for the two channels the test run OK. Playing Sounds on The RP2040 Chip Although we can play tones of various pitches on the PR2040 using the PMW to generate square waves, the quality of this sound is not close to high-fidelity sound like you would expect in a personal MP3 audio player. In this lesson we will demonstrate how to play a high-quality audio files that are stored on the two megabytes of non-volatile static memory of the Pico. According to the specification of the Raspberry Pi Pico , the system comes with 2MB on-board QSPI Flash that we can use to store sound files. By combining our Pico with an SD card reader we can also play many sounds and even full-length music and full albums. Background on Audio Encoding Audio files are encoded in many formats. For this lab there are two key concepts to understand: The Sampling Rate which is how frequently an audio signal is sampled. The more frequently we sample (up to 41K per second) the higher the fidelity of the recording. The downside is that the audio file takes more space. The audio bit depth is how many bits we used to encode the amplitude of the sound. For our labs, we will be using mono files (not stereo) a sampling rate of 8,000 samples per second (8K Hz) and a sampling rate of 16-bit depth. This is a good compromise between smaller size and sound fidelity in typical robots. Our robots typically will play a short 1-second sound to tell us they are performing an action like stopping, backing up or turning. This one-second 8K Hz WAV file will be about 20K. Our flash budget for the Raspberry Pi Pico is 2M, so we can easily store 10 sound effects in 200K or 1/10 of our available flash memory. We can also add a SD card if we need more flash memory. We will be using standard .WAV files with Pulse Code Modulation Encoding in .WAV files. WAV files do take more space than compressed MP3 files, but they are easier to play because the decoding steps are trivial for a microcontroller to perform. Overall Architecture We will be reading .wav files from the MicroPython non-volatile flash memory or an SD card. By convention we will store them in a directory called /sounds We will be using the wave.py module to read the .wav files We will be using the myPMW.py, chunk.py and myDMA.py modules to stream the data from the WAV files to the PWM controllers The metadata from the .wav files is used to change the sampling frequency of the .wav player Checking Your Sound File Sizes 1 2 3 4 5 6 7 8 9 10 11 import os waveFolder = \"/sounds\" total = 0 # get a list of .wav files and their sizes for file in os . listdir ( waveFolder ): size = os . path . getsize ( file ) print ( file , size ) total += size print ( 'Total sound directory size:' , total ) Connections Some of this documentation was take from Dan Perron's Pico Audio GitHub Repo . In these tests we used GPIO pins 2 and 3 to drive the left and right channels of audio that are sent to a stereo amplifier. You can use both an amplifier or head phone with a 1K resistor in series on the pins to limit the current from the 3.3v output signals. The myPWM subclass set the maximum count to 255 (8 bits) or 1023(10bits) at a frequency around 122.5KHz. The PWM is now on 10 bits (0..1023) The myDMA class allows to use direct memory access to transfer each frame at the current sample rate. We will need to install the wave.py and chunk.py from Jokey GitHub Awesome MicroPython Repo on root file system or the /lib folder on the pico file system. Don't forget to increase the SPI clock up to 3Mhz. (TODO not sure what this means) The following documentation was take from Daniel Perron's Github page. We set the PWM to a range of 255 at 122Khz We read the wave file using the class wave.py which will set the sample rate and read the audio data by chunk Each chunk is converted to 16 bit signed to unsigned char with the middle at 128, (512 for 10 bits) We wait for the DMA to be completed. On first it will be anyway. The converted chunk is then pass to the DMA to be transfer at the sample rate using one of build in timer Go on step 2 until is done. Steps to test playing a wav file Clone the Pico Audio PWM GitHub Repository 1 2 git clone https://github.com/danjperron/PicoAudioPWM cd PicoAudioPWM Download some test robot wav files The following GitHub location: https://github.com/CoderDojoTC/robot-media/tree/master/wav-8k contains a set of 8K Hz 16 bit robot sounds that you can use with your robot. Converting .MP3 to .WAV files This software only currently support playing .wav files since it is easy to convert these files into a format that can be played. WAV files store uncompressed audio, so they are larger than MP3 files. Wav files are simple ways to store sound patterns. MP3 files are much more complex and require complex algorithms to convert into sound outputs. The usual bitstream encoding is the linear pulse-code modulation (LPCM) format. If you have just a few MP3 files, can use the following web-site to convert MP3 files into wave files: Cloud Convert Service that Converts MP3 to WAV files The next lab shows you how to convert an entire folder of MP3 files to 8K Hz 16-bit WAV files using a shell script. Copy Sound Files to the Pico Your pico has 2MB of static memory. A typical robot sound effect you want to play when you bump into and object will play for around 1 second. You can copy many sound effect files to the pico file system and play them. Some IDEs may allow you to do this or you can use the rshell program. Here is an example of using the rshell program to copy a directory of wav files to the pico. Lines that start with pc$ are commands that you type into your PC or MAC's terminal. Lines that start with rs$ are commands that you type into the rshell. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # list the devices (only works on Mac and UNIX) pc$ ls /dev/cu.modem* # start the rshell pc$ rshell -p /dev/cu.modem* # change the name of the device to be \"pico\" rs$ echo 'name=\"pico\"' > /pyboard/board.py # exit from rshell - can also use exit CONTROL-C # reconnect with the rshell $pc rshell -p /dev/cu.modem* # go into the /pico file systems $rs cd /pico # create a directory for all our sound files mkdir sounds # copy files from hour PC's home ~/tmp/sounds dir to the pico rs$ cp ~/tmp/sounds/*.wav /pico/sounds rs$ ls /pico/sounds Listing the Wave Files After you have a list of Wave files loaded you can verify them by using the os listdir() function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import os waveFolder = \"/sounds\" wavelist = [] # get a list of .wav files for i in os . listdir ( waveFolder ): if i . find ( \".wav\" ) >= 0 : wavelist . append ( waveFolder + \"/\" + i ) elif i . find ( \".WAV\" ) >= 0 : wavelist . append ( waveFolder + \"/\" + i ) if not wavelist : print ( \"Warning NO '.wav' files\" ) else : for i in wavelist : print ( i ) Sample console output 1 2 3 4 5 6 /sounds/cylon-attention.wav /sounds/cylon-by-your-command.wav /sounds/cylon-excellent.wav /sounds/cylon-eye-scanner.wav /sounds/cylon-see-that-the-humans.wav /sounds/cylon-those-are-not-the-sounds.wav Checking the WAV File Format There is a standard Python module called `wave.py that reads the .wav files and shows the metadata for the file. Wave files come in many formats, single channel, stereo and different bit rates. The wave player can show us all this data that describes the wave file. The report shows you how to use fixed-width formatting since the file names and data should fit in columns to make it easier to read. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import os import wave waveFolder = \"/sounds\" wavelist = [] # get a list of .wav files for i in os . listdir ( waveFolder ): if i . find ( \".wav\" ) >= 0 : wavelist . append ( waveFolder + \"/\" + i ) elif i . find ( \".WAV\" ) >= 0 : wavelist . append ( waveFolder + \"/\" + i ) if not wavelist : print ( \"Warning NO '.wav' files\" ) else : print ( \" {0:<45} \" . format ( 'File Path' ), 'Frame Rate Width Chans Frames' ) for filename in wavelist : f = wave . open ( filename , 'rb' ) # the format string \"{0:<50}\" says print left justified from chars 0 to 50 in a fixed with string print ( \" {0:<50} \" . format ( filename ), \" {0:>5} \" . format ( f . getframerate ()), \" {0:>5} \" . format ( f . getsampwidth ()), \" {0:>6} \" . format ( f . getnchannels ()), \" {0:>6} \" . format ( f . getnframes ()) ) Sample Response 1 2 3 4 5 6 7 File Path Frame Rate Width Chans Frames /sounds/cylon-attention.wav 8000 1 1 6399 /sounds/cylon-by-your-command.wav 11025 1 1 12583 /sounds/cylon-excellent.wav 22050 1 1 48736 /sounds/cylon-eye-scanner.wav 16000 2 2 24768 /sounds/cylon-see-that-the-humans.wav 11025 1 1 30743 /sounds/cylon-those-are-not-the-sounds.wav 22050 1 1 64137 Adding an Interrupt If you halt the RP2040 while it is playing a sound, the independent PWM controllers will continue to generate sound. In order to shut the independent PWM controllers, an interrupt controller system must be used to cleanly disable all the sound. Here is an example of this using a try/except block of code. 1 2 3 4 5 6 7 8 9 10 11 import os as uos from wavePlayer import wavePlayer player = wavePlayer () try : while True : # repeat this over and over until the keyboard shuts down the circuit player . play ( '/sounds/cylon-eye-scanner.wav' ) except KeyboardInterrupt : player . stop () print ( \"wave player terminated\" ) Playing the Same Sound Repeatedly 1 2 3 4 5 6 7 8 9 10 import os as uos from wavePlayer import wavePlayer player = wavePlayer () try : while True : player . play ( '/sounds/cylon-eye-scanner.wav' ) except KeyboardInterrupt : player . stop () print ( \"wave player terminated\" ) Downloading the Audio Libraries Both the wave.py and the chunck.py files are here: https://github.com/joeky888/awesome-micropython-lib/tree/master/Audio References Daniel Perron Wikipedia page for Wave File c Web-Based Audio Conversion Service Convertio Wikipedia page for Audio Interchange File Format Wikipedia page for Pulse-code Modulation Raspberry Pi Pico Forum on Sounds Files","title":"Play Audio File"},{"location":"sound/07-play-audio-file/#playing-an-audio-file","text":"Note This lesson is still a work in progress. The wavePlayer is in an early draft form and has unpredictable interactions with other components. See the wav file test results section below. We also are having problems when different GPIO pins are used. If you stick to pins for GPIO 2 and 3 for the two channels the test run OK.","title":"Playing an Audio File"},{"location":"sound/07-play-audio-file/#playing-sounds-on-the-rp2040-chip","text":"Although we can play tones of various pitches on the PR2040 using the PMW to generate square waves, the quality of this sound is not close to high-fidelity sound like you would expect in a personal MP3 audio player. In this lesson we will demonstrate how to play a high-quality audio files that are stored on the two megabytes of non-volatile static memory of the Pico. According to the specification of the Raspberry Pi Pico , the system comes with 2MB on-board QSPI Flash that we can use to store sound files. By combining our Pico with an SD card reader we can also play many sounds and even full-length music and full albums.","title":"Playing Sounds on The RP2040 Chip"},{"location":"sound/07-play-audio-file/#background-on-audio-encoding","text":"Audio files are encoded in many formats. For this lab there are two key concepts to understand: The Sampling Rate which is how frequently an audio signal is sampled. The more frequently we sample (up to 41K per second) the higher the fidelity of the recording. The downside is that the audio file takes more space. The audio bit depth is how many bits we used to encode the amplitude of the sound. For our labs, we will be using mono files (not stereo) a sampling rate of 8,000 samples per second (8K Hz) and a sampling rate of 16-bit depth. This is a good compromise between smaller size and sound fidelity in typical robots. Our robots typically will play a short 1-second sound to tell us they are performing an action like stopping, backing up or turning. This one-second 8K Hz WAV file will be about 20K. Our flash budget for the Raspberry Pi Pico is 2M, so we can easily store 10 sound effects in 200K or 1/10 of our available flash memory. We can also add a SD card if we need more flash memory. We will be using standard .WAV files with Pulse Code Modulation Encoding in .WAV files. WAV files do take more space than compressed MP3 files, but they are easier to play because the decoding steps are trivial for a microcontroller to perform.","title":"Background on Audio Encoding"},{"location":"sound/07-play-audio-file/#overall-architecture","text":"We will be reading .wav files from the MicroPython non-volatile flash memory or an SD card. By convention we will store them in a directory called /sounds We will be using the wave.py module to read the .wav files We will be using the myPMW.py, chunk.py and myDMA.py modules to stream the data from the WAV files to the PWM controllers The metadata from the .wav files is used to change the sampling frequency of the .wav player","title":"Overall Architecture"},{"location":"sound/07-play-audio-file/#checking-your-sound-file-sizes","text":"1 2 3 4 5 6 7 8 9 10 11 import os waveFolder = \"/sounds\" total = 0 # get a list of .wav files and their sizes for file in os . listdir ( waveFolder ): size = os . path . getsize ( file ) print ( file , size ) total += size print ( 'Total sound directory size:' , total )","title":"Checking Your Sound File Sizes"},{"location":"sound/07-play-audio-file/#connections","text":"Some of this documentation was take from Dan Perron's Pico Audio GitHub Repo . In these tests we used GPIO pins 2 and 3 to drive the left and right channels of audio that are sent to a stereo amplifier. You can use both an amplifier or head phone with a 1K resistor in series on the pins to limit the current from the 3.3v output signals. The myPWM subclass set the maximum count to 255 (8 bits) or 1023(10bits) at a frequency around 122.5KHz. The PWM is now on 10 bits (0..1023) The myDMA class allows to use direct memory access to transfer each frame at the current sample rate. We will need to install the wave.py and chunk.py from Jokey GitHub Awesome MicroPython Repo on root file system or the /lib folder on the pico file system. Don't forget to increase the SPI clock up to 3Mhz. (TODO not sure what this means) The following documentation was take from Daniel Perron's Github page. We set the PWM to a range of 255 at 122Khz We read the wave file using the class wave.py which will set the sample rate and read the audio data by chunk Each chunk is converted to 16 bit signed to unsigned char with the middle at 128, (512 for 10 bits) We wait for the DMA to be completed. On first it will be anyway. The converted chunk is then pass to the DMA to be transfer at the sample rate using one of build in timer Go on step 2 until is done.","title":"Connections"},{"location":"sound/07-play-audio-file/#steps-to-test-playing-a-wav-file","text":"","title":"Steps to test playing a wav file"},{"location":"sound/07-play-audio-file/#clone-the-pico-audio-pwm-github-repository","text":"1 2 git clone https://github.com/danjperron/PicoAudioPWM cd PicoAudioPWM","title":"Clone the Pico Audio PWM GitHub Repository"},{"location":"sound/07-play-audio-file/#download-some-test-robot-wav-files","text":"The following GitHub location: https://github.com/CoderDojoTC/robot-media/tree/master/wav-8k contains a set of 8K Hz 16 bit robot sounds that you can use with your robot.","title":"Download some test robot wav files"},{"location":"sound/07-play-audio-file/#converting-mp3-to-wav-files","text":"This software only currently support playing .wav files since it is easy to convert these files into a format that can be played. WAV files store uncompressed audio, so they are larger than MP3 files. Wav files are simple ways to store sound patterns. MP3 files are much more complex and require complex algorithms to convert into sound outputs. The usual bitstream encoding is the linear pulse-code modulation (LPCM) format. If you have just a few MP3 files, can use the following web-site to convert MP3 files into wave files: Cloud Convert Service that Converts MP3 to WAV files The next lab shows you how to convert an entire folder of MP3 files to 8K Hz 16-bit WAV files using a shell script.","title":"Converting .MP3 to .WAV files"},{"location":"sound/07-play-audio-file/#copy-sound-files-to-the-pico","text":"Your pico has 2MB of static memory. A typical robot sound effect you want to play when you bump into and object will play for around 1 second. You can copy many sound effect files to the pico file system and play them. Some IDEs may allow you to do this or you can use the rshell program. Here is an example of using the rshell program to copy a directory of wav files to the pico. Lines that start with pc$ are commands that you type into your PC or MAC's terminal. Lines that start with rs$ are commands that you type into the rshell. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # list the devices (only works on Mac and UNIX) pc$ ls /dev/cu.modem* # start the rshell pc$ rshell -p /dev/cu.modem* # change the name of the device to be \"pico\" rs$ echo 'name=\"pico\"' > /pyboard/board.py # exit from rshell - can also use exit CONTROL-C # reconnect with the rshell $pc rshell -p /dev/cu.modem* # go into the /pico file systems $rs cd /pico # create a directory for all our sound files mkdir sounds # copy files from hour PC's home ~/tmp/sounds dir to the pico rs$ cp ~/tmp/sounds/*.wav /pico/sounds rs$ ls /pico/sounds","title":"Copy Sound Files to the Pico"},{"location":"sound/07-play-audio-file/#listing-the-wave-files","text":"After you have a list of Wave files loaded you can verify them by using the os listdir() function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import os waveFolder = \"/sounds\" wavelist = [] # get a list of .wav files for i in os . listdir ( waveFolder ): if i . find ( \".wav\" ) >= 0 : wavelist . append ( waveFolder + \"/\" + i ) elif i . find ( \".WAV\" ) >= 0 : wavelist . append ( waveFolder + \"/\" + i ) if not wavelist : print ( \"Warning NO '.wav' files\" ) else : for i in wavelist : print ( i ) Sample console output 1 2 3 4 5 6 /sounds/cylon-attention.wav /sounds/cylon-by-your-command.wav /sounds/cylon-excellent.wav /sounds/cylon-eye-scanner.wav /sounds/cylon-see-that-the-humans.wav /sounds/cylon-those-are-not-the-sounds.wav","title":"Listing the Wave Files"},{"location":"sound/07-play-audio-file/#checking-the-wav-file-format","text":"There is a standard Python module called `wave.py that reads the .wav files and shows the metadata for the file. Wave files come in many formats, single channel, stereo and different bit rates. The wave player can show us all this data that describes the wave file. The report shows you how to use fixed-width formatting since the file names and data should fit in columns to make it easier to read. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import os import wave waveFolder = \"/sounds\" wavelist = [] # get a list of .wav files for i in os . listdir ( waveFolder ): if i . find ( \".wav\" ) >= 0 : wavelist . append ( waveFolder + \"/\" + i ) elif i . find ( \".WAV\" ) >= 0 : wavelist . append ( waveFolder + \"/\" + i ) if not wavelist : print ( \"Warning NO '.wav' files\" ) else : print ( \" {0:<45} \" . format ( 'File Path' ), 'Frame Rate Width Chans Frames' ) for filename in wavelist : f = wave . open ( filename , 'rb' ) # the format string \"{0:<50}\" says print left justified from chars 0 to 50 in a fixed with string print ( \" {0:<50} \" . format ( filename ), \" {0:>5} \" . format ( f . getframerate ()), \" {0:>5} \" . format ( f . getsampwidth ()), \" {0:>6} \" . format ( f . getnchannels ()), \" {0:>6} \" . format ( f . getnframes ()) ) Sample Response 1 2 3 4 5 6 7 File Path Frame Rate Width Chans Frames /sounds/cylon-attention.wav 8000 1 1 6399 /sounds/cylon-by-your-command.wav 11025 1 1 12583 /sounds/cylon-excellent.wav 22050 1 1 48736 /sounds/cylon-eye-scanner.wav 16000 2 2 24768 /sounds/cylon-see-that-the-humans.wav 11025 1 1 30743 /sounds/cylon-those-are-not-the-sounds.wav 22050 1 1 64137","title":"Checking the WAV File Format"},{"location":"sound/07-play-audio-file/#adding-an-interrupt","text":"If you halt the RP2040 while it is playing a sound, the independent PWM controllers will continue to generate sound. In order to shut the independent PWM controllers, an interrupt controller system must be used to cleanly disable all the sound. Here is an example of this using a try/except block of code. 1 2 3 4 5 6 7 8 9 10 11 import os as uos from wavePlayer import wavePlayer player = wavePlayer () try : while True : # repeat this over and over until the keyboard shuts down the circuit player . play ( '/sounds/cylon-eye-scanner.wav' ) except KeyboardInterrupt : player . stop () print ( \"wave player terminated\" )","title":"Adding an Interrupt"},{"location":"sound/07-play-audio-file/#playing-the-same-sound-repeatedly","text":"1 2 3 4 5 6 7 8 9 10 import os as uos from wavePlayer import wavePlayer player = wavePlayer () try : while True : player . play ( '/sounds/cylon-eye-scanner.wav' ) except KeyboardInterrupt : player . stop () print ( \"wave player terminated\" )","title":"Playing the Same Sound Repeatedly"},{"location":"sound/07-play-audio-file/#downloading-the-audio-libraries","text":"Both the wave.py and the chunck.py files are here: https://github.com/joeky888/awesome-micropython-lib/tree/master/Audio","title":"Downloading the Audio Libraries"},{"location":"sound/07-play-audio-file/#references","text":"Daniel Perron Wikipedia page for Wave File c Web-Based Audio Conversion Service Convertio Wikipedia page for Audio Interchange File Format Wikipedia page for Pulse-code Modulation Raspberry Pi Pico Forum on Sounds Files","title":"References"},{"location":"sound/07a-test-audio-ports/","text":"Testing Audio Ports In this lab, we will be testing stereo audio ports. We will be sending a 1 kilohertz square wave to the left and then right ports. This program allows you to test your stereo connections and make sure that both channels are working correctly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from machine import Pin , PWM from utime import sleep # You will need to configure these two digital output ports AUDIO_LEFT_PIN = 18 AUDIO_RIGHT_PIN = 19 # create a Pulse Width Modulation Object on this pin left_speaker = PWM ( Pin ( AUDIO_LEFT_PIN )) # set the duty cycle to be 50% left_speaker . duty_u16 ( 1000 ) left_speaker . freq ( 1000 ) # 50% on and off sleep ( 1 ) # wait a second left_speaker . duty_u16 ( 0 ) # turn off the PWM circuits off with a zero duty cycle left_speaker . duty_u16 ( 0 ) sleep ( 1 ) # create a Pulse Width Modulation Object on this pin right_speaker = PWM ( Pin ( AUDIO_RIGHT_PIN )) # set the duty cycle to be 50% right_speaker . duty_u16 ( 1000 ) right_speaker . freq ( 1000 ) # 50% on and off sleep ( 1 ) # wait a second right_speaker . duty_u16 ( 0 ) # turn off the PWM circuits off with a zero duty cycle right_speaker . duty_u16 ( 0 ) References https://en.wikipedia.org/wiki/Phone_connector_(audio)#Computer_sound","title":"Testing Audio Ports"},{"location":"sound/07a-test-audio-ports/#testing-audio-ports","text":"In this lab, we will be testing stereo audio ports. We will be sending a 1 kilohertz square wave to the left and then right ports. This program allows you to test your stereo connections and make sure that both channels are working correctly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from machine import Pin , PWM from utime import sleep # You will need to configure these two digital output ports AUDIO_LEFT_PIN = 18 AUDIO_RIGHT_PIN = 19 # create a Pulse Width Modulation Object on this pin left_speaker = PWM ( Pin ( AUDIO_LEFT_PIN )) # set the duty cycle to be 50% left_speaker . duty_u16 ( 1000 ) left_speaker . freq ( 1000 ) # 50% on and off sleep ( 1 ) # wait a second left_speaker . duty_u16 ( 0 ) # turn off the PWM circuits off with a zero duty cycle left_speaker . duty_u16 ( 0 ) sleep ( 1 ) # create a Pulse Width Modulation Object on this pin right_speaker = PWM ( Pin ( AUDIO_RIGHT_PIN )) # set the duty cycle to be 50% right_speaker . duty_u16 ( 1000 ) right_speaker . freq ( 1000 ) # 50% on and off sleep ( 1 ) # wait a second right_speaker . duty_u16 ( 0 ) # turn off the PWM circuits off with a zero duty cycle right_speaker . duty_u16 ( 0 )","title":"Testing Audio Ports"},{"location":"sound/07a-test-audio-ports/#references","text":"https://en.wikipedia.org/wiki/Phone_connector_(audio)#Computer_sound","title":"References"},{"location":"sound/08-i2s-standard/","text":"I2S Standard I2S (Inter-IC Sound) pronounced \"eye-two-ess\", is an electrical serial bus interface standard used for connecting digital audio devices together. It is a general interface to communicate PCM audio data between integrated circuits in an electronic device. Note that I2S is unrelated to the similar sounding I2C bus protocol. Since MicroPython 1.17 we have a library that allows us to play","title":"I2S Standard"},{"location":"sound/08-i2s-standard/#i2s-standard","text":"I2S (Inter-IC Sound) pronounced \"eye-two-ess\", is an electrical serial bus interface standard used for connecting digital audio devices together. It is a general interface to communicate PCM audio data between integrated circuits in an electronic device. Note that I2S is unrelated to the similar sounding I2C bus protocol. Since MicroPython 1.17 we have a library that allows us to play","title":"I2S Standard"},{"location":"sound/09-converting-mp3-to-wav/","text":"Converting MP3 to WAV formats In last lab we will learned how to play an audio file stored on the flash memory or SD card. We used an early version of a Python module that plays .WAV files in a fixed format: 8,000 samples per second using 16-bit encoding. Because there are hundreds of different formats of audio files, we need a consistent way to convert all of these formats to 8K samples/second 16-bit .WAV formats. The audio data file conversions are done on your host PC, not the microcontroller. This allows us to use a rich library of tools that don't need to run on our microcontroller. Method 1: Use the ffmpeg Command Line Tool One of the easiest ways to get started is to go to the web site ffmpeg.org and download the program that does the conversion using a command line. Note that on a Mac you will need to go into your System Preferences and indicate that the following programs are trusted: Here are the direct links for MacOS ffmpeg (mac) ffprobe (mac) ffplay (mac) This will download a zip file which you will need to unzip and place in a location such as ~/bin . After you do this make sure you add `~/bin to your path by adding the following file to your .bash_profile: PATH=$PATH:~/bin After you source your .bash_profile type in the following: which ffmpeg This should return the location that it finds the ffmpeg shell script. You can then see the many file-format MPEG options: ffmpeg --help Converting MP3 to 8K 16 bit WAV Files To get the format we need for the MicroPython wave player class we just specific -i for the input file and use the -ar 8000 to specify the output bit rate of 8K samples per second. The final parameter is a file name that must in .wav so the command knows to use WAV PCM encoding. The default value is 16 gits per sample. 1 ffmpeg -i r2d2-beeping.mp3 -ar 8000 r2d2-beeping-8k.wav Bulk Conversions We can use unix shell commands to do a batch conversion of all the . The following is an example of using awk and sed to convert all the .mp3 files in a directory and convert them to 8K Hz WAV files and put them in a sibling directory. 1 ls -1 *.mp3 | awk '{print \"ffmpeg -i \" $1 \" -ar 8000 ../wav-8k/\"$1}' | sed s/mp3$/wav/ | sh Inspect the Files Using the UNIX file command: 1 2 cd ../wav-8k file *.wav returns 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 r2d2-another-beep.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping-2.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping-4.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping-8k.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping-like-an-alarm.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-cheerful.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-determined.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-excited.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-laughing.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-more-chatter.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-processing.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-sad.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-shocked.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-surprised.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-taking-to-himself.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-unsure.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz Note that these are WAVE audio, Pulse-code Modulated (PCM), 16 bit and mono at 8K Hz. Method 2: Use the pydub Python Module Note This section is only for experienced Python developers. Install Conda and the Python libraries 1 2 3 conda create -n mp3-to-wav python = 3 conda activate mp3-to-wav pip install pydub ffprobe ffmpeg Check your versions: 1 pip freeze returns: 1 2 3 ffmpeg==1.4 ffprobe==0.5 pydub==0.25.1 Running pydub 1 2 3 4 from pydub import AudioSegment sound = AudioSegment . from_mp3 ( \"r2d2-beeping.mp3\" ) sound . export ( \"r2d2-beeping.wav\" , format = \"wav\" , tags = { 'Robot name' : 'R2D2' }) Transferring the Files with Rshell 1 2 3 cd ../wav-8k rshell -p /dev/cu.usbmodem14101 cp *.wav /pico/sounds References PyDub Documentation File Formats for Audio from MPEG File Formats for motion picture experts group Python Library","title":"Converting Audio Files"},{"location":"sound/09-converting-mp3-to-wav/#converting-mp3-to-wav-formats","text":"In last lab we will learned how to play an audio file stored on the flash memory or SD card. We used an early version of a Python module that plays .WAV files in a fixed format: 8,000 samples per second using 16-bit encoding. Because there are hundreds of different formats of audio files, we need a consistent way to convert all of these formats to 8K samples/second 16-bit .WAV formats. The audio data file conversions are done on your host PC, not the microcontroller. This allows us to use a rich library of tools that don't need to run on our microcontroller.","title":"Converting MP3 to WAV formats"},{"location":"sound/09-converting-mp3-to-wav/#method-1-use-the-ffmpeg-command-line-tool","text":"One of the easiest ways to get started is to go to the web site ffmpeg.org and download the program that does the conversion using a command line. Note that on a Mac you will need to go into your System Preferences and indicate that the following programs are trusted: Here are the direct links for MacOS ffmpeg (mac) ffprobe (mac) ffplay (mac) This will download a zip file which you will need to unzip and place in a location such as ~/bin . After you do this make sure you add `~/bin to your path by adding the following file to your .bash_profile: PATH=$PATH:~/bin After you source your .bash_profile type in the following: which ffmpeg This should return the location that it finds the ffmpeg shell script. You can then see the many file-format MPEG options: ffmpeg --help","title":"Method 1: Use the ffmpeg Command Line Tool"},{"location":"sound/09-converting-mp3-to-wav/#converting-mp3-to-8k-16-bit-wav-files","text":"To get the format we need for the MicroPython wave player class we just specific -i for the input file and use the -ar 8000 to specify the output bit rate of 8K samples per second. The final parameter is a file name that must in .wav so the command knows to use WAV PCM encoding. The default value is 16 gits per sample. 1 ffmpeg -i r2d2-beeping.mp3 -ar 8000 r2d2-beeping-8k.wav","title":"Converting MP3 to 8K 16 bit WAV Files"},{"location":"sound/09-converting-mp3-to-wav/#bulk-conversions","text":"We can use unix shell commands to do a batch conversion of all the . The following is an example of using awk and sed to convert all the .mp3 files in a directory and convert them to 8K Hz WAV files and put them in a sibling directory. 1 ls -1 *.mp3 | awk '{print \"ffmpeg -i \" $1 \" -ar 8000 ../wav-8k/\"$1}' | sed s/mp3$/wav/ | sh","title":"Bulk Conversions"},{"location":"sound/09-converting-mp3-to-wav/#inspect-the-files-using-the-unix-file-command","text":"1 2 cd ../wav-8k file *.wav returns 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 r2d2-another-beep.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping-2.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping-4.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping-8k.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping-like-an-alarm.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-beeping.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-cheerful.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-determined.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-excited.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-laughing.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-more-chatter.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-processing.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-sad.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-shocked.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-surprised.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-taking-to-himself.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz r2d2-unsure.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 8000 Hz Note that these are WAVE audio, Pulse-code Modulated (PCM), 16 bit and mono at 8K Hz.","title":"Inspect the Files Using the UNIX file command:"},{"location":"sound/09-converting-mp3-to-wav/#method-2-use-the-pydub-python-module","text":"Note This section is only for experienced Python developers.","title":"Method 2: Use the pydub Python Module"},{"location":"sound/09-converting-mp3-to-wav/#install-conda-and-the-python-libraries","text":"1 2 3 conda create -n mp3-to-wav python = 3 conda activate mp3-to-wav pip install pydub ffprobe ffmpeg Check your versions: 1 pip freeze returns: 1 2 3 ffmpeg==1.4 ffprobe==0.5 pydub==0.25.1","title":"Install Conda and the Python libraries"},{"location":"sound/09-converting-mp3-to-wav/#running-pydub","text":"1 2 3 4 from pydub import AudioSegment sound = AudioSegment . from_mp3 ( \"r2d2-beeping.mp3\" ) sound . export ( \"r2d2-beeping.wav\" , format = \"wav\" , tags = { 'Robot name' : 'R2D2' })","title":"Running pydub"},{"location":"sound/09-converting-mp3-to-wav/#transferring-the-files-with-rshell","text":"1 2 3 cd ../wav-8k rshell -p /dev/cu.usbmodem14101 cp *.wav /pico/sounds","title":"Transferring the Files with Rshell"},{"location":"sound/09-converting-mp3-to-wav/#references","text":"PyDub Documentation File Formats for Audio from MPEG File Formats for motion picture experts group Python Library","title":"References"},{"location":"sound/10-midi/","text":"MIDI with MicroPython References DIY Electronic Music: MIDI, MicroPython and the Raspberry Pi Pico SparkFun MIDI Tutorial","title":"MIDI with MicroPython"},{"location":"sound/10-midi/#midi-with-micropython","text":"","title":"MIDI with MicroPython"},{"location":"sound/10-midi/#references","text":"DIY Electronic Music: MIDI, MicroPython and the Raspberry Pi Pico SparkFun MIDI Tutorial","title":"References"}]}