{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoderDojo Twin Cities Micropython This GitHub repository is for sharing teaching resources to teach Micropython to students in 5th to 12th grades (10-18 years old). The course assumes that either a mentor, teacher or students have access to at least one microcontroller such as the $4 Raspberry Pi Pico or the $10 ESP32. Students should also have access to some low-cost sensors (buttons, potentiometers, ultrasonic distance sensor) and displays such as LEDs or OLED. Course Outline Part 1: Getting Started Part 2: Introduction to MicroPython Introduction - Overview of Micropython and why we love it. Boards - Description of popular development boards that support Micropython (Pico and ESP32). How to choose the right microcontroller for your project. Raspberry Pi Pico - Details the Raspberry Pi Pico including features and pinouts. Thonny IDE - Thonny is an IDE that supports Micropython. We review the parts of the User interface. Blink - Blink an LED on and off. This is the equivalent of the \"Hello World!\" program in micropython. Button - see how a button can control the LED. Servo - Move a Servo. Part 3: Sensors Sensors Intro Displays Displays We cover simple displays that don't have complex drawing. For those we have a separate chapter. Part 4: Sound and Music Sound and Music Infro Part 5: OLED Displays OLED Displays Part 6: Robots Robots Part 7: Advanced Topics Advanced Topics Reference Material Glossary of Micropython Terms Contact Micropython References - links to other useful sites.","title":"Micropython Home"},{"location":"#coderdojo-twin-cities-micropython","text":"This GitHub repository is for sharing teaching resources to teach Micropython to students in 5th to 12th grades (10-18 years old). The course assumes that either a mentor, teacher or students have access to at least one microcontroller such as the $4 Raspberry Pi Pico or the $10 ESP32. Students should also have access to some low-cost sensors (buttons, potentiometers, ultrasonic distance sensor) and displays such as LEDs or OLED.","title":"CoderDojo Twin Cities Micropython"},{"location":"#course-outline","text":"","title":"Course Outline"},{"location":"#part-1-getting-started","text":"","title":"Part 1: Getting Started"},{"location":"#part-2-introduction-to-micropython","text":"Introduction - Overview of Micropython and why we love it. Boards - Description of popular development boards that support Micropython (Pico and ESP32). How to choose the right microcontroller for your project. Raspberry Pi Pico - Details the Raspberry Pi Pico including features and pinouts. Thonny IDE - Thonny is an IDE that supports Micropython. We review the parts of the User interface. Blink - Blink an LED on and off. This is the equivalent of the \"Hello World!\" program in micropython. Button - see how a button can control the LED. Servo - Move a Servo.","title":"Part 2: Introduction to MicroPython"},{"location":"#part-3-sensors","text":"Sensors Intro","title":"Part 3: Sensors"},{"location":"#displays","text":"Displays We cover simple displays that don't have complex drawing. For those we have a separate chapter.","title":"Displays"},{"location":"#part-4-sound-and-music","text":"Sound and Music Infro","title":"Part 4: Sound and Music"},{"location":"#part-5-oled-displays","text":"OLED Displays","title":"Part 5: OLED Displays"},{"location":"#part-6-robots","text":"Robots","title":"Part 6: Robots"},{"location":"#part-7-advanced-topics","text":"Advanced Topics","title":"Part 7: Advanced Topics"},{"location":"#reference-material","text":"Glossary of Micropython Terms Contact Micropython References - links to other useful sites.","title":"Reference Material"},{"location":"advanced-labs/01-intro/","text":"Advanced MicroPython Labs These labs are for advanced students that have already mastered the basic of MicroPython programming and want to explore advanced topics. Advanced Topics Include: Multicore Progamming - how to get programs running on multiple cores. Programmable I/O - The Raspberry Pi includes Programmable I/O devices that allow input and output operations without interrupting the main cores. The Pico has two PIO blocks that each have four state machines. Each of these machines can be working independently of the main core processors. Muitithreaded Code Example PIO Programming Hackspace PIO Programming Article","title":"Introduction"},{"location":"advanced-labs/01-intro/#advanced-micropython-labs","text":"These labs are for advanced students that have already mastered the basic of MicroPython programming and want to explore advanced topics. Advanced Topics Include: Multicore Progamming - how to get programs running on multiple cores. Programmable I/O - The Raspberry Pi includes Programmable I/O devices that allow input and output operations without interrupting the main cores. The Pico has two PIO blocks that each have four state machines. Each of these machines can be working independently of the main core processors. Muitithreaded Code Example PIO Programming Hackspace PIO Programming Article","title":"Advanced MicroPython Labs"},{"location":"circuit-python/01-intro/","text":"Introduction to CircuitPython CircuitPython is a fork of MicroPython done by Adafruit According to Google Trends , MicroPython is more popular than CircuitPython when we look at worldwide web search comparison Done for \"simplicity\" but does not support multiple cores CircuitPython has lots of drivers The code is generally incompatible with MicroPython although you can often manually convert one program into another It might be useful for testing devices where the MicroPython drivers do not work Setting up a CircuitPython Virtual Environment Because MicroPython and CircuitPython are incompatible, it is important that you don't intermix your python libraries. Here is how we setup a virtual environment for CircuitPython using Conda . 1 2 conda create -n circuitpython python = 3 conda activate circuitpython Installing the SSD1306 CircuitPython Library Per Directions Here 1 pip3 install adafruit-circuitpython-ssd1306 1 pip3 install adafruit-circuitpython-displayio-ssd1306 Note ERROR: Could not find a version that satisfies the requirement adafruit-circuitpython-displayio-ssd1306 ERROR: No matching distribution found for adafruit-circuitpython-displayio-ssd1306 1 Successfully installed Adafruit-Blinka-6.3.2 Adafruit-PlatformDetect-3.2.0 Adafruit-PureIO-1.1.8 adafruit-circuitpython-busdevice-5.0.6 adafruit-circuitpython-framebuf-1.4.6 adafruit-circuitpython-ssd1306-2.11.1 pyftdi-0.52.9 pyserial-3.5 pyusb-1.1.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Basic example of clearing and drawing pixels on a SSD1306 OLED display. # This example and library is meant to work with Adafruit CircuitPython API. # Author: Tony DiCola # License: Public Domain # Import all board pins. from board import SCL , SDA import busio # Import the SSD1306 module. import adafruit_ssd1306 # Create the I2C interface. i2c = busio . I2C ( SCL , SDA ) # Create the SSD1306 OLED class. # The first two parameters are the pixel width and pixel height. Change these # to the right size for your display! display = adafruit_ssd1306 . SSD1306_I2C ( 128 , 32 , i2c ) # Alternatively you can change the I2C address of the device with an addr parameter: #display = adafruit_ssd1306.SSD1306_I2C(128, 32, i2c, addr=0x31) # Clear the display. Always call show after changing pixels to make the display # update visible! display . fill ( 0 ) display . show () # Set a pixel in the origin 0,0 position. display . pixel ( 0 , 0 , 1 ) # Set a pixel in the middle 64, 16 position. display . pixel ( 64 , 16 , 1 ) # Set a pixel in the opposite 127, 31 position. display . pixel ( 127 , 31 , 1 ) display . show () Trend analysis As of March 2021, MicroPython is about two to four times more popular than CircuitPython. Google Worldwide Search Trends","title":"Circuit Python"},{"location":"circuit-python/01-intro/#introduction-to-circuitpython","text":"CircuitPython is a fork of MicroPython done by Adafruit According to Google Trends , MicroPython is more popular than CircuitPython when we look at worldwide web search comparison Done for \"simplicity\" but does not support multiple cores CircuitPython has lots of drivers The code is generally incompatible with MicroPython although you can often manually convert one program into another It might be useful for testing devices where the MicroPython drivers do not work","title":"Introduction to CircuitPython"},{"location":"circuit-python/01-intro/#setting-up-a-circuitpython-virtual-environment","text":"Because MicroPython and CircuitPython are incompatible, it is important that you don't intermix your python libraries. Here is how we setup a virtual environment for CircuitPython using Conda . 1 2 conda create -n circuitpython python = 3 conda activate circuitpython","title":"Setting up a CircuitPython Virtual Environment"},{"location":"circuit-python/01-intro/#installing-the-ssd1306-circuitpython-library","text":"Per Directions Here 1 pip3 install adafruit-circuitpython-ssd1306 1 pip3 install adafruit-circuitpython-displayio-ssd1306 Note ERROR: Could not find a version that satisfies the requirement adafruit-circuitpython-displayio-ssd1306 ERROR: No matching distribution found for adafruit-circuitpython-displayio-ssd1306 1 Successfully installed Adafruit-Blinka-6.3.2 Adafruit-PlatformDetect-3.2.0 Adafruit-PureIO-1.1.8 adafruit-circuitpython-busdevice-5.0.6 adafruit-circuitpython-framebuf-1.4.6 adafruit-circuitpython-ssd1306-2.11.1 pyftdi-0.52.9 pyserial-3.5 pyusb-1.1.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Basic example of clearing and drawing pixels on a SSD1306 OLED display. # This example and library is meant to work with Adafruit CircuitPython API. # Author: Tony DiCola # License: Public Domain # Import all board pins. from board import SCL , SDA import busio # Import the SSD1306 module. import adafruit_ssd1306 # Create the I2C interface. i2c = busio . I2C ( SCL , SDA ) # Create the SSD1306 OLED class. # The first two parameters are the pixel width and pixel height. Change these # to the right size for your display! display = adafruit_ssd1306 . SSD1306_I2C ( 128 , 32 , i2c ) # Alternatively you can change the I2C address of the device with an addr parameter: #display = adafruit_ssd1306.SSD1306_I2C(128, 32, i2c, addr=0x31) # Clear the display. Always call show after changing pixels to make the display # update visible! display . fill ( 0 ) display . show () # Set a pixel in the origin 0,0 position. display . pixel ( 0 , 0 , 1 ) # Set a pixel in the middle 64, 16 position. display . pixel ( 64 , 16 , 1 ) # Set a pixel in the opposite 127, 31 position. display . pixel ( 127 , 31 , 1 ) display . show ()","title":"Installing the SSD1306 CircuitPython Library"},{"location":"circuit-python/01-intro/#trend-analysis","text":"As of March 2021, MicroPython is about two to four times more popular than CircuitPython. Google Worldwide Search Trends","title":"Trend analysis"},{"location":"debugging/27-ampy/","text":"","title":"Ampy"},{"location":"debugging/28-debugging-python/","text":"How to Debug Micropython Listing the Modules 1 help ( 'modules' ) Result: 1 2 3 4 5 6 7 8 9 10 __main__ gc uasyncio/funcs uos _boot machine uasyncio/lock urandom _onewire math uasyncio/stream ure _rp2 micropython ubinascii uselect _thread onewire ucollections ustruct _uasyncio rp2 uctypes usys builtins uasyncio/__init__ uhashlib utime ds18x20 uasyncio/core uio uzlib framebuf uasyncio/event ujson Plus any modules on the filesystem Micropython issues https://github.com/micropython/micropython/issues","title":"Debugging Python"},{"location":"debugging/28-debugging-python/#how-to-debug-micropython","text":"","title":"How to Debug Micropython"},{"location":"debugging/28-debugging-python/#listing-the-modules","text":"1 help ( 'modules' ) Result: 1 2 3 4 5 6 7 8 9 10 __main__ gc uasyncio/funcs uos _boot machine uasyncio/lock urandom _onewire math uasyncio/stream ure _rp2 micropython ubinascii uselect _thread onewire ucollections ustruct _uasyncio rp2 uctypes usys builtins uasyncio/__init__ uhashlib utime ds18x20 uasyncio/core uio uzlib framebuf uasyncio/event ujson Plus any modules on the filesystem","title":"Listing the Modules"},{"location":"debugging/28-debugging-python/#micropython-issues","text":"https://github.com/micropython/micropython/issues","title":"Micropython issues"},{"location":"debugging/29-debugging-spi/","text":"Debugging SPI In this lab we use a logic analyzer to debug the SPI protocol being used to drive a sample OLED device. We will be using the the 8 port Saleae Logic Analyser . The retail cost is about $399.00 although there are lower cost logic analyzer available. The SSD1306 SPI OLED Timing Diagram The OLED display is a read-only interface. It does not send any data back to the microcontroller, so there is no MOSI connection. The data is transmitted on the SDK line when the SCL line goes high. The CS line must be low for the OLED to be active. For details, see section 8.1.3 MCU Serial Interface on page 21 of the SSD1305 132 x 64 Dot Matrix OLED/PLED Segment/Common Driver with Controller . OLED SPI settings Our OLED device has seven wires. In addition to power and ground there a five data connections we will be observing on our logic analyzer. CS - Chip Select pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 (Data from the ) SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin Setting up a Logic Analyzer Setup SPI Analyser Configure SPI Channel Settings Saleae Logic Analyser SPI Logic Analyser Settings Check a Working Device The first thing we want to see is what the signals to a working SPI OLED should be. There are plenty of working drivers for the Arduino, so I hooked one up to the Logic analizer to see what they were. Viewing Data Clock and RES All five signals DC and CS signals have a larger period. DC on was 3.668 milliseconds Clock Period Our Clock (SCL) has 8 positive pulses with a width of .4167 microseconds. This means that the positve/negative combined width has a period of 2 * .4167 = .8333 microseconds. This can be converted into a frequency of 1.2 megahertz. References Video on how to use the Saleae Logic Analyzer https://www.youtube.com/watch?v=Ak9R4yxQPhs","title":"Debugging SPI"},{"location":"debugging/29-debugging-spi/#debugging-spi","text":"In this lab we use a logic analyzer to debug the SPI protocol being used to drive a sample OLED device. We will be using the the 8 port Saleae Logic Analyser . The retail cost is about $399.00 although there are lower cost logic analyzer available.","title":"Debugging SPI"},{"location":"debugging/29-debugging-spi/#the-ssd1306-spi-oled-timing-diagram","text":"The OLED display is a read-only interface. It does not send any data back to the microcontroller, so there is no MOSI connection. The data is transmitted on the SDK line when the SCL line goes high. The CS line must be low for the OLED to be active. For details, see section 8.1.3 MCU Serial Interface on page 21 of the SSD1305 132 x 64 Dot Matrix OLED/PLED Segment/Common Driver with Controller .","title":"The SSD1306 SPI OLED Timing Diagram"},{"location":"debugging/29-debugging-spi/#oled-spi-settings","text":"Our OLED device has seven wires. In addition to power and ground there a five data connections we will be observing on our logic analyzer. CS - Chip Select pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 (Data from the ) SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin","title":"OLED SPI settings"},{"location":"debugging/29-debugging-spi/#setting-up-a-logic-analyzer","text":"","title":"Setting up a Logic Analyzer"},{"location":"debugging/29-debugging-spi/#setup-spi-analyser","text":"","title":"Setup SPI Analyser"},{"location":"debugging/29-debugging-spi/#configure-spi-channel-settings","text":"Saleae Logic Analyser SPI Logic Analyser Settings","title":"Configure SPI Channel Settings"},{"location":"debugging/29-debugging-spi/#check-a-working-device","text":"The first thing we want to see is what the signals to a working SPI OLED should be. There are plenty of working drivers for the Arduino, so I hooked one up to the Logic analizer to see what they were.","title":"Check a Working Device"},{"location":"debugging/29-debugging-spi/#viewing-data-clock-and-res","text":"All five signals DC and CS signals have a larger period. DC on was 3.668 milliseconds","title":"Viewing Data Clock and RES"},{"location":"debugging/29-debugging-spi/#clock-period","text":"Our Clock (SCL) has 8 positive pulses with a width of .4167 microseconds. This means that the positve/negative combined width has a period of 2 * .4167 = .8333 microseconds. This can be converted into a frequency of 1.2 megahertz.","title":"Clock Period"},{"location":"debugging/29-debugging-spi/#references","text":"Video on how to use the Saleae Logic Analyzer https://www.youtube.com/watch?v=Ak9R4yxQPhs","title":"References"},{"location":"debugging/29a-debugging-i2c/","text":"Debugging I2C Bus","title":"Debugging I2C"},{"location":"debugging/29a-debugging-i2c/#debugging-i2c-bus","text":"","title":"Debugging I2C Bus"},{"location":"displays/01-intro/","text":"Displays We cover small displays but not OLEDs. There is a separate chapter for OLED displays.","title":"Introduction"},{"location":"displays/01-intro/#displays","text":"We cover small displays but not OLEDs. There is a separate chapter for OLED displays.","title":"Displays"},{"location":"displays/10-character-lcd-display/","text":"Character LCD Display Address Scanner Scanner Code 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( i2c . scan ()) Scanner Result 1 2 3 >>> %Run -c $EDITOR_CONTENT [ 39 ] >>> Hello To The LCD 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) i2c . writeto ( 114 , ' \\x7C ' ) i2c . writeto ( 114 , ' \\x2D ' ) i2c . writeto ( 114 , \"hello world\" ) 1602 LCD MicroPython Forum on 1602 LCDs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import i2clcd lcd = i2clcd . i2clcd ( i2c_bus = 1 , i2c_addr = 0x27 , lcd_width = 16 ) lcd . init () # fill a line by the text lcd . print_line ( 'hello' , line = 0 ) lcd . print_line ( 'world!' , line = 1 , align = 'RIGHT' ) # print text at the current cursor position lcd . move_cursor ( 1 , 0 ) lcd . print ( 'the' ) # custom character char_celsius = ( 0x10 , 0x06 , 0x09 , 0x08 , 0x08 , 0x09 , 0x06 , 0x00 ) lcd . write_CGRAM ( char_celsius , 0 ) lcd . move_cursor ( 0 , 6 ) lcd . print ( b 'CGRAM: ' + i2clcd . CGRAM_CHR [ 0 ]) ssd1306 module SSD1306 Library - click the RAW button and then right click to do a \"Save As\" HD44780 Drivers Dave Hylands HD44780 Drivers in Python References MFitzp article on OLED displays Adafruit SSD1306 Driver Adafruit LCD Guide","title":"Character LCD Displays"},{"location":"displays/10-character-lcd-display/#character-lcd-display","text":"","title":"Character LCD Display"},{"location":"displays/10-character-lcd-display/#address-scanner","text":"","title":"Address Scanner"},{"location":"displays/10-character-lcd-display/#scanner-code","text":"1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( i2c . scan ())","title":"Scanner Code"},{"location":"displays/10-character-lcd-display/#scanner-result","text":"1 2 3 >>> %Run -c $EDITOR_CONTENT [ 39 ] >>>","title":"Scanner Result"},{"location":"displays/10-character-lcd-display/#hello-to-the-lcd","text":"1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) i2c . writeto ( 114 , ' \\x7C ' ) i2c . writeto ( 114 , ' \\x2D ' ) i2c . writeto ( 114 , \"hello world\" )","title":"Hello To The LCD"},{"location":"displays/10-character-lcd-display/#1602-lcd","text":"MicroPython Forum on 1602 LCDs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import i2clcd lcd = i2clcd . i2clcd ( i2c_bus = 1 , i2c_addr = 0x27 , lcd_width = 16 ) lcd . init () # fill a line by the text lcd . print_line ( 'hello' , line = 0 ) lcd . print_line ( 'world!' , line = 1 , align = 'RIGHT' ) # print text at the current cursor position lcd . move_cursor ( 1 , 0 ) lcd . print ( 'the' ) # custom character char_celsius = ( 0x10 , 0x06 , 0x09 , 0x08 , 0x08 , 0x09 , 0x06 , 0x00 ) lcd . write_CGRAM ( char_celsius , 0 ) lcd . move_cursor ( 0 , 6 ) lcd . print ( b 'CGRAM: ' + i2clcd . CGRAM_CHR [ 0 ])","title":"1602 LCD"},{"location":"displays/10-character-lcd-display/#ssd1306-module","text":"SSD1306 Library - click the RAW button and then right click to do a \"Save As\"","title":"ssd1306 module"},{"location":"displays/10-character-lcd-display/#hd44780-drivers","text":"Dave Hylands HD44780 Drivers in Python","title":"HD44780 Drivers"},{"location":"displays/10-character-lcd-display/#references","text":"MFitzp article on OLED displays Adafruit SSD1306 Driver Adafruit LCD Guide","title":"References"},{"location":"displays/seven-segment/","text":"Sample Seven Segment Display Lab 4 Digit Seven Segment Display Make sure to put a current limiting resistor in series with each LED. A 330 ohm resistor is a generally safe value for 5 volt circuits and you can use a 220 ohm resistor for 3.3 volt circuits. This code was provided by Jaison Miller from his GitHub Repo . ```py from machine import Pin, PWM, Timer import utime Constants - where the pins are currently plugged into, etc. number_bitmaps = { 0: 0b00111111, 1: 0b00000110, 2: 0b01011011, 3: 0b01001111, 4: 0b01100110, 5: 0b01101101, 6: 0b01111101, 7: 0b00000111, 8: 0b01111111, 9: 0b01100111 } segment_masks = { 'a': 0b00000001, 'b': 0b00000010, 'c': 0b00000100, 'd': 0b00001000, 'e': 0b00010000, 'f': 0b00100000, 'g': 0b01000000 } pin_segments = { 'a': 10, 'b': 11, 'c': 12, 'd': 17, 'e': 16, 'f': 13, 'g': 14} pin_others = { 'decimal': 22, 'colon': 6, 'dash': 8 } pin_digits = { 1: 18, 2: 19, 3: 20, 4: 21 } pin_control_others = { 'colon': 27, 'dash': 7 } initial setup of the pins, alternatives include using PWM to set the brightness if not using PWM then make sure to use appropriate resistors to avoid blowing the LEDs in the display (like I have) segment_maps = {} for segment, pin in pin_segments.items(): segment_maps[segment] = Pin(pin, Pin.OUT) other_pin_maps = {} for feature, pin in pin_others.items(): other_pin_maps[feature] = Pin(pin, Pin.OUT) digit_maps = {} for digit, pin in pin_digits.items(): digit_maps[digit] = Pin(pin, Pin.OUT) other_maps = {} for feature, pin in pin_control_others.items(): other_maps[feature] = Pin(pin, Pin.OUT) def render_digit_display(show_digit=1, number=8, decimal=False): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # turn everything off for segment, mask in segment_masks.items(): segment_maps[segment].value(1) other_pin_maps['decimal'].value(1) # turn on the digit required to be displayed for digit, digit_pin in digit_maps.items(): if show_digit == digit: digit_pin.value(1) # print(\"\\n\\nDigit: {} - Pin: {} - Number: {}\\n\".format(digit, pin, number)) else: digit_pin.value(0) utime.sleep(0.001) display_number_bitmap = number_bitmaps[number] # check every for segment, mask in segment_masks.items(): # print(\"segment: {}\\nmask: {}\".format(segment, mask)) if display_number_bitmap & mask == mask: # print(\"segment OFF: {}\".format(segment)) segment_maps[segment].value(0) else: segment_maps[segment].value(1) # show decimal if decimal: other_pin_maps['decimal'].value(0) else: other_pin_maps['decimal'].value(1) utime.sleep(0.001) def render_feature_display(show_colon=False, show_dash=False): if show_colon: other_pin_maps['colon'].value(0) other_maps['colon'].value(1) else: other_pin_maps['colon'].value(0) other_maps['colon'].value(0) 1 2 3 4 5 6 if show_dash: other_pin_maps['dash'].value(0) other_maps['dash'].value(1) else: other_pin_maps['dash'].value(0) other_maps['dash'].value(0) while True: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lt_year, lt_month, lt_mday, lt_hour, lt_minute, lt_second, lt_weekday, lt_yearday = utime.localtime() # testing out all the features of the display digit_1_decimal = (lt_second % 4 == 0) digit_2_decimal = (lt_second % 4 == 1) digit_3_decimal = (lt_second % 4 == 2) digit_4_decimal = (lt_second % 4 == 3) render_digit_display(1, lt_minute // 10, digit_1_decimal) render_digit_display(2, lt_minute % 10, digit_2_decimal) render_digit_display(3, lt_second // 10, digit_3_decimal) render_digit_display(4, lt_second % 10, digit_4_decimal) if (lt_second % 2 == 0): render_feature_display(True, False) else: render_feature_display(False, True) ```","title":"7 Segment Display"},{"location":"displays/seven-segment/#sample-seven-segment-display-lab","text":"","title":"Sample Seven Segment Display Lab"},{"location":"displays/seven-segment/#4-digit-seven-segment-display","text":"Make sure to put a current limiting resistor in series with each LED. A 330 ohm resistor is a generally safe value for 5 volt circuits and you can use a 220 ohm resistor for 3.3 volt circuits. This code was provided by Jaison Miller from his GitHub Repo . ```py from machine import Pin, PWM, Timer import utime","title":"4 Digit Seven Segment Display"},{"location":"displays/seven-segment/#constants-where-the-pins-are-currently-plugged-into-etc","text":"number_bitmaps = { 0: 0b00111111, 1: 0b00000110, 2: 0b01011011, 3: 0b01001111, 4: 0b01100110, 5: 0b01101101, 6: 0b01111101, 7: 0b00000111, 8: 0b01111111, 9: 0b01100111 } segment_masks = { 'a': 0b00000001, 'b': 0b00000010, 'c': 0b00000100, 'd': 0b00001000, 'e': 0b00010000, 'f': 0b00100000, 'g': 0b01000000 } pin_segments = { 'a': 10, 'b': 11, 'c': 12, 'd': 17, 'e': 16, 'f': 13, 'g': 14} pin_others = { 'decimal': 22, 'colon': 6, 'dash': 8 } pin_digits = { 1: 18, 2: 19, 3: 20, 4: 21 } pin_control_others = { 'colon': 27, 'dash': 7 }","title":"Constants - where the pins are currently plugged into, etc."},{"location":"displays/seven-segment/#initial-setup-of-the-pins-alternatives-include-using-pwm-to-set-the-brightness","text":"","title":"initial setup of the pins, alternatives include using PWM to set the brightness"},{"location":"displays/seven-segment/#if-not-using-pwm-then-make-sure-to-use-appropriate-resistors-to-avoid-blowing-the-leds-in-the-display-like-i-have","text":"segment_maps = {} for segment, pin in pin_segments.items(): segment_maps[segment] = Pin(pin, Pin.OUT) other_pin_maps = {} for feature, pin in pin_others.items(): other_pin_maps[feature] = Pin(pin, Pin.OUT) digit_maps = {} for digit, pin in pin_digits.items(): digit_maps[digit] = Pin(pin, Pin.OUT) other_maps = {} for feature, pin in pin_control_others.items(): other_maps[feature] = Pin(pin, Pin.OUT) def render_digit_display(show_digit=1, number=8, decimal=False): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # turn everything off for segment, mask in segment_masks.items(): segment_maps[segment].value(1) other_pin_maps['decimal'].value(1) # turn on the digit required to be displayed for digit, digit_pin in digit_maps.items(): if show_digit == digit: digit_pin.value(1) # print(\"\\n\\nDigit: {} - Pin: {} - Number: {}\\n\".format(digit, pin, number)) else: digit_pin.value(0) utime.sleep(0.001) display_number_bitmap = number_bitmaps[number] # check every for segment, mask in segment_masks.items(): # print(\"segment: {}\\nmask: {}\".format(segment, mask)) if display_number_bitmap & mask == mask: # print(\"segment OFF: {}\".format(segment)) segment_maps[segment].value(0) else: segment_maps[segment].value(1) # show decimal if decimal: other_pin_maps['decimal'].value(0) else: other_pin_maps['decimal'].value(1) utime.sleep(0.001) def render_feature_display(show_colon=False, show_dash=False): if show_colon: other_pin_maps['colon'].value(0) other_maps['colon'].value(1) else: other_pin_maps['colon'].value(0) other_maps['colon'].value(0) 1 2 3 4 5 6 if show_dash: other_pin_maps['dash'].value(0) other_maps['dash'].value(1) else: other_pin_maps['dash'].value(0) other_maps['dash'].value(0) while True: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lt_year, lt_month, lt_mday, lt_hour, lt_minute, lt_second, lt_weekday, lt_yearday = utime.localtime() # testing out all the features of the display digit_1_decimal = (lt_second % 4 == 0) digit_2_decimal = (lt_second % 4 == 1) digit_3_decimal = (lt_second % 4 == 2) digit_4_decimal = (lt_second % 4 == 3) render_digit_display(1, lt_minute // 10, digit_1_decimal) render_digit_display(2, lt_minute % 10, digit_2_decimal) render_digit_display(3, lt_second // 10, digit_3_decimal) render_digit_display(4, lt_second % 10, digit_4_decimal) if (lt_second % 2 == 0): render_feature_display(True, False) else: render_feature_display(False, True) ```","title":"if not using PWM then make sure to use appropriate resistors to avoid blowing the LEDs in the display (like I have)"},{"location":"getting-started/01-intro/","text":"Welcome to the CoderDojo course on MicroPython This course is about MicroPython , a variation of the popular Python programming language that is used to program microcontrollers . Intended Audience Junior High or High School Students Age 10-16 Preferred Skills Familiarity with basic text editing functions such as select, copy and paste Understand how to save files to disk Basic understanding of Python programming language ( We strongly suggest you take the Introduction to Python Programming CoderDojo Course if you are not familiar with Python. ) User should be familiar with the the following Python concepts: imports libraries variables loops conditionals lists functions function parameters Course Outline What is a Microcontroller? What is Micropython? Raspberry Pi Pico Getting Started: Setting up MicroPython environment using Thonny or VS Code Introduction to MicroPython - Getting Started Sensors: getting information about the world around us Displays: showing information to users Sound and Music: playing tones, sounds and music OLED Displays: drawing on displays Robots: making robots move around with motors Advanced Topics License of Content Our intent is to allow teachers and mentors around the world to integrate MicroPython into their courses without any fees. We want you to be able to use this content freely with a few conditions: please give us attribution and please don't resell our content for profit. Note that we use the same Creative Commons licensing as the Raspberry Pi Foundation and the CoderDojo Foundation: Creative Commons Attribution NonCommercial ShareAlike This means you are free to reuse and remix this content for non-commercial educational purposes as long as you keep the attribution and preserve the license agreement.","title":"Introduction"},{"location":"getting-started/01-intro/#welcome-to-the-coderdojo-course-on-micropython","text":"This course is about MicroPython , a variation of the popular Python programming language that is used to program microcontrollers .","title":"Welcome to the CoderDojo course on MicroPython"},{"location":"getting-started/01-intro/#intended-audience","text":"Junior High or High School Students Age 10-16","title":"Intended Audience"},{"location":"getting-started/01-intro/#preferred-skills","text":"Familiarity with basic text editing functions such as select, copy and paste Understand how to save files to disk Basic understanding of Python programming language ( We strongly suggest you take the Introduction to Python Programming CoderDojo Course if you are not familiar with Python. ) User should be familiar with the the following Python concepts: imports libraries variables loops conditionals lists functions function parameters","title":"Preferred Skills"},{"location":"getting-started/01-intro/#course-outline","text":"What is a Microcontroller? What is Micropython? Raspberry Pi Pico Getting Started: Setting up MicroPython environment using Thonny or VS Code Introduction to MicroPython - Getting Started Sensors: getting information about the world around us Displays: showing information to users Sound and Music: playing tones, sounds and music OLED Displays: drawing on displays Robots: making robots move around with motors Advanced Topics","title":"Course Outline"},{"location":"getting-started/01-intro/#license-of-content","text":"Our intent is to allow teachers and mentors around the world to integrate MicroPython into their courses without any fees. We want you to be able to use this content freely with a few conditions: please give us attribution and please don't resell our content for profit. Note that we use the same Creative Commons licensing as the Raspberry Pi Foundation and the CoderDojo Foundation: Creative Commons Attribution NonCommercial ShareAlike This means you are free to reuse and remix this content for non-commercial educational purposes as long as you keep the attribution and preserve the license agreement.","title":"License of Content"},{"location":"getting-started/01a-microcontrollers/","text":"Microcontrollers This lesson is an overview of microcontrollers and their role in teaching physical computing . A microcontroller is a small low-cost computer used to control physical devices such as LED, servos and motors. Microcontroller boards typically cost around $4 to $6 and are an ideal way to learn about computer science because you can use them to build fun projects. For example you can control a row of LEDs, move a robot and sense the world around us with a variety of light, sound and motion sensors. In the past, microcontrollers were difficult for younger students to program. They were also too expensive for every student to purchase and take home. A typical Arduino kit could easily cost over $20 and required you to learn C to program it. Today, microcontrollers such as the Raspberry Pi Pico and the ESP32 cost as little as two dollars. And these devices are designed to be programmed in Python, the most popular programming language for students. What is Physical Computing? Physical Computing is a field of study that can sense and respond to the world around us. Unlike programming a cell phone or a laptop computer, our focus is reading sensor values and quickly responding to changes. Physical Computing is widely used to teach principals of computer science because students can create their own projects and express creativity such a controlling the patterns of lights or creating complex sounds. How Microcontrollers are Used Microcontrollers do three things: They read sensor values of the world around them They transform this data into useful representations They send outputs to devices that control the world such as LEDs and motors as well as displays Here is a general diagram to think about when you are designing microcontroller systems: Here is a specific example instance of what inputs and outputs might do. Programming a Microcontroller In this class, we will use the MicroPython to program our Microcontroller. Our programs will usually have the following structure: Imports : Specify the Python libraries used in the code ( More Information on Python libraries are available here ) Setup : Setup/ Initialize variables and sensors Main loop : Continuously monitor sensor inputs and take actions The following is an example code in Micropython: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Import Section import machine import time # Setup Section led = machine . Pin ( 16 , machine . Pin . OUT ) # Main Loop while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) Almost all our programs will start with the import machine line. This tells the system that we need to gather all the libraries that understand our physical machine. If you couldn't understand the example program - don't worry! We will be going through it in detail as we work on our labs.","title":"Microcontrollers"},{"location":"getting-started/01a-microcontrollers/#microcontrollers","text":"This lesson is an overview of microcontrollers and their role in teaching physical computing . A microcontroller is a small low-cost computer used to control physical devices such as LED, servos and motors. Microcontroller boards typically cost around $4 to $6 and are an ideal way to learn about computer science because you can use them to build fun projects. For example you can control a row of LEDs, move a robot and sense the world around us with a variety of light, sound and motion sensors. In the past, microcontrollers were difficult for younger students to program. They were also too expensive for every student to purchase and take home. A typical Arduino kit could easily cost over $20 and required you to learn C to program it. Today, microcontrollers such as the Raspberry Pi Pico and the ESP32 cost as little as two dollars. And these devices are designed to be programmed in Python, the most popular programming language for students.","title":"Microcontrollers"},{"location":"getting-started/01a-microcontrollers/#what-is-physical-computing","text":"Physical Computing is a field of study that can sense and respond to the world around us. Unlike programming a cell phone or a laptop computer, our focus is reading sensor values and quickly responding to changes. Physical Computing is widely used to teach principals of computer science because students can create their own projects and express creativity such a controlling the patterns of lights or creating complex sounds.","title":"What is Physical Computing?"},{"location":"getting-started/01a-microcontrollers/#how-microcontrollers-are-used","text":"Microcontrollers do three things: They read sensor values of the world around them They transform this data into useful representations They send outputs to devices that control the world such as LEDs and motors as well as displays Here is a general diagram to think about when you are designing microcontroller systems: Here is a specific example instance of what inputs and outputs might do.","title":"How Microcontrollers are Used"},{"location":"getting-started/01a-microcontrollers/#programming-a-microcontroller","text":"In this class, we will use the MicroPython to program our Microcontroller. Our programs will usually have the following structure: Imports : Specify the Python libraries used in the code ( More Information on Python libraries are available here ) Setup : Setup/ Initialize variables and sensors Main loop : Continuously monitor sensor inputs and take actions The following is an example code in Micropython: 1 2 3 4 5 6 7 8 9 10 11 12 13 # Import Section import machine import time # Setup Section led = machine . Pin ( 16 , machine . Pin . OUT ) # Main Loop while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) Almost all our programs will start with the import machine line. This tells the system that we need to gather all the libraries that understand our physical machine. If you couldn't understand the example program - don't worry! We will be going through it in detail as we work on our labs.","title":"Programming a Microcontroller"},{"location":"getting-started/01b-libraries/","text":"What is MicroPython? MicroPython is an implementation of the Python 3 programming language that includes a small subset of the Python standard library and is optimized to run on microcontrollers. ( From micropython.org ) MicroPython was originally created by the Australian programmer and physicist Damien George. It is written in C . MicroPython is now an OpenSource project and the source code is available in GitHub . Micropython Libraries When you start up your IDE, it may have a list of python modules built in. You can list the current modules you have installed by running the help('modules') command. 1 help ( 'modules' ) MicroPython Builtin Functions MicroPython is designed to run quickly in a small memory system. So it has trimmed down many of the standard Python libraries to fit the needs of microcontrollers. Most of these libraries start with the letter \"u\" so that you are aware they are designed to run on microcontrollers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cmath \u2013 mathematical functions for complex numbers gc \u2013 control the garbage collector math \u2013 mathematical functions uarray \u2013 arrays of numeric data uasyncio \u2014 asynchronous I/O scheduler ubinascii \u2013 binary/ASCII conversions ucollections \u2013 collection and container types uerrno \u2013 system error codes uhashlib \u2013 hashing algorithms uheapq \u2013 heap queue algorithm uio \u2013 input/output streams ujson \u2013 JSON encoding and decoding uos \u2013 basic \u201coperating system\u201d services ure \u2013 simple regular expressions uselect \u2013 wait for events on a set of streams usocket \u2013 socket module ussl \u2013 SSL/TLS module ustruct \u2013 pack and unpack primitive data types usys \u2013 system specific functions utime \u2013 time related functions uzlib \u2013 zlib decompression _thread \u2013 multithreading support MicroPython Specific Libraries 1 2 3 4 5 6 7 8 btree \u2013 simple BTree database framebuf \u2014 frame buffer manipulation machine \u2014 functions related to the hardware micropython \u2013 access and control MicroPython internals network \u2014 network configuration ubluetooth \u2014 low-level Bluetooth ucryptolib \u2013 cryptographic ciphers uctypes \u2013 access binary data in a structured way Adding a module When you are using python and you attempt to use a module that python can't find you will get an error. You must then use the python pip installer tool to add the new library. Getting MicroPython Libraries from PyPi Filter Only MicroPython Libraries Full List of modules 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 ESP-test audioop filecmp random __future__ base64 fileinput re _abc bcrypt fnmatch readline _ast bdb formatter reedsolo _asyncio binascii fractions reprlib _bisect binhex ftplib resource _blake2 bisect functools rlcompleter _bootlocale bitstring gc runpy _bz2 blink-builtin-led genericpath sched _cffi_backend brain_argparse getopt secrets _codecs brain_attrs getpass select _codecs_cn brain_builtin_inference gettext selectors _codecs_hk brain_collections glob send2trash _codecs_iso2022 brain_crypt grp serial _codecs_jp brain_curses gzip setuptools _codecs_kr brain_dataclasses hashlib sh1106 _codecs_tw brain_dateutil heapq sh1106-test _collections brain_fstrings hmac shelve _collections_abc brain_functools html shlex _compat_pickle brain_gi http shutil _compression brain_hashlib i2c-display signal _contextvars brain_http i2c-scanner site _crypt brain_io i2c_lcd six _csv brain_mechanize i2clcd smtpd _ctypes brain_multiprocessing imaplib smtplib _ctypes_test brain_namedtuple_enum imghdr sndhdr _curses brain_nose imp socket _curses_panel brain_numpy_core_fromnumeric importlib socketserver _datetime brain_numpy_core_function_base inspect spi-debug _dbm brain_numpy_core_multiarray io sqlite3 _decimal brain_numpy_core_numeric ipaddress sre_compile _dummy_thread brain_numpy_core_numerictypes isort sre_constants _elementtree brain_numpy_core_umath itertools sre_parse _functools brain_numpy_ndarray jedi ssl _hashlib brain_numpy_random_mtrand json stat _heapq brain_numpy_utils keyword statistics _imp brain_pkg_resources lazy_object_proxy string _io brain_pytest led-strip stringprep _json brain_qt lib2to3 struct _locale brain_random linecache subprocess _lsprof brain_re list-modules sunau _lzma brain_six locale symbol _markupbase brain_ssl logging symtable _md5 brain_subprocess lzma sys _multibytecodec brain_threading macpath sysconfig _multiprocessing brain_typing mailbox syslog _opcode brain_uuid mailcap tabnanny _operator builtins marshal tarfile _osx_support bz2 math telnetlib _pickle cProfile mccabe tempfile _posixsubprocess calendar mimetypes termios _py_abc certifi mmap test _pydecimal cffi modulefinder textwrap _pyio cgi multiprocessing this _queue cgitb mypy thonny _random chunk mypy_extensions threading _scproxy clonevirtualenv mypyc time _sha1 cmath nacl timeit _sha256 cmd netrc tkinter _sha3 code nis token _sha512 codecs nntplib tokenize _signal codeop ntpath toml _sitebuiltins collections nturl2path trace _socket colorsys numbers traceback _sqlite3 compileall opcode tracemalloc _sre concurrent operator tty _ssl configparser optparse turtle _stat contextlib os turtledemo _string contextvars paramiko typed_ast _strptime copy parser types _struct copyreg parso typing _symtable crypt pathlib typing_extensions _sysconfigdata_m_darwin_darwin cryptography pdb unicodedata _testbuffer csv pickle unittest _testcapi ctypes pickletools urllib _testimportmultiple curses pip uu _testmultiphase dataclasses pipenv uuid _thread datetime pipes venv _threading_local dbm pkg_resources virtualenv _tkinter decimal pkgutil virtualenv_support _tracemalloc difflib platform warnings _uuid dir-example plistlib wave _warnings dis poplib weakref _weakref distutils posix webbrowser _weakrefset doctest posixpath websockets _xxtestfuzz docutils pprint wheel abc dummy_threading profile wrapt aifc easy_install pstats wsgiref antigravity ecdsa pty xdrlib argparse email ptyprocess xml array encodings pwd xmlrpc array-test ensurepip py_compile xxlimited ast enum pyclbr xxsubtype astroid errno pycparser zipapp asttokens espefuse pydoc zipfile asynchat espressif pydoc_data zipimport asyncio espsecure pyexpat zlib asyncore esptool pylint at faulthandler queue atexit fcntl quopri","title":"MicroPython Libraries"},{"location":"getting-started/01b-libraries/#what-is-micropython","text":"MicroPython is an implementation of the Python 3 programming language that includes a small subset of the Python standard library and is optimized to run on microcontrollers. ( From micropython.org ) MicroPython was originally created by the Australian programmer and physicist Damien George. It is written in C . MicroPython is now an OpenSource project and the source code is available in GitHub .","title":"What is MicroPython?"},{"location":"getting-started/01b-libraries/#micropython-libraries","text":"When you start up your IDE, it may have a list of python modules built in. You can list the current modules you have installed by running the help('modules') command. 1 help ( 'modules' )","title":"Micropython Libraries"},{"location":"getting-started/01b-libraries/#micropython-builtin-functions","text":"MicroPython is designed to run quickly in a small memory system. So it has trimmed down many of the standard Python libraries to fit the needs of microcontrollers. Most of these libraries start with the letter \"u\" so that you are aware they are designed to run on microcontrollers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cmath \u2013 mathematical functions for complex numbers gc \u2013 control the garbage collector math \u2013 mathematical functions uarray \u2013 arrays of numeric data uasyncio \u2014 asynchronous I/O scheduler ubinascii \u2013 binary/ASCII conversions ucollections \u2013 collection and container types uerrno \u2013 system error codes uhashlib \u2013 hashing algorithms uheapq \u2013 heap queue algorithm uio \u2013 input/output streams ujson \u2013 JSON encoding and decoding uos \u2013 basic \u201coperating system\u201d services ure \u2013 simple regular expressions uselect \u2013 wait for events on a set of streams usocket \u2013 socket module ussl \u2013 SSL/TLS module ustruct \u2013 pack and unpack primitive data types usys \u2013 system specific functions utime \u2013 time related functions uzlib \u2013 zlib decompression _thread \u2013 multithreading support","title":"MicroPython Builtin Functions"},{"location":"getting-started/01b-libraries/#micropython-specific-libraries","text":"1 2 3 4 5 6 7 8 btree \u2013 simple BTree database framebuf \u2014 frame buffer manipulation machine \u2014 functions related to the hardware micropython \u2013 access and control MicroPython internals network \u2014 network configuration ubluetooth \u2014 low-level Bluetooth ucryptolib \u2013 cryptographic ciphers uctypes \u2013 access binary data in a structured way","title":"MicroPython Specific Libraries"},{"location":"getting-started/01b-libraries/#adding-a-module","text":"When you are using python and you attempt to use a module that python can't find you will get an error. You must then use the python pip installer tool to add the new library.","title":"Adding a module"},{"location":"getting-started/01b-libraries/#getting-micropython-libraries-from-pypi","text":"Filter Only MicroPython Libraries","title":"Getting MicroPython Libraries from PyPi"},{"location":"getting-started/01b-libraries/#full-list-of-modules","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 ESP-test audioop filecmp random __future__ base64 fileinput re _abc bcrypt fnmatch readline _ast bdb formatter reedsolo _asyncio binascii fractions reprlib _bisect binhex ftplib resource _blake2 bisect functools rlcompleter _bootlocale bitstring gc runpy _bz2 blink-builtin-led genericpath sched _cffi_backend brain_argparse getopt secrets _codecs brain_attrs getpass select _codecs_cn brain_builtin_inference gettext selectors _codecs_hk brain_collections glob send2trash _codecs_iso2022 brain_crypt grp serial _codecs_jp brain_curses gzip setuptools _codecs_kr brain_dataclasses hashlib sh1106 _codecs_tw brain_dateutil heapq sh1106-test _collections brain_fstrings hmac shelve _collections_abc brain_functools html shlex _compat_pickle brain_gi http shutil _compression brain_hashlib i2c-display signal _contextvars brain_http i2c-scanner site _crypt brain_io i2c_lcd six _csv brain_mechanize i2clcd smtpd _ctypes brain_multiprocessing imaplib smtplib _ctypes_test brain_namedtuple_enum imghdr sndhdr _curses brain_nose imp socket _curses_panel brain_numpy_core_fromnumeric importlib socketserver _datetime brain_numpy_core_function_base inspect spi-debug _dbm brain_numpy_core_multiarray io sqlite3 _decimal brain_numpy_core_numeric ipaddress sre_compile _dummy_thread brain_numpy_core_numerictypes isort sre_constants _elementtree brain_numpy_core_umath itertools sre_parse _functools brain_numpy_ndarray jedi ssl _hashlib brain_numpy_random_mtrand json stat _heapq brain_numpy_utils keyword statistics _imp brain_pkg_resources lazy_object_proxy string _io brain_pytest led-strip stringprep _json brain_qt lib2to3 struct _locale brain_random linecache subprocess _lsprof brain_re list-modules sunau _lzma brain_six locale symbol _markupbase brain_ssl logging symtable _md5 brain_subprocess lzma sys _multibytecodec brain_threading macpath sysconfig _multiprocessing brain_typing mailbox syslog _opcode brain_uuid mailcap tabnanny _operator builtins marshal tarfile _osx_support bz2 math telnetlib _pickle cProfile mccabe tempfile _posixsubprocess calendar mimetypes termios _py_abc certifi mmap test _pydecimal cffi modulefinder textwrap _pyio cgi multiprocessing this _queue cgitb mypy thonny _random chunk mypy_extensions threading _scproxy clonevirtualenv mypyc time _sha1 cmath nacl timeit _sha256 cmd netrc tkinter _sha3 code nis token _sha512 codecs nntplib tokenize _signal codeop ntpath toml _sitebuiltins collections nturl2path trace _socket colorsys numbers traceback _sqlite3 compileall opcode tracemalloc _sre concurrent operator tty _ssl configparser optparse turtle _stat contextlib os turtledemo _string contextvars paramiko typed_ast _strptime copy parser types _struct copyreg parso typing _symtable crypt pathlib typing_extensions _sysconfigdata_m_darwin_darwin cryptography pdb unicodedata _testbuffer csv pickle unittest _testcapi ctypes pickletools urllib _testimportmultiple curses pip uu _testmultiphase dataclasses pipenv uuid _thread datetime pipes venv _threading_local dbm pkg_resources virtualenv _tkinter decimal pkgutil virtualenv_support _tracemalloc difflib platform warnings _uuid dir-example plistlib wave _warnings dis poplib weakref _weakref distutils posix webbrowser _weakrefset doctest posixpath websockets _xxtestfuzz docutils pprint wheel abc dummy_threading profile wrapt aifc easy_install pstats wsgiref antigravity ecdsa pty xdrlib argparse email ptyprocess xml array encodings pwd xmlrpc array-test ensurepip py_compile xxlimited ast enum pyclbr xxsubtype astroid errno pycparser zipapp asttokens espefuse pydoc zipfile asynchat espressif pydoc_data zipimport asyncio espsecure pyexpat zlib asyncore esptool pylint at faulthandler queue atexit fcntl quopri","title":"Full List of modules"},{"location":"getting-started/02-boards/","text":"Micropython Boards Technically, any computer that has at least 16K of RAM can run Micropython. ESP32 ESP32 - $5 to $21 Raspberry Pi Pico Raspberry Pi Pico (../glossary.md#ESP32) - $4 Cables You will need a USB cable to program your microcontroller. These cables are frequently sold at high margin rates at retail stores. If you plan ahead, you can usually find these cables on eBay for about 50% less. Classroom purchases make this a good option. Getting Machine Statistics 1 2 import machine help(machine)","title":"Boards"},{"location":"getting-started/02-boards/#micropython-boards","text":"Technically, any computer that has at least 16K of RAM can run Micropython.","title":"Micropython Boards"},{"location":"getting-started/02-boards/#esp32","text":"ESP32 - $5 to $21","title":"ESP32"},{"location":"getting-started/02-boards/#raspberry-pi-pico","text":"Raspberry Pi Pico (../glossary.md#ESP32) - $4","title":"Raspberry Pi Pico"},{"location":"getting-started/02-boards/#cables","text":"You will need a USB cable to program your microcontroller. These cables are frequently sold at high margin rates at retail stores. If you plan ahead, you can usually find these cables on eBay for about 50% less. Classroom purchases make this a good option.","title":"Cables"},{"location":"getting-started/02-boards/#getting-machine-statistics","text":"1 2 import machine help(machine)","title":"Getting Machine Statistics"},{"location":"getting-started/02-esp32/","text":"ESP32 TTGO The ESP32 is a low-cost (under $10) microcontroller with both built-in WiFi and Bluetooth. This lab demonstrates using a version of the ESP32 that includes an integrated display. Step 1: Install the USB to UART Bridge VCP Drivers Follow the directions here: https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers Test this by running the ``ls -l /dev/cu*``` and verify you see: /dev/cu.SLAB_USBtoUART If you don't see this try to reboot. Mac: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/establish-serial-connection.html https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/raw/master/MicroPython_BUILD/firmware/MicroPython_LoBo_esp32_all.zip Step 2: Create a Python Conda Environment for ESP32 This is so we don't mess up other Python projects on your system. 1 2 conda create -n esp32 python = 3 conda activate esp32 Step #3: Install the esptool 1 2 3 4 5 6 7 $ pip3 install esptool Collecting esptool Downloading esptool-3.0.tar.gz ( 149 kB ) | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 149 kB 2 .9 MB/s ... Installing collected packages: pycparser, six, cffi, reedsolo, pyserial, ecdsa, cryptography, bitstring, esptool Successfully installed bitstring-3.1.7 cffi-1.14.5 cryptography-3.4.6 ecdsa-0.16.1 esptool-3.0 pycparser-2.20 pyserial-3.5 reedsolo-1.5.4 six-1.15.0 Step 4: Erase the Old Firmware 1 esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash Step 5: Download the New Firmware Get the ESP32_All prebuilt binary: https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/wiki/firmwares Step 6: Reflash the new ESP32 Firmware 1 2 cd esp32_all/ ../flash.sh -p /dev/cu.SLAB_USBtoUART this will run... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash esptool.py v3.0 Serial port /dev/cu.SLAB_USBtoUART Connecting........_ Detecting chip type... ESP32 Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 24 :62:ab:ca:62:84 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 2 .5s Hard resetting via RTS pin... Configure Thonny You must configure Thonny to use the ESP32. Set the Serial Port First, you must tell Thonny how to find the right port. Set the Interpreter Next, yo must tell Thonny to use the ESP32 interpreter. Run a test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import machine , display , time , math , network , utime tft = display . TFT () tft . init ( tft . ST7789 , bgr = False , rot = tft . LANDSCAPE , miso = 17 , backl_pin = 4 , backl_on = 1 , mosi = 19 , clk = 18 , cs = 5 , dc = 16 ) tft . setwin ( 40 , 52 , 320 , 240 ) for i in range ( 0 , 241 ): color = 0xFFFFFF - tft . hsb2rgb ( i / 241 * 360 , 1 , 1 ) tft . line ( i , 0 , i , 135 , color ) tft . set_fg ( 0x000000 ) tft . ellipse ( 120 , 67 , 120 , 67 ) tft . line ( 0 , 0 , 240 , 135 ) text = \"CoderDojo Rocks!\" tft . text ( 120 - int ( tft . textWidth ( text ) / 2 ), 67 - int ( tft . fontSize ()[ 1 ] / 2 ), text , 0xFFFFFF ) You should see the following on the ESP32 display: References https://www.instructables.com/TTGO-color-Display-With-Micropython-TTGO-T-display/","title":"ESP32"},{"location":"getting-started/02-esp32/#esp32-ttgo","text":"The ESP32 is a low-cost (under $10) microcontroller with both built-in WiFi and Bluetooth. This lab demonstrates using a version of the ESP32 that includes an integrated display.","title":"ESP32 TTGO"},{"location":"getting-started/02-esp32/#step-1-install-the-usb-to-uart-bridge-vcp-drivers","text":"Follow the directions here: https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers Test this by running the ``ls -l /dev/cu*``` and verify you see: /dev/cu.SLAB_USBtoUART If you don't see this try to reboot. Mac: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/establish-serial-connection.html https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/raw/master/MicroPython_BUILD/firmware/MicroPython_LoBo_esp32_all.zip","title":"Step 1: Install the USB to UART Bridge VCP Drivers"},{"location":"getting-started/02-esp32/#step-2-create-a-python-conda-environment-for-esp32","text":"This is so we don't mess up other Python projects on your system. 1 2 conda create -n esp32 python = 3 conda activate esp32","title":"Step 2: Create a Python Conda Environment for ESP32"},{"location":"getting-started/02-esp32/#step-3-install-the-esptool","text":"1 2 3 4 5 6 7 $ pip3 install esptool Collecting esptool Downloading esptool-3.0.tar.gz ( 149 kB ) | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 149 kB 2 .9 MB/s ... Installing collected packages: pycparser, six, cffi, reedsolo, pyserial, ecdsa, cryptography, bitstring, esptool Successfully installed bitstring-3.1.7 cffi-1.14.5 cryptography-3.4.6 ecdsa-0.16.1 esptool-3.0 pycparser-2.20 pyserial-3.5 reedsolo-1.5.4 six-1.15.0","title":"Step #3: Install the esptool"},{"location":"getting-started/02-esp32/#step-4-erase-the-old-firmware","text":"1 esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash","title":"Step 4: Erase the Old Firmware"},{"location":"getting-started/02-esp32/#step-5-download-the-new-firmware","text":"Get the ESP32_All prebuilt binary: https://github.com/loboris/MicroPython_ESP32_psRAM_LoBo/wiki/firmwares","title":"Step 5: Download the New Firmware"},{"location":"getting-started/02-esp32/#step-6-reflash-the-new-esp32-firmware","text":"1 2 cd esp32_all/ ../flash.sh -p /dev/cu.SLAB_USBtoUART this will run... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ esptool.py --port /dev/cu.SLAB_USBtoUART erase_flash esptool.py v3.0 Serial port /dev/cu.SLAB_USBtoUART Connecting........_ Detecting chip type... ESP32 Chip is ESP32-D0WDQ6 ( revision 1 ) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: 24 :62:ab:ca:62:84 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 2 .5s Hard resetting via RTS pin...","title":"Step 6: Reflash the new ESP32 Firmware"},{"location":"getting-started/02-esp32/#configure-thonny","text":"You must configure Thonny to use the ESP32.","title":"Configure Thonny"},{"location":"getting-started/02-esp32/#set-the-serial-port","text":"First, you must tell Thonny how to find the right port.","title":"Set the Serial Port"},{"location":"getting-started/02-esp32/#set-the-interpreter","text":"Next, yo must tell Thonny to use the ESP32 interpreter.","title":"Set the Interpreter"},{"location":"getting-started/02-esp32/#run-a-test","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import machine , display , time , math , network , utime tft = display . TFT () tft . init ( tft . ST7789 , bgr = False , rot = tft . LANDSCAPE , miso = 17 , backl_pin = 4 , backl_on = 1 , mosi = 19 , clk = 18 , cs = 5 , dc = 16 ) tft . setwin ( 40 , 52 , 320 , 240 ) for i in range ( 0 , 241 ): color = 0xFFFFFF - tft . hsb2rgb ( i / 241 * 360 , 1 , 1 ) tft . line ( i , 0 , i , 135 , color ) tft . set_fg ( 0x000000 ) tft . ellipse ( 120 , 67 , 120 , 67 ) tft . line ( 0 , 0 , 240 , 135 ) text = \"CoderDojo Rocks!\" tft . text ( 120 - int ( tft . textWidth ( text ) / 2 ), 67 - int ( tft . fontSize ()[ 1 ] / 2 ), text , 0xFFFFFF ) You should see the following on the ESP32 display:","title":"Run a test"},{"location":"getting-started/02-esp32/#references","text":"https://www.instructables.com/TTGO-color-Display-With-Micropython-TTGO-T-display/","title":"References"},{"location":"getting-started/02-pi-pico/","text":"Getting Started with the Raspberry Pi Pico The Raspberry Pi Pico is a custom silicon microcontroller built by the Raspberry Pi Foundation with a retail list prices of $4. With 264K SRAM, it has around 100 times the RAM of an Arduino Uno (2K). It is ideal for projects that need more RAM such as project that require drawing to an OLED display. Specs RP2040 microcontroller chip designed by Raspberry Pi Foundation Dual-core Arm Cortex M0+ processor, flexible clock running up to 133 MHz 264KB of SRAM, and 2MB of on-board Flash memory Support for up to 16MB of off-chip Flash memory via dedicated QSPI bus DMA controller Interpolator and integer divider peripherals Castellated module allows soldering direct to carrier boards USB 1.1 and PHY with device and host support Low-power sleep and dormant modes Drag-and-drop programming using mass storage over USB 26 \u00d7 multi-function GPIO pins 3 12 bit analogue inputs 16 controllable PWM channels 2 SPI, 2 I2C, and 2 UART channels Accurate clock and timer on-chip 8 Raspberry Pi Programmable I/O (PIO) state machines Temperature sensor Accelerated floating-point libraries on-chip 8 \u00d7 Programmable I/O (PIO) state machines for custom peripheral support Created using the TSMC 40LP (40 nano meter low power) manufacturing process USB mass-storage boot mode with UF2 support, for drag-and-drop programming USB Cable The Raspberry Pi Pico uses a USB-micro connector. You can purchase USB Micro-B to USB-A or USB-C (Mac) cables on e-bay for under $2 or for $5 at Microcenter. - image from ebay Pico Pinout The pinout diagram for the Raspberry Pi Pico is shown below. It features: * 26 \u00d7 multi-function GPIO pins * 2 \u00d7 SPI, 2 \u00d7 I2C, 2 \u00d7 UART, 3 \u00d7 12-bit ADC, 16 \u00d7 controllable PWM Raspberry Pi Pico\u2019s 40 pins with pin 1 in the upper right corner with the USB connector at the top. The pin numbers are incremented as you go counterclockwise around the board. You go down the left side and then continue up on the right side until you get to pin 40 in the upper right corner. When you program the Pico, you use the machine.Pin() but you always use the GP* number, never the pin number on the board pin numbers. The diagram above shows the top view where pins 1, 2 and 40 are printed next to the pins. Pico Pinout Datasheet PDF Next to each pin is the primary label of what the pin does. Pins 3, 8, 13, 18, 23, 28, 33 and 38 with the black background are all GND pins. Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Label Name Description V3 3.3 volts power A source of 3.3 V power, the same voltage your Pico runs at internally, generated from the VSYS input. This power supply can be switched on and off using the 3V3_EN pin above it, which also switches your Pico off. VSYS ~2-5 volts power A pin directly connected to your Pico\u2019s internal power supply, which cannot be switched off without also switching Pico off. VBUS 5 volts power A source of 5 V power taken from your Pico\u2019s micro USB port, and used to power hardware which needs more than 3.3 V. GND 0 volts ground A ground connection, used to complete a circuit connected to a power source. Several of these pins are dotted around your Pico to make wiring easier. GPxx General-purpose input/output pin number \u2018xx The GPIO pins available for your program, labelled \u2018GP0\u2019 through to \u2018GP28\u2019. GPxx_ADCx General-purpose input/output pin number \u2018xx\u2019, with analogue input number \u2018x\u2019 A GPIO pin which ends in \u2018ADC\u2019 and a number can be used as an analogue input as well as a digital input or output \u2013 but not both at the same time. ADC_VREF Analogue-to-digital converter (ADC) voltage reference A special input pin which sets a reference voltage for any analogue inputs. AGND Analogue-to-digital converter (ADC) 0 volts ground A special ground connection for use with the ADC_VREF pin. RUN Enables or disables your Pico The RUN header is used to start and stop your Pico from another microcontroller. Steps To Get Micropython Running on the Mac Download the MicroPython UF2 file. Push and hold the BOOTSEL button and plug your Pico into the USB port of your Raspberry Pi or other computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2. Drag and drop the MicroPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. You are now running MicroPython. Using Thonny Thonny is a free lightweight Python development tool. Download the Thonny Application Download the Thonny Pico driver Configure Thonny to use the Pico interpreter Test using the help() function Test by running a blink application 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done! Getting The Bootloader Running from the Thonny Python Shell Although you can hold down the BOOTSEL button as you are plugging in the Pico, there is a much easier way. Just type the following into the Thonny shell: 1 >>>machine.bootloader () This will make the Pico go into the Bootloader Mode and mount the file system. You can then copy the bootloader file using the drag-and-drop from your file system or use a UNIX copy command. Once the copy is finished the Pico will automaticaly restart using the new uf2 file. Using the Onboard LED 1 2 3 4 from machine import Pin import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) led_onboard . value ( 1 ) 1 2 3 4 5 6 7 8 9 from machine import Pin import utime # right uppermost pin with USB on the left led = Pin ( 16 , Pin . OUT ) led . low () while True : led . toggle () utime . sleep ( 1 ) Press the Play Button References Getting Started Guide Raspberry Pi Getting Started Book PDF Raspberry Pi Book PDF Download Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)","title":"Raspberry Pi Pico"},{"location":"getting-started/02-pi-pico/#getting-started-with-the-raspberry-pi-pico","text":"The Raspberry Pi Pico is a custom silicon microcontroller built by the Raspberry Pi Foundation with a retail list prices of $4. With 264K SRAM, it has around 100 times the RAM of an Arduino Uno (2K). It is ideal for projects that need more RAM such as project that require drawing to an OLED display.","title":"Getting Started with the Raspberry Pi Pico"},{"location":"getting-started/02-pi-pico/#specs","text":"RP2040 microcontroller chip designed by Raspberry Pi Foundation Dual-core Arm Cortex M0+ processor, flexible clock running up to 133 MHz 264KB of SRAM, and 2MB of on-board Flash memory Support for up to 16MB of off-chip Flash memory via dedicated QSPI bus DMA controller Interpolator and integer divider peripherals Castellated module allows soldering direct to carrier boards USB 1.1 and PHY with device and host support Low-power sleep and dormant modes Drag-and-drop programming using mass storage over USB 26 \u00d7 multi-function GPIO pins 3 12 bit analogue inputs 16 controllable PWM channels 2 SPI, 2 I2C, and 2 UART channels Accurate clock and timer on-chip 8 Raspberry Pi Programmable I/O (PIO) state machines Temperature sensor Accelerated floating-point libraries on-chip 8 \u00d7 Programmable I/O (PIO) state machines for custom peripheral support Created using the TSMC 40LP (40 nano meter low power) manufacturing process USB mass-storage boot mode with UF2 support, for drag-and-drop programming","title":"Specs"},{"location":"getting-started/02-pi-pico/#usb-cable","text":"The Raspberry Pi Pico uses a USB-micro connector. You can purchase USB Micro-B to USB-A or USB-C (Mac) cables on e-bay for under $2 or for $5 at Microcenter. - image from ebay","title":"USB Cable"},{"location":"getting-started/02-pi-pico/#pico-pinout","text":"The pinout diagram for the Raspberry Pi Pico is shown below. It features: * 26 \u00d7 multi-function GPIO pins * 2 \u00d7 SPI, 2 \u00d7 I2C, 2 \u00d7 UART, 3 \u00d7 12-bit ADC, 16 \u00d7 controllable PWM Raspberry Pi Pico\u2019s 40 pins with pin 1 in the upper right corner with the USB connector at the top. The pin numbers are incremented as you go counterclockwise around the board. You go down the left side and then continue up on the right side until you get to pin 40 in the upper right corner. When you program the Pico, you use the machine.Pin() but you always use the GP* number, never the pin number on the board pin numbers. The diagram above shows the top view where pins 1, 2 and 40 are printed next to the pins. Pico Pinout Datasheet PDF Next to each pin is the primary label of what the pin does. Pins 3, 8, 13, 18, 23, 28, 33 and 38 with the black background are all GND pins. Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Label Name Description V3 3.3 volts power A source of 3.3 V power, the same voltage your Pico runs at internally, generated from the VSYS input. This power supply can be switched on and off using the 3V3_EN pin above it, which also switches your Pico off. VSYS ~2-5 volts power A pin directly connected to your Pico\u2019s internal power supply, which cannot be switched off without also switching Pico off. VBUS 5 volts power A source of 5 V power taken from your Pico\u2019s micro USB port, and used to power hardware which needs more than 3.3 V. GND 0 volts ground A ground connection, used to complete a circuit connected to a power source. Several of these pins are dotted around your Pico to make wiring easier. GPxx General-purpose input/output pin number \u2018xx The GPIO pins available for your program, labelled \u2018GP0\u2019 through to \u2018GP28\u2019. GPxx_ADCx General-purpose input/output pin number \u2018xx\u2019, with analogue input number \u2018x\u2019 A GPIO pin which ends in \u2018ADC\u2019 and a number can be used as an analogue input as well as a digital input or output \u2013 but not both at the same time. ADC_VREF Analogue-to-digital converter (ADC) voltage reference A special input pin which sets a reference voltage for any analogue inputs. AGND Analogue-to-digital converter (ADC) 0 volts ground A special ground connection for use with the ADC_VREF pin. RUN Enables or disables your Pico The RUN header is used to start and stop your Pico from another microcontroller.","title":"Pico Pinout"},{"location":"getting-started/02-pi-pico/#steps-to-get-micropython-running-on-the-mac","text":"Download the MicroPython UF2 file. Push and hold the BOOTSEL button and plug your Pico into the USB port of your Raspberry Pi or other computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2. Drag and drop the MicroPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. You are now running MicroPython.","title":"Steps To Get Micropython Running on the Mac"},{"location":"getting-started/02-pi-pico/#using-thonny","text":"Thonny is a free lightweight Python development tool. Download the Thonny Application Download the Thonny Pico driver Configure Thonny to use the Pico interpreter Test using the help() function Test by running a blink application 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done!","title":"Using Thonny"},{"location":"getting-started/02-pi-pico/#getting-the-bootloader-running-from-the-thonny-python-shell","text":"Although you can hold down the BOOTSEL button as you are plugging in the Pico, there is a much easier way. Just type the following into the Thonny shell: 1 >>>machine.bootloader () This will make the Pico go into the Bootloader Mode and mount the file system. You can then copy the bootloader file using the drag-and-drop from your file system or use a UNIX copy command. Once the copy is finished the Pico will automaticaly restart using the new uf2 file.","title":"Getting The Bootloader Running from the Thonny Python Shell"},{"location":"getting-started/02-pi-pico/#using-the-onboard-led","text":"1 2 3 4 from machine import Pin import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) led_onboard . value ( 1 ) 1 2 3 4 5 6 7 8 9 from machine import Pin import utime # right uppermost pin with USB on the left led = Pin ( 16 , Pin . OUT ) led . low () while True : led . toggle () utime . sleep ( 1 ) Press the Play Button","title":"Using the Onboard LED"},{"location":"getting-started/02-pi-pico/#references","text":"","title":"References"},{"location":"getting-started/02-pi-pico/#getting-started-guide","text":"Raspberry Pi Getting Started","title":"Getting Started Guide"},{"location":"getting-started/02-pi-pico/#book-pdf","text":"Raspberry Pi Book PDF Download Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)","title":"Book PDF"},{"location":"getting-started/02c-thonny/","text":"Thonny Python IDE A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny has the following screen areas. Toolbar Script Area Python Shell Interpreter Thonny runs on Mac, Windows and Linux. Running help() You can enter the help() function in the main script area and then press the Play button. This will tell you 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 MicroPython v1.14 on 2021-02-02; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT Welcome to MicroPython! For online help please visit https://micropython.org/help/. For access to the hardware use the 'machine' module. RP2 specific commands are in the 'rp2' module. Quick overview of some objects: machine.Pin(pin) -- get a pin, eg machine.Pin(0) machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p methods: init(..), value([v]), high(), low(), irq(handler) machine.ADC(pin) -- make an analog object from a pin methods: read_u16() machine.PWM(pin) -- make a PWM object from a pin methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d]) machine.I2C(id) -- create an I2C object (id=0,1) methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True) readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg) machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1) methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf) machine.Timer(freq, callback) -- create a software timer object eg: machine.Timer(freq=1, callback=lambda t:print(t)) Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Useful control commands: CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') >>> Save Options You can save a python file in Thonny to either the Pico or to your local computer's file system. first stop execution of any program you are running. Downloading the Firmware After you start up Thonny there will be a button in the lower right corner. After you click on it you will see the following: 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done! Version After you press play the following will appear in the console. 1 2 3 MicroPython v1.13-290-g556ae7914 on 2021 -01-21 ; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT Background on Thonny Micropython was originally developed by Damien George and first released in 2014. Some support of Thonny is being done the University of Tartu Institute of Computer Science in Estonia. Several features were sponsored by the Raspberry Pi Foundation Thonny web site","title":"Thonny IDE"},{"location":"getting-started/02c-thonny/#thonny-python-ide","text":"A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny has the following screen areas.","title":"Thonny Python IDE"},{"location":"getting-started/02c-thonny/#toolbar","text":"","title":"Toolbar"},{"location":"getting-started/02c-thonny/#script-area","text":"","title":"Script Area"},{"location":"getting-started/02c-thonny/#python-shell","text":"","title":"Python Shell"},{"location":"getting-started/02c-thonny/#interpreter","text":"Thonny runs on Mac, Windows and Linux.","title":"Interpreter"},{"location":"getting-started/02c-thonny/#running-help","text":"You can enter the help() function in the main script area and then press the Play button. This will tell you 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 MicroPython v1.14 on 2021-02-02; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT Welcome to MicroPython! For online help please visit https://micropython.org/help/. For access to the hardware use the 'machine' module. RP2 specific commands are in the 'rp2' module. Quick overview of some objects: machine.Pin(pin) -- get a pin, eg machine.Pin(0) machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p methods: init(..), value([v]), high(), low(), irq(handler) machine.ADC(pin) -- make an analog object from a pin methods: read_u16() machine.PWM(pin) -- make a PWM object from a pin methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d]) machine.I2C(id) -- create an I2C object (id=0,1) methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True) readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg) machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1) methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf) machine.Timer(freq, callback) -- create a software timer object eg: machine.Timer(freq=1, callback=lambda t:print(t)) Pins are numbered 0-29, and 26-29 have ADC capabilities Pin IO modes are: Pin.IN, Pin.OUT, Pin.ALT Pin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN Useful control commands: CTRL-C -- interrupt a running program CTRL-D -- on a blank line, do a soft reset of the board CTRL-E -- on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') >>>","title":"Running help()"},{"location":"getting-started/02c-thonny/#save-options","text":"You can save a python file in Thonny to either the Pico or to your local computer's file system. first stop execution of any program you are running.","title":"Save Options"},{"location":"getting-started/02c-thonny/#downloading-the-firmware","text":"After you start up Thonny there will be a button in the lower right corner. After you click on it you will see the following: 1 2 3 4 5 6 7 Downloading 465408 bytes from https://github.com/raspberrypi/micropython/releases/download/pico-20210120/pico_micropython_20210121.uf2 Writing to /Volumes/RPI-RP2/firmware 100% Waiting for the port... Found 2e8a:0005 at /dev/cu.usbmodem0000000000001 Done!","title":"Downloading the Firmware"},{"location":"getting-started/02c-thonny/#version","text":"After you press play the following will appear in the console. 1 2 3 MicroPython v1.13-290-g556ae7914 on 2021 -01-21 ; Raspberry Pi Pico with RP2040 Type \"help()\" for more information. >>> %Run -c $EDITOR_CONTENT","title":"Version"},{"location":"getting-started/02c-thonny/#background-on-thonny","text":"Micropython was originally developed by Damien George and first released in 2014. Some support of Thonny is being done the University of Tartu Institute of Computer Science in Estonia. Several features were sponsored by the Raspberry Pi Foundation Thonny web site","title":"Background on Thonny"},{"location":"getting-started/02d-vscode/","text":"Using Visual Studio Code to Program MicroPython Although the Thonney IDE is a great way for kids to start programming in Python on the Raspberry Pi Pico, it has limited advanced features and no large library of extensions. For intermediate to advanced Python developers, the Visual Studio Code IDE is a good options when it is used with an appropriate extension such as the Pico Go extension by Chris Wood. Note that Visual Studio Code is sometimes just called VS Code. Code extensions provide code auto-completion and allows you to communicate with your Raspberry Pi Pico board using the built-in REPL console. You can a single file on your board, sync your entire project or directly type and execute commands. Because the files are stored on your local computer, it makes it easier to use version control software to allow you to work in teams with remote developers. Installing Visual Studio Code Visual Studio Code runs on Windows, Mac and Linux systems such as the operating systems that run on the Raspberry Pi 3 or 4. You typically need around 2GB of RAM to run VS-Code. See the VS Code Requirements . If you have a Raspberry Pi the installation instructions are here . Adding the Pico Go Extension After you have installed VS-Code you must download the Pico Go Extension: Pico Go Quick Start References Pico Go by Chris Wood Bao Phan Micropython Extension","title":"VS Code IED"},{"location":"getting-started/02d-vscode/#using-visual-studio-code-to-program-micropython","text":"Although the Thonney IDE is a great way for kids to start programming in Python on the Raspberry Pi Pico, it has limited advanced features and no large library of extensions. For intermediate to advanced Python developers, the Visual Studio Code IDE is a good options when it is used with an appropriate extension such as the Pico Go extension by Chris Wood. Note that Visual Studio Code is sometimes just called VS Code. Code extensions provide code auto-completion and allows you to communicate with your Raspberry Pi Pico board using the built-in REPL console. You can a single file on your board, sync your entire project or directly type and execute commands. Because the files are stored on your local computer, it makes it easier to use version control software to allow you to work in teams with remote developers.","title":"Using Visual Studio Code to Program MicroPython"},{"location":"getting-started/02d-vscode/#installing-visual-studio-code","text":"Visual Studio Code runs on Windows, Mac and Linux systems such as the operating systems that run on the Raspberry Pi 3 or 4. You typically need around 2GB of RAM to run VS-Code. See the VS Code Requirements . If you have a Raspberry Pi the installation instructions are here .","title":"Installing Visual Studio Code"},{"location":"getting-started/02d-vscode/#adding-the-pico-go-extension","text":"After you have installed VS-Code you must download the Pico Go Extension: Pico Go Quick Start","title":"Adding the Pico Go Extension"},{"location":"getting-started/02d-vscode/#references","text":"Pico Go by Chris Wood Bao Phan Micropython Extension","title":"References"},{"location":"getting-started/03-suggested-parts/","text":"Sourcing Parts One of the key values of CoderDojo clubs around the world is to not charge any fees for attending these clubs. Parts need to be purchase by limited funds raised through donations. Club organizers need to be frugal about getting low-cost parts for the participants. Our experience is that is difficult to get the right parts at low cost using firms that promise quick delivery times of a few days. The lowest price parts often must be purchased weeks in advance from places like China and Taiwan. As a result, clubs that use funds carefully must plan weeks if not months in advance of classes and events. So we strongly suggest bringing an robot part procurement team together two months before you begin to offer robot courses where students can each have their own robots. Purchasing The Raspberry Pi Kits As of June 2021, the Raspberry Pi Pico did not come integrated into low-cost development kits that include robot kit parts. You frequently must to purchase the independent parts yourself. Here are some of the parts we recommend. The Raspberry Pi Pico In the US, our best source of these has been Microcenter stores. They sell them for $3.99 and they often have them on sale for $1.99. Microcenter Pico Part Listing Microcenter has around 25 Locations in the US. USB Cable For a Mac with USB-C connectors, you will need to get a USB micro to C cable: Ebay USB 3.1 USB C Type C to Micro USB Male Sync OTG Charge Data Transfers Adapters Sample 1 meter USB cable on eBay for $2.40. Headers We need male breakaway headers with standard 1/10th inch spacing. The Raspberry Pi Pico will need 20 pins on each side. If you get 40-pin versions they can easily be broken in half. EBay: Ebay 40-Pin Male Header 0.1\" 2.54mm Breadboard PCB Strip Connectors 5pc - these ship from China in a few weeks and you can get five of them for $1 (including shipping). Amazon: Amazon MCIGICM 10pcs Male Header Pin, 40 Pin Header Strip (2.54 mm) for Arduino Connector Solderless Breadboards We like the 1/2 size boards that have 400 connection points. We like to mount them with the USB connector at the top with the numbers running down the left side to align with the pin numbers. EBay: Solderless Breadboard 400 Point Tie Prototype Test Bread Board PCB For Arduino Amazon: Amazon 4 Pieces for $6 Hookup Wire Use 22 gauge wire. Get a large spool of black and red and smaller spools of other colors. Male-to-Male Breadboard Jumper Wires You can use 22 gauge wire to build your projects, however kids that don't have fine motor skills sometimes get frustrated with raw wires. You can purchase a Jumper Wire Kit with 65 jumpers on EBay for under $2 that has nice plastic ends that are easier to use. Ebay: 65pcs Jumper Wire cable kit for Solderless Breadboard New - 65 of various lengths for $1.50 Ebay: 65X 65PCS Jumper Wire Cable Kit For Solderless Breadboard Amazon: ZYAMY 195pcs Breadboard Jumper Wire 12cm 16cm 20cm 24cm Solderless Flexible Breadboard Connecting Line Cables Male to Male Breadboard Jumpers (65pcs/Set x 3) - three packs of 65 for about $8 Momentary Press Buttons A B3F Momentary Press Button with a blue cap. Note the schematic in the lower right corner that shows the internal connections of the button. We like the B3F-4055 12 x12x7.3mm Tactile Switch Momentary Press Buttons that have small dimples on the bottom that fit into the breadboard center trough. They can be purchased for under 10 cents per unit on eBay. You can by them with our without colored caps. The links below have example listings on eBay. eBay Tactile Push Button Switch Momentary Tact & Cap 12x12x7.3mm Assorted Kit - this kit includes 15 switchs with seven colors of caps for US $8.95. eBay: 10PCS New B3F Tactile Switch Key Button Switch 12x12x7.3mm Blue eBay 100PCS B3F-4055 Tactile Switch W/ OMRON Tact Push Button Momentary 12 x12 x7.3mm eBay Button Caps 140PCS Round Tactile Button Cap Kits 9.58 5.1mm for 12 12*7.3mm Tact Switch Sensor Kit Although not all of these items are really \"sensors\" (some are displays), these kits provide high value at a low price-per item cost. Note that some of these kits contain tilt switches that contain Mercery. I remove these from the kits. EBay 16 Sensor Kit Raspberry Pi / Arduino Sensor Kit 16 Modules Package 16 kinds of sensor EBay 45 Sensor Kit for $18 US 45 In 1 Sensor Module Starter Kit Updated Set For Arduino Raspberry Pi Education HiLetgo 37 Sensors Assortment Kit 37 Sensors Kit Sensor Starter Kit for Arduino Raspberry pi Sensor kit 37 in 1 Robot Projects Starter Kits for Arduino Raspberry pi Linear 10K Potentiometers We use linear 10K potentiometers in many labs and kits. The pre-wired options are very handy but you will need some male-to-male jumpers. EBay: Pre-wired Potentiometer with Knob EBay: 10 10K Pots for $2.29 Amazon: 10K Pot Kit with 8 pots and knobs for $8 Momentary Press Buttons We like these small momentary press buttons because they are easy to mount directly on the breadboard. They provide ideal \"Mode Programming\" buttons to put the microcontroller into a programming mode. Switches These are ideal for turning your project boxes on and off. Small 0.96\" OLED displays We love these low-cost 128X64 OLED displays. They are bright and draw very little power. There are two different connectors: 4-wire I2C and 7-wire SPI. I would suggest the simpler I2C for most starter projects. EBay: 0.96\" OLED LCD Display Module IIC I2C Interface 128x64 For SSD1306 Amazon: Five OLED displays for $7 Larger 2.42\" OLEDs For our robot projects our students like to view the values from a distance. For them we use these $17 OLED displays that are about twice the size. 2.42\" OLED Display wired with SPI Non-rechargeable AA and AAA Battery Packs Rechargeable Battery Packs If you are work on project that need long-lasting portable power such as LED strip costumes, there are a wide variety of long-lasting rechargeable battery packs available from prices around $9 to $15. My favorites are ones that have percentage of power remaining displayed. Ultrasonic Distance Sensors These inexpensive \"ping\" sensors are used in many robot projects. HC-SR04 Ultrasonic Distance Sensor - $1 on eBay Motor Controllers We like two motor three wheel robots in our classrooms. They need a H-Bridge circuit for controlling the motor direction. The popular L293D chip takes four PWM signals and will use these to drive two 3-12v DC motors. The L293D chip can be mounted directly on your breadboard. However, we like the low-cost Mini motor controller boards that are only $2 that also have handy screw headers for easily attaching and removing the motor and power wires. Here are the specs: Here Input DC 4.5-36V 600mA output per channel (per motor) See section 4.4 in the Raspberry Pi Pico Datasheet on the Powerchain - note that the input VSYS, the main system input voltage, is only designed to go up to up to 5.5 volts. VSYS feeds the RVT6150 buck-boost SMPS. Mini Motor Drive Shield Expansion Board L293D Module For Arduino UNO MEGA2560 R3 $3 [Amazon 3 motor drives for $7] L293 Datasheet Banggood L293D Motor Drive Module Parshavele ST Microelectronics L78M Datasheet Datasheet for 78M05 Voltage Datasheet for ST 78M05 Voltage Regulators Note that the L293D Mini Motor Drive shield also has a voltage regulator that delivers a constant 5 volt signal to the robot microcontroller.","title":"Sourcing Parts"},{"location":"getting-started/03-suggested-parts/#sourcing-parts","text":"One of the key values of CoderDojo clubs around the world is to not charge any fees for attending these clubs. Parts need to be purchase by limited funds raised through donations. Club organizers need to be frugal about getting low-cost parts for the participants. Our experience is that is difficult to get the right parts at low cost using firms that promise quick delivery times of a few days. The lowest price parts often must be purchased weeks in advance from places like China and Taiwan. As a result, clubs that use funds carefully must plan weeks if not months in advance of classes and events. So we strongly suggest bringing an robot part procurement team together two months before you begin to offer robot courses where students can each have their own robots.","title":"Sourcing Parts"},{"location":"getting-started/03-suggested-parts/#purchasing-the-raspberry-pi-kits","text":"As of June 2021, the Raspberry Pi Pico did not come integrated into low-cost development kits that include robot kit parts. You frequently must to purchase the independent parts yourself. Here are some of the parts we recommend.","title":"Purchasing The Raspberry Pi Kits"},{"location":"getting-started/03-suggested-parts/#the-raspberry-pi-pico","text":"In the US, our best source of these has been Microcenter stores. They sell them for $3.99 and they often have them on sale for $1.99. Microcenter Pico Part Listing Microcenter has around 25 Locations in the US.","title":"The Raspberry Pi Pico"},{"location":"getting-started/03-suggested-parts/#usb-cable","text":"For a Mac with USB-C connectors, you will need to get a USB micro to C cable: Ebay USB 3.1 USB C Type C to Micro USB Male Sync OTG Charge Data Transfers Adapters Sample 1 meter USB cable on eBay for $2.40.","title":"USB Cable"},{"location":"getting-started/03-suggested-parts/#headers","text":"We need male breakaway headers with standard 1/10th inch spacing. The Raspberry Pi Pico will need 20 pins on each side. If you get 40-pin versions they can easily be broken in half. EBay: Ebay 40-Pin Male Header 0.1\" 2.54mm Breadboard PCB Strip Connectors 5pc - these ship from China in a few weeks and you can get five of them for $1 (including shipping). Amazon: Amazon MCIGICM 10pcs Male Header Pin, 40 Pin Header Strip (2.54 mm) for Arduino Connector","title":"Headers"},{"location":"getting-started/03-suggested-parts/#solderless-breadboards","text":"We like the 1/2 size boards that have 400 connection points. We like to mount them with the USB connector at the top with the numbers running down the left side to align with the pin numbers. EBay: Solderless Breadboard 400 Point Tie Prototype Test Bread Board PCB For Arduino Amazon: Amazon 4 Pieces for $6","title":"Solderless Breadboards"},{"location":"getting-started/03-suggested-parts/#hookup-wire","text":"Use 22 gauge wire. Get a large spool of black and red and smaller spools of other colors.","title":"Hookup Wire"},{"location":"getting-started/03-suggested-parts/#male-to-male-breadboard-jumper-wires","text":"You can use 22 gauge wire to build your projects, however kids that don't have fine motor skills sometimes get frustrated with raw wires. You can purchase a Jumper Wire Kit with 65 jumpers on EBay for under $2 that has nice plastic ends that are easier to use. Ebay: 65pcs Jumper Wire cable kit for Solderless Breadboard New - 65 of various lengths for $1.50 Ebay: 65X 65PCS Jumper Wire Cable Kit For Solderless Breadboard Amazon: ZYAMY 195pcs Breadboard Jumper Wire 12cm 16cm 20cm 24cm Solderless Flexible Breadboard Connecting Line Cables Male to Male Breadboard Jumpers (65pcs/Set x 3) - three packs of 65 for about $8","title":"Male-to-Male Breadboard Jumper Wires"},{"location":"getting-started/03-suggested-parts/#momentary-press-buttons","text":"A B3F Momentary Press Button with a blue cap. Note the schematic in the lower right corner that shows the internal connections of the button. We like the B3F-4055 12 x12x7.3mm Tactile Switch Momentary Press Buttons that have small dimples on the bottom that fit into the breadboard center trough. They can be purchased for under 10 cents per unit on eBay. You can by them with our without colored caps. The links below have example listings on eBay. eBay Tactile Push Button Switch Momentary Tact & Cap 12x12x7.3mm Assorted Kit - this kit includes 15 switchs with seven colors of caps for US $8.95. eBay: 10PCS New B3F Tactile Switch Key Button Switch 12x12x7.3mm Blue eBay 100PCS B3F-4055 Tactile Switch W/ OMRON Tact Push Button Momentary 12 x12 x7.3mm eBay Button Caps 140PCS Round Tactile Button Cap Kits 9.58 5.1mm for 12 12*7.3mm Tact Switch","title":"Momentary Press Buttons"},{"location":"getting-started/03-suggested-parts/#sensor-kit","text":"Although not all of these items are really \"sensors\" (some are displays), these kits provide high value at a low price-per item cost. Note that some of these kits contain tilt switches that contain Mercery. I remove these from the kits. EBay 16 Sensor Kit Raspberry Pi / Arduino Sensor Kit 16 Modules Package 16 kinds of sensor EBay 45 Sensor Kit for $18 US 45 In 1 Sensor Module Starter Kit Updated Set For Arduino Raspberry Pi Education HiLetgo 37 Sensors Assortment Kit 37 Sensors Kit Sensor Starter Kit for Arduino Raspberry pi Sensor kit 37 in 1 Robot Projects Starter Kits for Arduino Raspberry pi","title":"Sensor Kit"},{"location":"getting-started/03-suggested-parts/#linear-10k-potentiometers","text":"We use linear 10K potentiometers in many labs and kits. The pre-wired options are very handy but you will need some male-to-male jumpers. EBay: Pre-wired Potentiometer with Knob EBay: 10 10K Pots for $2.29 Amazon: 10K Pot Kit with 8 pots and knobs for $8","title":"Linear 10K Potentiometers"},{"location":"getting-started/03-suggested-parts/#momentary-press-buttons_1","text":"We like these small momentary press buttons because they are easy to mount directly on the breadboard. They provide ideal \"Mode Programming\" buttons to put the microcontroller into a programming mode.","title":"Momentary Press Buttons"},{"location":"getting-started/03-suggested-parts/#switches","text":"These are ideal for turning your project boxes on and off.","title":"Switches"},{"location":"getting-started/03-suggested-parts/#small-096-oled-displays","text":"We love these low-cost 128X64 OLED displays. They are bright and draw very little power. There are two different connectors: 4-wire I2C and 7-wire SPI. I would suggest the simpler I2C for most starter projects. EBay: 0.96\" OLED LCD Display Module IIC I2C Interface 128x64 For SSD1306 Amazon: Five OLED displays for $7","title":"Small 0.96\" OLED displays"},{"location":"getting-started/03-suggested-parts/#larger-242-oleds","text":"For our robot projects our students like to view the values from a distance. For them we use these $17 OLED displays that are about twice the size. 2.42\" OLED Display wired with SPI","title":"Larger 2.42\" OLEDs"},{"location":"getting-started/03-suggested-parts/#non-rechargeable-aa-and-aaa-battery-packs","text":"","title":"Non-rechargeable AA and AAA Battery Packs"},{"location":"getting-started/03-suggested-parts/#rechargeable-battery-packs","text":"If you are work on project that need long-lasting portable power such as LED strip costumes, there are a wide variety of long-lasting rechargeable battery packs available from prices around $9 to $15. My favorites are ones that have percentage of power remaining displayed.","title":"Rechargeable Battery Packs"},{"location":"getting-started/03-suggested-parts/#ultrasonic-distance-sensors","text":"These inexpensive \"ping\" sensors are used in many robot projects. HC-SR04 Ultrasonic Distance Sensor - $1 on eBay","title":"Ultrasonic Distance Sensors"},{"location":"getting-started/03-suggested-parts/#motor-controllers","text":"We like two motor three wheel robots in our classrooms. They need a H-Bridge circuit for controlling the motor direction. The popular L293D chip takes four PWM signals and will use these to drive two 3-12v DC motors. The L293D chip can be mounted directly on your breadboard. However, we like the low-cost Mini motor controller boards that are only $2 that also have handy screw headers for easily attaching and removing the motor and power wires. Here are the specs: Here Input DC 4.5-36V 600mA output per channel (per motor) See section 4.4 in the Raspberry Pi Pico Datasheet on the Powerchain - note that the input VSYS, the main system input voltage, is only designed to go up to up to 5.5 volts. VSYS feeds the RVT6150 buck-boost SMPS. Mini Motor Drive Shield Expansion Board L293D Module For Arduino UNO MEGA2560 R3 $3 [Amazon 3 motor drives for $7] L293 Datasheet Banggood L293D Motor Drive Module Parshavele ST Microelectronics L78M Datasheet Datasheet for 78M05 Voltage Datasheet for ST 78M05 Voltage Regulators Note that the L293D Mini Motor Drive shield also has a voltage regulator that delivers a constant 5 volt signal to the robot microcontroller.","title":"Motor Controllers"},{"location":"getting-started/10-displays/","text":"Adding A Display to Your Project In the past, the memory available in an standard Arduino Uno (2K bytes) was too small to add high quality displays. With the arrival of the ESP32 and the Raspberry Pi Pico this has all changed. These microcontrollers have around 100 times that RAM - typically around 200K bytes. So we are integrating low-cost OLED displays into many of our CoderDojo projects! Display Types There are four main types of display technology that use for small microcontrollers. LED - Light Emitting Diode - these are often low-resolution but have larger area. The start with single color displays but there are also multi-color LED strips and LED matrix displays. OLED - Organic Light Emitting Diode - small low-cost and high-contrast monochrome displays used in watches. LCD - Liquid Crystal Display - many of these are monochrome displays that must have precise power to get consistent contrast. TFT - Thin Film Transistor - a type of LCD that are used for larger color screens. 240X240 TFT Display Full Color LCD TFT Display SPI HD 65K Module ST7735 Concepts Before you begin to use these displays, there are a few things to understand to use them effectively. Based on your project needs, you can use this knowledge to find the right solution for you. Framebuffers A framebuffer is a copy of the display information that is resident within the RAM of the microcontroller. It must be as large as the display. For a 128X64 monochrome display this would be 128 * 64 = 8192 bits or 1,024 bytes (1K). A full color 240X240 TFT which uses 8 bits for red, green and blue would require 3 X 8 X 240 X 240 = 1,382,400 bits or 172K bytes. Not all all displays need framebuffers. Some displays can take a series of vector drawing commands such as \"draw line\" and \"draw text\". These displays can be useful if you don't have a large amount of RAM. Display Chip Types There are two common versions: SSD1306 - This is the most popular and versatile chip. It can be used to drive many different types and sizes of OLEDs. The SSD1306 can be used with both the simple 4 wire I2C interface as well as the slightly faster 7 wire SPI interface. These devices have only four wires labeled VCC, GND, SDA and SCL. SDA is for data and SCL is for the clock. SH1106 - This is less popular version and supports the 4-wire I2C interface. ST7735 - This chip is used on larger color TFT displays. ILI9341 - This chip is used on larger TDF displays. You can usually look on the back of the display device and see what type of check controls your OLED display. Communication Protocols In addition to the multiple types of displays and types of chips driving the displays, there are also two options on how you want to communicate between your microcontroller and the display. I2C - This is the most common type and only requires two wires beside power and ground. Us this as your default unless you display does not support it. The original specification of I2C had a communication speed of 100K bits per second. Many systems can be run at 400K per second. SPI - This is a more complex interface and requires up to seven wires. Some devices only support SPI interfaces. SPI typically runs around 1M bits/second although it can go up to 10M bits/second in some applications. SPI is ideal when you want to transfer a large amount of display data to a screen quickly. Basic Draw Functions For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function. Initializing the Framebuffer Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following: Full list of Drawing Functions Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state is 0=off (black) and 1=on (white). Function Description Example blit fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x1, x2, y, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert invert the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel Draw a single point on the screen rect Draw an empty rectangle scroll Scroll the display text Write text at a point vline Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display Initialize the display write_cmd Write a command to the display show Update the display from the frame buffer poweroff poweron contrast write_data Interfaces I2C Pros: Simple four wire interface Pin Purpose Description SPI Example: 128X64 pixel monochrome displays Types of Displays Summary Table Display Type Cost Links Notes LCD OLED TFT Displays References ST7735 Micropython Driver by Anthony Norman","title":"Displays"},{"location":"getting-started/10-displays/#adding-a-display-to-your-project","text":"In the past, the memory available in an standard Arduino Uno (2K bytes) was too small to add high quality displays. With the arrival of the ESP32 and the Raspberry Pi Pico this has all changed. These microcontrollers have around 100 times that RAM - typically around 200K bytes. So we are integrating low-cost OLED displays into many of our CoderDojo projects!","title":"Adding A Display to Your Project"},{"location":"getting-started/10-displays/#display-types","text":"There are four main types of display technology that use for small microcontrollers. LED - Light Emitting Diode - these are often low-resolution but have larger area. The start with single color displays but there are also multi-color LED strips and LED matrix displays. OLED - Organic Light Emitting Diode - small low-cost and high-contrast monochrome displays used in watches. LCD - Liquid Crystal Display - many of these are monochrome displays that must have precise power to get consistent contrast. TFT - Thin Film Transistor - a type of LCD that are used for larger color screens. 240X240 TFT Display Full Color LCD TFT Display SPI HD 65K Module ST7735","title":"Display Types"},{"location":"getting-started/10-displays/#concepts","text":"Before you begin to use these displays, there are a few things to understand to use them effectively. Based on your project needs, you can use this knowledge to find the right solution for you.","title":"Concepts"},{"location":"getting-started/10-displays/#framebuffers","text":"A framebuffer is a copy of the display information that is resident within the RAM of the microcontroller. It must be as large as the display. For a 128X64 monochrome display this would be 128 * 64 = 8192 bits or 1,024 bytes (1K). A full color 240X240 TFT which uses 8 bits for red, green and blue would require 3 X 8 X 240 X 240 = 1,382,400 bits or 172K bytes. Not all all displays need framebuffers. Some displays can take a series of vector drawing commands such as \"draw line\" and \"draw text\". These displays can be useful if you don't have a large amount of RAM.","title":"Framebuffers"},{"location":"getting-started/10-displays/#display-chip-types","text":"There are two common versions: SSD1306 - This is the most popular and versatile chip. It can be used to drive many different types and sizes of OLEDs. The SSD1306 can be used with both the simple 4 wire I2C interface as well as the slightly faster 7 wire SPI interface. These devices have only four wires labeled VCC, GND, SDA and SCL. SDA is for data and SCL is for the clock. SH1106 - This is less popular version and supports the 4-wire I2C interface. ST7735 - This chip is used on larger color TFT displays. ILI9341 - This chip is used on larger TDF displays. You can usually look on the back of the display device and see what type of check controls your OLED display.","title":"Display Chip Types"},{"location":"getting-started/10-displays/#communication-protocols","text":"In addition to the multiple types of displays and types of chips driving the displays, there are also two options on how you want to communicate between your microcontroller and the display. I2C - This is the most common type and only requires two wires beside power and ground. Us this as your default unless you display does not support it. The original specification of I2C had a communication speed of 100K bits per second. Many systems can be run at 400K per second. SPI - This is a more complex interface and requires up to seven wires. Some devices only support SPI interfaces. SPI typically runs around 1M bits/second although it can go up to 10M bits/second in some applications. SPI is ideal when you want to transfer a large amount of display data to a screen quickly.","title":"Communication Protocols"},{"location":"getting-started/10-displays/#basic-draw-functions","text":"For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function.","title":"Basic Draw Functions"},{"location":"getting-started/10-displays/#initializing-the-framebuffer","text":"Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following:","title":"Initializing the Framebuffer"},{"location":"getting-started/10-displays/#full-list-of-drawing-functions","text":"Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state is 0=off (black) and 1=on (white). Function Description Example blit fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x1, x2, y, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert invert the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel Draw a single point on the screen rect Draw an empty rectangle scroll Scroll the display text Write text at a point vline Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display Initialize the display write_cmd Write a command to the display show Update the display from the frame buffer poweroff poweron contrast write_data","title":"Full list of Drawing Functions"},{"location":"getting-started/10-displays/#interfaces","text":"","title":"Interfaces"},{"location":"getting-started/10-displays/#i2c","text":"Pros: Simple four wire interface Pin Purpose Description","title":"I2C"},{"location":"getting-started/10-displays/#spi","text":"Example: 128X64 pixel monochrome displays","title":"SPI"},{"location":"getting-started/10-displays/#types-of-displays","text":"","title":"Types of Displays"},{"location":"getting-started/10-displays/#summary-table","text":"Display Type Cost Links Notes","title":"Summary Table"},{"location":"getting-started/10-displays/#lcd","text":"","title":"LCD"},{"location":"getting-started/10-displays/#oled","text":"","title":"OLED"},{"location":"getting-started/10-displays/#tft-displays","text":"","title":"TFT Displays"},{"location":"getting-started/10-displays/#references","text":"ST7735 Micropython Driver by Anthony Norman","title":"References"},{"location":"intro/01-intro/","text":"Introduction to MicroPython This lesson assumes that you have at least skimmed the Getting Started sections and have selected one of the MicroPython IDEs to write your code. The lesson will introduce you to the basic concepts of using MicroPython using the $4 Raspberry Pi Pico or a similar microcontroller. The first two examples just use the Raspberry Pi Pico and don't require a breadboard or wiring. All the subsequent examples will require you to place components on a solderless breadboard.","title":"Introduction"},{"location":"intro/01-intro/#introduction-to-micropython","text":"This lesson assumes that you have at least skimmed the Getting Started sections and have selected one of the MicroPython IDEs to write your code. The lesson will introduce you to the basic concepts of using MicroPython using the $4 Raspberry Pi Pico or a similar microcontroller. The first two examples just use the Raspberry Pi Pico and don't require a breadboard or wiring. All the subsequent examples will require you to place components on a solderless breadboard.","title":"Introduction to MicroPython"},{"location":"intro/02-breadboards/","text":"Breadboards We use standard solderless mini breadboards in our labs. The breadboards have holes that are spaced 1/10th of an inch apart which is a standard for most electronics in the US. Our breadboards are usually 1/2 size with 400-ties. They have a central trough and power rails on the left and right edges. Breadboard Regions and Connections Learning how a breadboard works is critical for building your projects. In the figure above you will see that there are two types of regions of the breadboard The side regions are called the power distribution rails. They are similar to power lines that reach across our projects. The central region is call the row connector region. In this area the horizontal rows are all connected inside the breadboard. Within any row, columns a, b, c, d and e are all electrically connected. Within any row, columns f, h, i, j, and k are also electrically connected. However, there is a gap between columns e and f called the center gap or component slot that parts are usually placed over. Components like buttons and chips usually have their pins straddle the component slot. Pico Placement on Breadboard For most of our labs we place the Pico so that pin 1 of the Pico is in row 1 of the breadboard as in the image below. This means that the GND connections to the Pico are always in rows 3, 8, 13 and 18 on both sides of the breadboard. One of the ground pins is usually hooked up to the vertical blue power rails on the sides of the breadboard. Pico Placement Annotations GND are the ground connections. There are VBUS is the 5V power from the USB and is high only when the USB is connected. This is nominally 5V (or 0V if the USB is not connected or not powered). VSYS (also know and Voltage System Input) is the main system input voltage. When the Pico is disconnected from the USB you apply power to the Voltage System Input. The input can vary in the allowed range 1.8V to 5.5V, and is used by the on-board SMPS to generate the 3.3V for the RP2040 and its GPIO connections. When the input voltage is less than 3.3 volts the Pico uses an internal DC voltage Boost converter to get the correct voltage to the processor. 3V3_EN connects to the on-board SMPS enable pin, and is pulled high (to VSYS) via a 100K resistor. To disable the 3.3V (which also de-powers the RP2040), short this pin low. In effect by making the 3V3_EN LOW you are turning off the Pico. Breadboard Connections","title":"Breadboards"},{"location":"intro/02-breadboards/#breadboards","text":"We use standard solderless mini breadboards in our labs. The breadboards have holes that are spaced 1/10th of an inch apart which is a standard for most electronics in the US. Our breadboards are usually 1/2 size with 400-ties. They have a central trough and power rails on the left and right edges.","title":"Breadboards"},{"location":"intro/02-breadboards/#breadboard-regions-and-connections","text":"Learning how a breadboard works is critical for building your projects. In the figure above you will see that there are two types of regions of the breadboard The side regions are called the power distribution rails. They are similar to power lines that reach across our projects. The central region is call the row connector region. In this area the horizontal rows are all connected inside the breadboard. Within any row, columns a, b, c, d and e are all electrically connected. Within any row, columns f, h, i, j, and k are also electrically connected. However, there is a gap between columns e and f called the center gap or component slot that parts are usually placed over. Components like buttons and chips usually have their pins straddle the component slot.","title":"Breadboard Regions and Connections"},{"location":"intro/02-breadboards/#pico-placement-on-breadboard","text":"For most of our labs we place the Pico so that pin 1 of the Pico is in row 1 of the breadboard as in the image below. This means that the GND connections to the Pico are always in rows 3, 8, 13 and 18 on both sides of the breadboard. One of the ground pins is usually hooked up to the vertical blue power rails on the sides of the breadboard.","title":"Pico Placement on Breadboard"},{"location":"intro/02-breadboards/#pico-placement-annotations","text":"GND are the ground connections. There are VBUS is the 5V power from the USB and is high only when the USB is connected. This is nominally 5V (or 0V if the USB is not connected or not powered). VSYS (also know and Voltage System Input) is the main system input voltage. When the Pico is disconnected from the USB you apply power to the Voltage System Input. The input can vary in the allowed range 1.8V to 5.5V, and is used by the on-board SMPS to generate the 3.3V for the RP2040 and its GPIO connections. When the input voltage is less than 3.3 volts the Pico uses an internal DC voltage Boost converter to get the correct voltage to the processor. 3V3_EN connects to the on-board SMPS enable pin, and is pulled high (to VSYS) via a 100K resistor. To disable the 3.3V (which also de-powers the RP2040), short this pin low. In effect by making the 3V3_EN LOW you are turning off the Pico.","title":"Pico Placement Annotations"},{"location":"intro/02-breadboards/#breadboard-connections","text":"","title":"Breadboard Connections"},{"location":"intro/03-blink/","text":"Blink in Micropython Overview In this lab, we will use Micropython to make an LED blink on and off using Python. We will assume that an LED is connected to pin GIO16 and is connected via a 330 ohm resistor to ground. Virual Lab Unicorn Emulator Sample Program This program has two parts. The first part is often called the preamble - this code gets executed once and loads the right libraries and initializes global variables. The second part is the main event loop. This program continues to run until the device is powered down or reset. The import machine statement is required to define the characteristics of our physical machine. The import time library is required for the python sleep function. Blinking the Builtin LED This lab is the perfect place to start since you only need the Pico and a micro USB cable. The pico has a single built in LED wired to GPIO 25. This program will blink the built-in LED on and off every 1/4 of a second. 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( . 25 ) If you save the file as main.py, this program will run when the pico starts up without the BOOTSEL being pressed. Here is the code that will blink an LED that is connected to PIN GIO16, which is in the upper right corner of the Pico. 1 2 3 4 5 6 7 8 9 10 11 import machine import time # upper right corner pin with USB on the left led = machine . Pin ( 16 , machine . Pin . OUT ) # loop forever while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( 5 )","title":"Blink"},{"location":"intro/03-blink/#blink-in-micropython","text":"","title":"Blink in Micropython"},{"location":"intro/03-blink/#overview","text":"In this lab, we will use Micropython to make an LED blink on and off using Python. We will assume that an LED is connected to pin GIO16 and is connected via a 330 ohm resistor to ground.","title":"Overview"},{"location":"intro/03-blink/#virual-lab","text":"Unicorn Emulator","title":"Virual Lab"},{"location":"intro/03-blink/#sample-program","text":"This program has two parts. The first part is often called the preamble - this code gets executed once and loads the right libraries and initializes global variables. The second part is the main event loop. This program continues to run until the device is powered down or reset. The import machine statement is required to define the characteristics of our physical machine. The import time library is required for the python sleep function.","title":"Sample Program"},{"location":"intro/03-blink/#blinking-the-builtin-led","text":"This lab is the perfect place to start since you only need the Pico and a micro USB cable. The pico has a single built in LED wired to GPIO 25. This program will blink the built-in LED on and off every 1/4 of a second. 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( . 25 ) If you save the file as main.py, this program will run when the pico starts up without the BOOTSEL being pressed. Here is the code that will blink an LED that is connected to PIN GIO16, which is in the upper right corner of the Pico. 1 2 3 4 5 6 7 8 9 10 11 import machine import time # upper right corner pin with USB on the left led = machine . Pin ( 16 , machine . Pin . OUT ) # loop forever while True : led . high () time . sleep ( 0.5 ) led . low () time . sleep ( 0.5 ) 1 2 3 4 5 6 import machine import utime led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) while True : led_onboard . toggle () utime . sleep ( 5 )","title":"Blinking the Builtin LED"},{"location":"intro/03-button/","text":"Button In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. We will use it to toggle the built-in LED. In the example above, we are connecting the button on the left to the lower-left corner pin of the Raspberry Pi Pico. This is GPIO Pin 15 and is in row number 20 of our breadboard . Momentary Switch Buttons We use \"B3F\" tactile switch buttons that can be mounted directly on our breadboards. When the button is pressed, it connects a wire that joins two pins on one side to the two pins on the other side. The buttons can be mounted directly over the trough in the center of the breadboard. They typically cost under $2 for 10 buttons. Sample Code 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin import time # GPIO is the internal built-in LED led = Pin ( 25 , Pin . OUT ) button = Pin ( 15 , Pin . IN , Pin . PULL_DOWN ) # input with pull down resistor while True : if button . value (): # if the value changes led . toggle () time . sleep ( 0.1 ) # wait 1/10th of a second References Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video Switchs with trough pins Sample B3F Button on eBay 10 pieces for $1.50","title":"Buttons"},{"location":"intro/03-button/#button","text":"In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. We will use it to toggle the built-in LED. In the example above, we are connecting the button on the left to the lower-left corner pin of the Raspberry Pi Pico. This is GPIO Pin 15 and is in row number 20 of our breadboard .","title":"Button"},{"location":"intro/03-button/#momentary-switch-buttons","text":"We use \"B3F\" tactile switch buttons that can be mounted directly on our breadboards. When the button is pressed, it connects a wire that joins two pins on one side to the two pins on the other side. The buttons can be mounted directly over the trough in the center of the breadboard. They typically cost under $2 for 10 buttons.","title":"Momentary Switch Buttons"},{"location":"intro/03-button/#sample-code","text":"1 2 3 4 5 6 7 8 9 10 11 from machine import Pin import time # GPIO is the internal built-in LED led = Pin ( 25 , Pin . OUT ) button = Pin ( 15 , Pin . IN , Pin . PULL_DOWN ) # input with pull down resistor while True : if button . value (): # if the value changes led . toggle () time . sleep ( 0.1 ) # wait 1/10th of a second","title":"Sample Code"},{"location":"intro/03-button/#references","text":"Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video Switchs with trough pins Sample B3F Button on eBay 10 pieces for $1.50","title":"References"},{"location":"intro/03-temperature/","text":"Using the Builtin Temperature Sensor Reading the temperature 1 2 3 4 5 6 7 8 import machine import utime sensor_temp = machine . ADC ( 4 ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 print ( temperature ) print ( ' \\n ' ) Logging the Temperature 1 2 3 4 5 6 7 8 9 10 11 import machine import utime sensor_temp = machine . ADC ( machine . ADC . CORE_TEMP ) conversion_factor = 3.3 / ( 65535 ) file = open ( \"temps.txt\" , \"w\" ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 file . write ( str ( temperature )) file . flush () utime . sleep ( 10 )","title":"Temperature"},{"location":"intro/03-temperature/#using-the-builtin-temperature-sensor","text":"","title":"Using the Builtin Temperature Sensor"},{"location":"intro/03-temperature/#reading-the-temperature","text":"1 2 3 4 5 6 7 8 import machine import utime sensor_temp = machine . ADC ( 4 ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 print ( temperature ) print ( ' \\n ' )","title":"Reading the temperature"},{"location":"intro/03-temperature/#logging-the-temperature","text":"1 2 3 4 5 6 7 8 9 10 11 import machine import utime sensor_temp = machine . ADC ( machine . ADC . CORE_TEMP ) conversion_factor = 3.3 / ( 65535 ) file = open ( \"temps.txt\" , \"w\" ) while True : reading = sensor_temp . read_u16 () * conversion_factor temperature = 27 - ( reading - 0.706 ) / 0.001721 file . write ( str ( temperature )) file . flush () utime . sleep ( 10 )","title":"Logging the Temperature"},{"location":"intro/04-motor/","text":"Driving a Motor with the Pico The Pico has 26 general purpose input and output pins. However, each pin's power is designed to digitally communicate with other devices and has a limited current capacity of around 17 milliamps according to the Raspberry Pi Pico Datasheet Table 5 . The solution is to either use the digital output signal to turn on and off a switch such as a transistor of to use a motor driver chip such as an L293D chip. Basic Transistor Circuit Transistor NPN 2222A Diode: 1N1448 Motor: 3-6 volt hobby motor PWM Control PWM Frequency Set the frequency to 50Hz (one cycle per 20ms) and the duty value to between 51 (51/1023 * 20ms = 1ms) and 102 (102/1023 * 20ms = 2ms) Sample Coder 1 2 3 4 5 6 7 8 import machine # set the 7th from the bottom on right as our motor pin motor_pin = machine . Pin ( 21 , machine . Pin . OUT ) # allocate a PWM object for controlling the motor speed motor_pwm = machine . PWM ( motor_pin ) motor_pwm . freq ( 50 ) # 50 hertz motor_pwm . duty ( 51 ) References Sparkfun Motor Lab from SIK Kit Nick Zoic MicroPython Motor Control Tutorial","title":"Motor"},{"location":"intro/04-motor/#driving-a-motor-with-the-pico","text":"The Pico has 26 general purpose input and output pins. However, each pin's power is designed to digitally communicate with other devices and has a limited current capacity of around 17 milliamps according to the Raspberry Pi Pico Datasheet Table 5 . The solution is to either use the digital output signal to turn on and off a switch such as a transistor of to use a motor driver chip such as an L293D chip.","title":"Driving a Motor with the Pico"},{"location":"intro/04-motor/#basic-transistor-circuit","text":"Transistor NPN 2222A Diode: 1N1448 Motor: 3-6 volt hobby motor","title":"Basic Transistor Circuit"},{"location":"intro/04-motor/#pwm-control","text":"","title":"PWM Control"},{"location":"intro/04-motor/#pwm-frequency","text":"Set the frequency to 50Hz (one cycle per 20ms) and the duty value to between 51 (51/1023 * 20ms = 1ms) and 102 (102/1023 * 20ms = 2ms)","title":"PWM Frequency"},{"location":"intro/04-motor/#sample-coder","text":"1 2 3 4 5 6 7 8 import machine # set the 7th from the bottom on right as our motor pin motor_pin = machine . Pin ( 21 , machine . Pin . OUT ) # allocate a PWM object for controlling the motor speed motor_pwm = machine . PWM ( motor_pin ) motor_pwm . freq ( 50 ) # 50 hertz motor_pwm . duty ( 51 )","title":"Sample Coder"},{"location":"intro/04-motor/#references","text":"Sparkfun Motor Lab from SIK Kit Nick Zoic MicroPython Motor Control Tutorial","title":"References"},{"location":"intro/04-servo/","text":"Micropython Servo Lab TBD 1 2 3 4 5 6 7 import machine import pyb # The pyboard has four simple servo connections servo = pyb . Servo ( 1 ) servo . angle ( 90 , 5000 )","title":"Servo"},{"location":"intro/04-servo/#micropython-servo-lab","text":"TBD 1 2 3 4 5 6 7 import machine import pyb # The pyboard has four simple servo connections servo = pyb . Servo ( 1 ) servo . angle ( 90 , 5000 )","title":"Micropython Servo Lab"},{"location":"intro/05-led-strip/","text":"LED Strip Note The current version of the runtime (rp2-pico-20210205-unstable-v1.14-8-g1f800cac3) accidentally dropped the array module. To run this you will need to use this See issue Issue 6837: rp2 port no module named array . This should be fixed in a day or two. Feb. 20th, 2021. - Dan Circuit connections LED Strip Pico Name Pico Pin Description GND GND 3 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 1 Topmost left with USB on top Parameters 1 2 3 NUM_LEDS = 60 PIN_NUM = 1 brightness = 1 full code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 # Example using PIO to drive a set of WS2812 LEDs. import array , time from machine import Pin import rp2 # Configure the number of WS2812 LEDs. NUM_LEDS = 60 PIN_NUM = 22 brightness = 0.2 @rp2 . asm_pio ( sideset_init = rp2 . PIO . OUT_LOW , out_shiftdir = rp2 . PIO . SHIFT_LEFT , autopull = True , pull_thresh = 24 ) def ws2812 (): T1 = 2 T2 = 5 T3 = 3 wrap_target () label ( \"bitloop\" ) out ( x , 1 ) . side ( 0 ) [ T3 - 1 ] jmp ( not_x , \"do_zero\" ) . side ( 1 ) [ T1 - 1 ] jmp ( \"bitloop\" ) . side ( 1 ) [ T2 - 1 ] label ( \"do_zero\" ) nop () . side ( 0 ) [ T2 - 1 ] wrap () # Create the StateMachine with the ws2812 program, outputting on pin sm = rp2 . StateMachine ( 0 , ws2812 , freq = 8_000_000 , sideset_base = Pin ( PIN_NUM )) # Start the StateMachine, it will wait for data on its FIFO. sm . active ( 1 ) # Display a pattern on the LEDs via an array of LED RGB values. ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) ########################################################################## def pixels_show (): dimmer_ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) for i , c in enumerate ( ar ): r = int ((( c >> 8 ) & 0xFF ) * brightness ) g = int ((( c >> 16 ) & 0xFF ) * brightness ) b = int (( c & 0xFF ) * brightness ) dimmer_ar [ i ] = ( g << 16 ) + ( r << 8 ) + b sm . put ( dimmer_ar , 8 ) time . sleep_ms ( 10 ) def pixels_set ( i , color ): ar [ i ] = ( color [ 1 ] << 16 ) + ( color [ 0 ] << 8 ) + color [ 2 ] def pixels_fill ( color ): for i in range ( len ( ar )): pixels_set ( i , color ) def color_chase ( color , wait ): for i in range ( NUM_LEDS ): pixels_set ( i , color ) time . sleep ( wait ) pixels_show () time . sleep ( 0.2 ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait ): for j in range ( 255 ): for i in range ( NUM_LEDS ): rc_index = ( i * 256 // NUM_LEDS ) + j pixels_set ( i , wheel ( rc_index & 255 )) pixels_show () time . sleep ( wait ) BLACK = ( 0 , 0 , 0 ) RED = ( 255 , 0 , 0 ) YELLOW = ( 255 , 150 , 0 ) GREEN = ( 0 , 255 , 0 ) CYAN = ( 0 , 255 , 255 ) BLUE = ( 0 , 0 , 255 ) PURPLE = ( 180 , 0 , 255 ) WHITE = ( 255 , 255 , 255 ) COLORS = ( BLACK , RED , YELLOW , GREEN , CYAN , BLUE , PURPLE , WHITE ) print ( \"fills\" ) for color in COLORS : pixels_fill ( color ) pixels_show () time . sleep ( 0.2 ) print ( \"chases\" ) for color in COLORS : color_chase ( color , 0.01 ) print ( \"rainbow\" ) rainbow_cycle ( 0 ) References Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video rp2 port no module named array","title":"LED Strip"},{"location":"intro/05-led-strip/#led-strip","text":"Note The current version of the runtime (rp2-pico-20210205-unstable-v1.14-8-g1f800cac3) accidentally dropped the array module. To run this you will need to use this See issue Issue 6837: rp2 port no module named array . This should be fixed in a day or two. Feb. 20th, 2021. - Dan","title":"LED Strip"},{"location":"intro/05-led-strip/#circuit-connections","text":"LED Strip Pico Name Pico Pin Description GND GND 3 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 1 Topmost left with USB on top","title":"Circuit connections"},{"location":"intro/05-led-strip/#parameters","text":"1 2 3 NUM_LEDS = 60 PIN_NUM = 1 brightness = 1","title":"Parameters"},{"location":"intro/05-led-strip/#full-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 # Example using PIO to drive a set of WS2812 LEDs. import array , time from machine import Pin import rp2 # Configure the number of WS2812 LEDs. NUM_LEDS = 60 PIN_NUM = 22 brightness = 0.2 @rp2 . asm_pio ( sideset_init = rp2 . PIO . OUT_LOW , out_shiftdir = rp2 . PIO . SHIFT_LEFT , autopull = True , pull_thresh = 24 ) def ws2812 (): T1 = 2 T2 = 5 T3 = 3 wrap_target () label ( \"bitloop\" ) out ( x , 1 ) . side ( 0 ) [ T3 - 1 ] jmp ( not_x , \"do_zero\" ) . side ( 1 ) [ T1 - 1 ] jmp ( \"bitloop\" ) . side ( 1 ) [ T2 - 1 ] label ( \"do_zero\" ) nop () . side ( 0 ) [ T2 - 1 ] wrap () # Create the StateMachine with the ws2812 program, outputting on pin sm = rp2 . StateMachine ( 0 , ws2812 , freq = 8_000_000 , sideset_base = Pin ( PIN_NUM )) # Start the StateMachine, it will wait for data on its FIFO. sm . active ( 1 ) # Display a pattern on the LEDs via an array of LED RGB values. ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) ########################################################################## def pixels_show (): dimmer_ar = array . array ( \"I\" , [ 0 for _ in range ( NUM_LEDS )]) for i , c in enumerate ( ar ): r = int ((( c >> 8 ) & 0xFF ) * brightness ) g = int ((( c >> 16 ) & 0xFF ) * brightness ) b = int (( c & 0xFF ) * brightness ) dimmer_ar [ i ] = ( g << 16 ) + ( r << 8 ) + b sm . put ( dimmer_ar , 8 ) time . sleep_ms ( 10 ) def pixels_set ( i , color ): ar [ i ] = ( color [ 1 ] << 16 ) + ( color [ 0 ] << 8 ) + color [ 2 ] def pixels_fill ( color ): for i in range ( len ( ar )): pixels_set ( i , color ) def color_chase ( color , wait ): for i in range ( NUM_LEDS ): pixels_set ( i , color ) time . sleep ( wait ) pixels_show () time . sleep ( 0.2 ) def wheel ( pos ): # Input a value 0 to 255 to get a color value. # The colours are a transition r - g - b - back to r. if pos < 0 or pos > 255 : return ( 0 , 0 , 0 ) if pos < 85 : return ( 255 - pos * 3 , pos * 3 , 0 ) if pos < 170 : pos -= 85 return ( 0 , 255 - pos * 3 , pos * 3 ) pos -= 170 return ( pos * 3 , 0 , 255 - pos * 3 ) def rainbow_cycle ( wait ): for j in range ( 255 ): for i in range ( NUM_LEDS ): rc_index = ( i * 256 // NUM_LEDS ) + j pixels_set ( i , wheel ( rc_index & 255 )) pixels_show () time . sleep ( wait ) BLACK = ( 0 , 0 , 0 ) RED = ( 255 , 0 , 0 ) YELLOW = ( 255 , 150 , 0 ) GREEN = ( 0 , 255 , 0 ) CYAN = ( 0 , 255 , 255 ) BLUE = ( 0 , 0 , 255 ) PURPLE = ( 180 , 0 , 255 ) WHITE = ( 255 , 255 , 255 ) COLORS = ( BLACK , RED , YELLOW , GREEN , CYAN , BLUE , PURPLE , WHITE ) print ( \"fills\" ) for color in COLORS : pixels_fill ( color ) pixels_show () time . sleep ( 0.2 ) print ( \"chases\" ) for color in COLORS : color_chase ( color , 0.01 ) print ( \"rainbow\" ) rainbow_cycle ( 0 )","title":"full code"},{"location":"intro/05-led-strip/#references","text":"Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video rp2 port no module named array","title":"References"},{"location":"misc/30-colophon/","text":"Colophone We are mostly a group of unpaid volunteers without a large budget for distributed content management software. However, we still want to provide a great user experience for both our mentors and our students. So we use free open-source tools whenever we can. Here is how we built this site. Our content language is Markdown . We use Python Markdown to parse our content. We convert Markdown to HTML with mkdocs . Our user interface theme is Mkdocs Material . We use an extensive number of Material user interface components. Our software version control system is git Our site is hosted on GitHub page . We use standard code highlighting provided by the mkdocs codehilite extension. Our BY-NC-SA content license agreement is created by Creative Commons We wish to acknowledge the work of everyone that contributes to open-source projects. Without these systems this work would not be possible. If you would like to contribute lesson we welcome your contribution as a git pull request. You can read our CoderDojo Twin CitiesAuthoring Guide if you would like to help out.","title":"Colophon"},{"location":"misc/30-colophon/#colophone","text":"We are mostly a group of unpaid volunteers without a large budget for distributed content management software. However, we still want to provide a great user experience for both our mentors and our students. So we use free open-source tools whenever we can. Here is how we built this site. Our content language is Markdown . We use Python Markdown to parse our content. We convert Markdown to HTML with mkdocs . Our user interface theme is Mkdocs Material . We use an extensive number of Material user interface components. Our software version control system is git Our site is hosted on GitHub page . We use standard code highlighting provided by the mkdocs codehilite extension. Our BY-NC-SA content license agreement is created by Creative Commons We wish to acknowledge the work of everyone that contributes to open-source projects. Without these systems this work would not be possible. If you would like to contribute lesson we welcome your contribution as a git pull request. You can read our CoderDojo Twin CitiesAuthoring Guide if you would like to help out.","title":"Colophone"},{"location":"misc/contact/","text":"Cybersecurity for Kids Contacts General Code Savvy Contact kidscode@codesavvy.org Contact for CoderDojo Twin Cities hello@coderdojotc.org Specific questions on this repository Dan McCreary","title":"Contact"},{"location":"misc/contact/#cybersecurity-for-kids-contacts","text":"","title":"Cybersecurity for Kids Contacts"},{"location":"misc/contact/#general-code-savvy-contact","text":"kidscode@codesavvy.org","title":"General Code Savvy Contact"},{"location":"misc/contact/#contact-for-coderdojo-twin-cities","text":"hello@coderdojotc.org","title":"Contact for CoderDojo Twin Cities"},{"location":"misc/contact/#specific-questions-on-this-repository","text":"Dan McCreary","title":"Specific questions on this repository"},{"location":"misc/contributing/","text":"Micropython Book Contributing Guide The goal of this microsite is to provide micropython content to STEM educational programs around the world. We value inclusion and we love low-cost project that promote STEM instruction in communities that don't have large budgets. We value a focus on instructional design that teaches computational thinking and uses evidence of the effective delivery of this content to underprivileged communities. We welcome anyone that would like to add content to this microsite with the following guidelines: Contribution License Your content must be your own original content. We discourage copying bulk content from other sites without clear understanding of the copyrights that govern this content. We put a special focus on image attribution. Any images added must clearly state that the images are original content created by the author. You must agree to license your new original content to allow other teachers and mentors to reuse this content in their classrooms free of charge. We use Creative Commons Licenses Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) for all content in this microsite and other microsites managed by CoderDojo Twin Cities. Under these terms teachers and mentors are free to: Share \u2014 copy and redistribute the material in any medium or format Adapt \u2014 remix, transform, and build upon the material The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. NonCommercial \u2014 You may not use the material for commercial purposes. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Ways to Contribute Start out by helping us proof-read our content and help us find typos, spelling, lack-of clarity, and missing content. As you learn the style of our lessons you will be better able to contribute new lessons that have a similar style You may submit pull requests to this site of if you are not familiar with this process, you can add a link to your content in an issue. You may add an issue to our issues board here You are welcome to participate by looking for open tasks and using GitHub workflows to take on tasks to completion. Teaching Suggestions Avoid too much focus on building games that don't promote teaching computational thinking skills. Simple remote control robots might be fun, but sometime the fun of driving a robot around gets in the way of learning new concepts. Resources Please see our page on Teaching Computational Thinking .","title":"Contributing"},{"location":"misc/contributing/#micropython-book-contributing-guide","text":"The goal of this microsite is to provide micropython content to STEM educational programs around the world. We value inclusion and we love low-cost project that promote STEM instruction in communities that don't have large budgets. We value a focus on instructional design that teaches computational thinking and uses evidence of the effective delivery of this content to underprivileged communities. We welcome anyone that would like to add content to this microsite with the following guidelines:","title":"Micropython Book Contributing Guide"},{"location":"misc/contributing/#contribution-license","text":"Your content must be your own original content. We discourage copying bulk content from other sites without clear understanding of the copyrights that govern this content. We put a special focus on image attribution. Any images added must clearly state that the images are original content created by the author. You must agree to license your new original content to allow other teachers and mentors to reuse this content in their classrooms free of charge. We use Creative Commons Licenses Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) for all content in this microsite and other microsites managed by CoderDojo Twin Cities. Under these terms teachers and mentors are free to: Share \u2014 copy and redistribute the material in any medium or format Adapt \u2014 remix, transform, and build upon the material The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. NonCommercial \u2014 You may not use the material for commercial purposes. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.","title":"Contribution License"},{"location":"misc/contributing/#ways-to-contribute","text":"Start out by helping us proof-read our content and help us find typos, spelling, lack-of clarity, and missing content. As you learn the style of our lessons you will be better able to contribute new lessons that have a similar style You may submit pull requests to this site of if you are not familiar with this process, you can add a link to your content in an issue. You may add an issue to our issues board here You are welcome to participate by looking for open tasks and using GitHub workflows to take on tasks to completion.","title":"Ways to Contribute"},{"location":"misc/contributing/#teaching-suggestions","text":"Avoid too much focus on building games that don't promote teaching computational thinking skills. Simple remote control robots might be fun, but sometime the fun of driving a robot around gets in the way of learning new concepts.","title":"Teaching Suggestions"},{"location":"misc/contributing/#resources","text":"Please see our page on Teaching Computational Thinking .","title":"Resources"},{"location":"misc/glossary/","text":"Micropython Glossary of Terms Ampy A micropython command line utility to interact with a CircuitPython or MicroPython board over a serial connection. Ampy is meant to be a simple command line tool to manipulate files and run code on a CircuitPython or MicroPython board over its serial connection. With ampy you can send files from your computer to the board's file system, download files from a board to your computer, and even send a Python script to a board to be executed. Note that ampy by design is meant to be simple and does not support advanced interaction like a shell or terminal to send input to a board. Check out other MicroPython tools like rshell or mpfshell for more advanced interaction with boards. Analog to Digital Converter A component that takes an analogue signal and changes it to a digital one. Every ADC has two parameters, its resolution , measured in digital bits, and its channels , or how many analogue signals it can accept and convert at once. Also know as: ADC BOOTSEL A button on the pico that when pressed during power up will allow you to mount the device as a USB device. Also known as: Boot Selection Castellated Edge Plated through holes or vias located in the edges of a printed circuit board that make it easier to solder onto another circuit board. The word \"Castellated\" means having grooves or slots on an edge and is derived from the turrets of a castle. ESP32 A series of low-cost, low-power system on a chip microcontrollers with integrated Wi-Fi and dual-mode Bluetooth. Typical costs for the ESP32 is Sample on eBay $5 Sample on Amazon $11 Sample on Sparkfun $21 ESP32 Quick Reference Framebuffer A region of your microcontroller RAM that stores a bitmap image of your display. For a 128X64 monochrome display this would be 128 * 64 = 8,192 bits or 1,024 bytes (1K). Color displays must store up to 8 bytes per color for each color (red, green and blue). Wikipedia page on Framebuffer I2C A communications protocol common in microcontroller-based systems, particularly for interfacing with sensors, memory devices and liquid crystal displays. I2C is similar to SPI, it's a synchronous protocol because it uses a clock line. Also Known as: Inter-integrated Circuit See also: SPI Micropython A set of Python libraries and tools developed specifically for microcontrollers. Micropython was originally developed by Damien George and first released in 2014. It includes many of the features of mainstream Python, while adding a range of new ones designed to take advantage of the facilities available on Raspberry Pi Pico and other microcontroller boards like the ESP32. See also: CircuitPython MPG Shell A simple micropython shell based file explorer for ESP8266 and WiPy Micropython based devices. The shell is a helper for up/downloading files to the ESP8266 (over serial line and Websockets) and WiPy (serial line and telnet). It basically offers commands to list and upload/download files on the flash FS of the device. GitHub Repo for MPFShell OLED Organic polymer light emitting diode. Raspberry Pi Foundation The company that builds the Raspberry Pi hardware and provides some software. Raspberry Pi Pico A microcontroller designed by the Raspberry Pi foundation for doing real-time control systems. The Pico was introduces in 2020 with a retail list price of $4. It was a key development because it used a custom chip that had 100 times the RAM of an Arduino Nano. Pico Pinout The Pico pinout has Pinout PDF RP2040 chip A custom chip created by the Raspberry Pi Foundation to power the Raspberry Pi Pico . rshell A simple micropython shell which runs on the host and uses MicroPython's raw-REPL to send python snippets to the pyboard in order to get filesystem information, and to copy files to and from MicroPython's filesystem. It also has the ability to invoke the regular REPL, so rshell can be used as a terminal emulator as well. Note: With rshell you can disable USB Mass Storage and still copy files into and out of your pyboard. RShell GitHub Repo SPI An interface bus commonly used to send data between microcontrollers and small peripherals such as sensors, displays and SD cards. SPI uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Also known as: Serial Peripheral Interface See also: I2C Thonny A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny runs on Mac, Windows and Linux. Thonny web site UF2 File The file that must be uploaded into the Raspberry Pi Pico folder to allow it to be used. The file name format looks like this: rp2-pico-20210205-unstable-v1.14-8-g1f800cac3.uf2 Unicorn MicroPython on Unicorn is completely open source Micropython emulator Github Repo: https://github.com/micropython/micropython-unicorn","title":"Glossary"},{"location":"misc/glossary/#micropython-glossary-of-terms","text":"","title":"Micropython Glossary of Terms"},{"location":"misc/glossary/#ampy","text":"A micropython command line utility to interact with a CircuitPython or MicroPython board over a serial connection. Ampy is meant to be a simple command line tool to manipulate files and run code on a CircuitPython or MicroPython board over its serial connection. With ampy you can send files from your computer to the board's file system, download files from a board to your computer, and even send a Python script to a board to be executed. Note that ampy by design is meant to be simple and does not support advanced interaction like a shell or terminal to send input to a board. Check out other MicroPython tools like rshell or mpfshell for more advanced interaction with boards.","title":"Ampy"},{"location":"misc/glossary/#analog-to-digital-converter","text":"A component that takes an analogue signal and changes it to a digital one. Every ADC has two parameters, its resolution , measured in digital bits, and its channels , or how many analogue signals it can accept and convert at once. Also know as: ADC","title":"Analog to Digital Converter"},{"location":"misc/glossary/#bootsel","text":"A button on the pico that when pressed during power up will allow you to mount the device as a USB device. Also known as: Boot Selection","title":"BOOTSEL"},{"location":"misc/glossary/#castellated-edge","text":"Plated through holes or vias located in the edges of a printed circuit board that make it easier to solder onto another circuit board. The word \"Castellated\" means having grooves or slots on an edge and is derived from the turrets of a castle.","title":"Castellated Edge"},{"location":"misc/glossary/#esp32","text":"A series of low-cost, low-power system on a chip microcontrollers with integrated Wi-Fi and dual-mode Bluetooth. Typical costs for the ESP32 is Sample on eBay $5 Sample on Amazon $11 Sample on Sparkfun $21 ESP32 Quick Reference","title":"ESP32"},{"location":"misc/glossary/#framebuffer","text":"A region of your microcontroller RAM that stores a bitmap image of your display. For a 128X64 monochrome display this would be 128 * 64 = 8,192 bits or 1,024 bytes (1K). Color displays must store up to 8 bytes per color for each color (red, green and blue). Wikipedia page on Framebuffer","title":"Framebuffer"},{"location":"misc/glossary/#i2c","text":"A communications protocol common in microcontroller-based systems, particularly for interfacing with sensors, memory devices and liquid crystal displays. I2C is similar to SPI, it's a synchronous protocol because it uses a clock line. Also Known as: Inter-integrated Circuit See also: SPI","title":"I2C"},{"location":"misc/glossary/#micropython","text":"A set of Python libraries and tools developed specifically for microcontrollers. Micropython was originally developed by Damien George and first released in 2014. It includes many of the features of mainstream Python, while adding a range of new ones designed to take advantage of the facilities available on Raspberry Pi Pico and other microcontroller boards like the ESP32. See also: CircuitPython","title":"Micropython"},{"location":"misc/glossary/#mpg-shell","text":"A simple micropython shell based file explorer for ESP8266 and WiPy Micropython based devices. The shell is a helper for up/downloading files to the ESP8266 (over serial line and Websockets) and WiPy (serial line and telnet). It basically offers commands to list and upload/download files on the flash FS of the device. GitHub Repo for MPFShell","title":"MPG Shell"},{"location":"misc/glossary/#oled","text":"Organic polymer light emitting diode.","title":"OLED"},{"location":"misc/glossary/#raspberry-pi-foundation","text":"The company that builds the Raspberry Pi hardware and provides some software.","title":"Raspberry Pi Foundation"},{"location":"misc/glossary/#raspberry-pi-pico","text":"A microcontroller designed by the Raspberry Pi foundation for doing real-time control systems. The Pico was introduces in 2020 with a retail list price of $4. It was a key development because it used a custom chip that had 100 times the RAM of an Arduino Nano.","title":"Raspberry Pi Pico"},{"location":"misc/glossary/#pico-pinout","text":"The Pico pinout has Pinout PDF","title":"Pico Pinout"},{"location":"misc/glossary/#rp2040-chip","text":"A custom chip created by the Raspberry Pi Foundation to power the Raspberry Pi Pico .","title":"RP2040 chip"},{"location":"misc/glossary/#rshell","text":"A simple micropython shell which runs on the host and uses MicroPython's raw-REPL to send python snippets to the pyboard in order to get filesystem information, and to copy files to and from MicroPython's filesystem. It also has the ability to invoke the regular REPL, so rshell can be used as a terminal emulator as well. Note: With rshell you can disable USB Mass Storage and still copy files into and out of your pyboard. RShell GitHub Repo","title":"rshell"},{"location":"misc/glossary/#spi","text":"An interface bus commonly used to send data between microcontrollers and small peripherals such as sensors, displays and SD cards. SPI uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Also known as: Serial Peripheral Interface See also: I2C","title":"SPI"},{"location":"misc/glossary/#thonny","text":"A lightweight Python IDE ideal for writing simple Python programs for first time users. Thonny runs on Mac, Windows and Linux. Thonny web site","title":"Thonny"},{"location":"misc/glossary/#uf2-file","text":"The file that must be uploaded into the Raspberry Pi Pico folder to allow it to be used. The file name format looks like this: rp2-pico-20210205-unstable-v1.14-8-g1f800cac3.uf2","title":"UF2 File"},{"location":"misc/glossary/#unicorn","text":"MicroPython on Unicorn is completely open source Micropython emulator Github Repo: https://github.com/micropython/micropython-unicorn","title":"Unicorn"},{"location":"misc/mermaid-test/","text":"1 2 3 4 5 6 7 graph LR p[Pico] -->|ADC_VREF 36 row=6| pos(Positive) p[Pico] -->|AGND 33 row=8| neg(Negative) p[Pico] -->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) 1 2 3 graph LR MyApp --> DB(<font color=white>fa:fa-database MySQL) style DB fill:#00758f","title":"Render Test"},{"location":"misc/projects/","text":"CoderDojo MicroPython Projects Projects are groups lesson plans that need to work together and frequently build on other projects. Key project areas include: Sensors - find low cost sensors and create a lesson around them Robot Extensions - build extensions to our Base robot Sound and Music - add labs that generate sound and play music OLED Displays and Graphics - leverage the new low-cost OLED displays Debugging - build lesson plans to help student learn how to debug MicroPython programs and use logic analyzers Advanced Labs - using multiple cores, programming the IP processors, integrating C and assembly code Projects that a In Development Please connect with Dan McCreary if you are interested in helping out with these projects. Name Status Description Ping HC-SR04 50%) Create an OLED ping lab Motion Sensor 0% Create a lesson that uses a motion sensor. Use an OLED to display motion vs. time Photosensor 0% Create a lesson that will monitor light on a photo sensor DS18B Temp Sensor 0% Create a lesson that will read and display a waterproof temperature sensor JoyStick 0% Create a lesson that will read the X, Y and button of a JoyStick OLED JoyStick 0% Use a Joystick to move a ball around an OLED and paint pixels OLED Game of Life 0% Write a Game of Life with an OLED. Add a Joystick to paint initial conditions","title":"Projects"},{"location":"misc/projects/#coderdojo-micropython-projects","text":"Projects are groups lesson plans that need to work together and frequently build on other projects. Key project areas include: Sensors - find low cost sensors and create a lesson around them Robot Extensions - build extensions to our Base robot Sound and Music - add labs that generate sound and play music OLED Displays and Graphics - leverage the new low-cost OLED displays Debugging - build lesson plans to help student learn how to debug MicroPython programs and use logic analyzers Advanced Labs - using multiple cores, programming the IP processors, integrating C and assembly code","title":"CoderDojo MicroPython Projects"},{"location":"misc/projects/#projects-that-a-in-development","text":"Please connect with Dan McCreary if you are interested in helping out with these projects. Name Status Description Ping HC-SR04 50%) Create an OLED ping lab Motion Sensor 0% Create a lesson that uses a motion sensor. Use an OLED to display motion vs. time Photosensor 0% Create a lesson that will monitor light on a photo sensor DS18B Temp Sensor 0% Create a lesson that will read and display a waterproof temperature sensor JoyStick 0% Create a lesson that will read the X, Y and button of a JoyStick OLED JoyStick 0% Use a Joystick to move a ball around an OLED and paint pixels OLED Game of Life 0% Write a Game of Life with an OLED. Add a Joystick to paint initial conditions","title":"Projects that a In Development"},{"location":"misc/references/","text":"References for MicroPython Micropython References MicroPython Forum - a good place to ask questions about MicroPython. Mostly for hard core developers. MicroPython.org site - We would not recommend the PyBoard for beginners. They are over 10x more expensive than the the Raspberry Pi Pico. Spider Maf Github Repo Pico References MicroPython Firmware for the Raspberry Pi Pico - You will want to bookmark this site. It has the firmware required to run MicroPython on your Raspberry Pi Pico. As of March 2021, they are fixing bugs weekly, so you will want to make sure your firmware is current. Pico Launch Video on YouTube Raspberry Pi Web Site Project Search Pico Data Sheet - you will only need this for detailed information on how to use the Pico hardware. Meet Raspberry Silicon: Raspberry Pi Pico now on sale at $4 - The original Raspberry Pi Pico announcement. The journey to Raspberry Silicon - blog by Liam Fraser - Feb. 8th 2021. Nice story of how the Raspberry Pi Foundation created the custom silicon chip. TensorFlow Lite Micro for the Pico Pico Invaders Video YouTube video of Raspberry Pi driving a full color VGA screen - Full-speed high-fidelity BBC Micro emulation on a (slightly) overclocked Raspberry Pi Pico Raspberry Pi RP2040: Our Microcontroller for the Masses - James Adams, COO and Director of Hardware, Raspberry Pi ARM Blueprint post on TinyML - nice review of the Tiny Machine Learning possible on the ARM processor. Google TensorFlow engineer talking about how ARM and Google are working together on TinyML - short 60 second video clip of Google TensorFlow engineer Ian Nappier talking about how they are working with ARM to create a standard TinyML library for all ARM processors to use. Components Comparison of RP2040 Boards Components References 2.42\" OLED Display from DIY More","title":"References"},{"location":"misc/references/#references-for-micropython","text":"","title":"References for MicroPython"},{"location":"misc/references/#micropython-references","text":"MicroPython Forum - a good place to ask questions about MicroPython. Mostly for hard core developers. MicroPython.org site - We would not recommend the PyBoard for beginners. They are over 10x more expensive than the the Raspberry Pi Pico. Spider Maf Github Repo","title":"Micropython References"},{"location":"misc/references/#pico-references","text":"MicroPython Firmware for the Raspberry Pi Pico - You will want to bookmark this site. It has the firmware required to run MicroPython on your Raspberry Pi Pico. As of March 2021, they are fixing bugs weekly, so you will want to make sure your firmware is current. Pico Launch Video on YouTube Raspberry Pi Web Site Project Search Pico Data Sheet - you will only need this for detailed information on how to use the Pico hardware. Meet Raspberry Silicon: Raspberry Pi Pico now on sale at $4 - The original Raspberry Pi Pico announcement. The journey to Raspberry Silicon - blog by Liam Fraser - Feb. 8th 2021. Nice story of how the Raspberry Pi Foundation created the custom silicon chip. TensorFlow Lite Micro for the Pico Pico Invaders Video YouTube video of Raspberry Pi driving a full color VGA screen - Full-speed high-fidelity BBC Micro emulation on a (slightly) overclocked Raspberry Pi Pico Raspberry Pi RP2040: Our Microcontroller for the Masses - James Adams, COO and Director of Hardware, Raspberry Pi ARM Blueprint post on TinyML - nice review of the Tiny Machine Learning possible on the ARM processor. Google TensorFlow engineer talking about how ARM and Google are working together on TinyML - short 60 second video clip of Google TensorFlow engineer Ian Nappier talking about how they are working with ARM to create a standard TinyML library for all ARM processors to use.","title":"Pico References"},{"location":"misc/references/#components","text":"Comparison of RP2040 Boards","title":"Components"},{"location":"misc/references/#components-references","text":"2.42\" OLED Display from DIY More","title":"Components References"},{"location":"motors/01-intro/","text":"Using MicroPython to Control Motors and Servos Controlling motors are one of the funnest ways to learn how to program! They give us quick hand-on feedback on what are programs are doing. Motors are used in almost all our robot project. Robots are used in many STEM courses and coding clubs around the world. Programs like the AI Racing League allow students to learn topics like Machine Learning, Computer Vision and AI. These programs all depend on our understanding of how motors work and how to control them. Motor Types There are three types of motors we will learn how to control: DC Motors Servos Stepper Motors Outline of Labs Lab 1: Using and Transistor to Control a Motor In this lab we will use MicroPython to turn a motor on and off. We will use the digital output from the Raspberry Pi Pico to control a transistor as a switch to control the current to a motor. We will also learn how to use a diode to to protect the transistor from flyback current. Theory: What is an H-Bridge Circuit? This lab shows a sample circuit with four switches arranged in the shape of the letter \"H\" with the motor at the center of the letter. By closing switches in opposite corners we can make the motor reverse direction. Lab 2: Controlling a Motor Speed with the L293 H-Bridge Chip In this lab we will use a PWM signal to control the speed of a motor. Lab 3: Changing Motor Direction In this lab we will make a motor go both forward and backward and change the speed.","title":"Introduction"},{"location":"motors/01-intro/#using-micropython-to-control-motors-and-servos","text":"Controlling motors are one of the funnest ways to learn how to program! They give us quick hand-on feedback on what are programs are doing. Motors are used in almost all our robot project. Robots are used in many STEM courses and coding clubs around the world. Programs like the AI Racing League allow students to learn topics like Machine Learning, Computer Vision and AI. These programs all depend on our understanding of how motors work and how to control them.","title":"Using MicroPython to Control Motors and Servos"},{"location":"motors/01-intro/#motor-types","text":"There are three types of motors we will learn how to control: DC Motors Servos Stepper Motors","title":"Motor Types"},{"location":"motors/01-intro/#outline-of-labs","text":"","title":"Outline of Labs"},{"location":"motors/01-intro/#lab-1-using-and-transistor-to-control-a-motor","text":"In this lab we will use MicroPython to turn a motor on and off. We will use the digital output from the Raspberry Pi Pico to control a transistor as a switch to control the current to a motor. We will also learn how to use a diode to to protect the transistor from flyback current.","title":"Lab 1: Using and Transistor to Control a Motor"},{"location":"motors/01-intro/#theory-what-is-an-h-bridge-circuit","text":"This lab shows a sample circuit with four switches arranged in the shape of the letter \"H\" with the motor at the center of the letter. By closing switches in opposite corners we can make the motor reverse direction.","title":"Theory: What is an H-Bridge Circuit?"},{"location":"motors/01-intro/#lab-2-controlling-a-motor-speed-with-the-l293-h-bridge-chip","text":"In this lab we will use a PWM signal to control the speed of a motor.","title":"Lab 2: Controlling a Motor Speed with the L293 H-Bridge Chip"},{"location":"motors/01-intro/#lab-3-changing-motor-direction","text":"In this lab we will make a motor go both forward and backward and change the speed.","title":"Lab 3: Changing Motor Direction"},{"location":"motors/02-transistor/","text":"Using an Transistor to Control a Motor Power Requirements for Motors Motors need about 200 milliamps to work. But a microcontroller like the Raspberry Pi Pico only can switch about 18 milliamps. So we need a way to control more power. The Pico has 26 general purpose input and output pins. However, each pin's power is designed to digitally communicate with other devices and has a limited current capacity of around 17 milliamps according to the Raspberry Pi Pico Datasheet Table 5 . The solution is to either use the digital output signal to turn on and off a switch such as a transistor of to use a motor driver chip such as an L293D chip. Basic Transistor Circuit Transistor NPN 2222A Diode: 1N1448 Motor: 3-6 volt hobby motor PWM Control PWM Frequency Set the frequency to 50Hz (one cycle per 20ms) and the duty value to between 51 (51/1023 * 20ms = 1ms) and 102 (102/1023 * 20ms = 2ms) Sample Coder 1 2 3 4 5 6 7 8 import machine # set the 7th from the bottom on right as our motor pin motor_pin = machine . Pin ( 21 , machine . Pin . OUT ) # allocate a PWM object for controlling the motor speed motor_pwm = machine . PWM ( motor_pin ) motor_pwm . freq ( 50 ) # 50 hertz motor_pwm . duty ( 51 ) References Sparkfun Motor Lab from SIK Kit Nick Zoic MicroPython Motor Control Tutorial","title":"Transistor Lab"},{"location":"motors/02-transistor/#using-an-transistor-to-control-a-motor","text":"","title":"Using an Transistor to Control a Motor"},{"location":"motors/02-transistor/#power-requirements-for-motors","text":"Motors need about 200 milliamps to work. But a microcontroller like the Raspberry Pi Pico only can switch about 18 milliamps. So we need a way to control more power. The Pico has 26 general purpose input and output pins. However, each pin's power is designed to digitally communicate with other devices and has a limited current capacity of around 17 milliamps according to the Raspberry Pi Pico Datasheet Table 5 . The solution is to either use the digital output signal to turn on and off a switch such as a transistor of to use a motor driver chip such as an L293D chip.","title":"Power Requirements for Motors"},{"location":"motors/02-transistor/#basic-transistor-circuit","text":"Transistor NPN 2222A Diode: 1N1448 Motor: 3-6 volt hobby motor","title":"Basic Transistor Circuit"},{"location":"motors/02-transistor/#pwm-control","text":"","title":"PWM Control"},{"location":"motors/02-transistor/#pwm-frequency","text":"Set the frequency to 50Hz (one cycle per 20ms) and the duty value to between 51 (51/1023 * 20ms = 1ms) and 102 (102/1023 * 20ms = 2ms)","title":"PWM Frequency"},{"location":"motors/02-transistor/#sample-coder","text":"1 2 3 4 5 6 7 8 import machine # set the 7th from the bottom on right as our motor pin motor_pin = machine . Pin ( 21 , machine . Pin . OUT ) # allocate a PWM object for controlling the motor speed motor_pwm = machine . PWM ( motor_pin ) motor_pwm . freq ( 50 ) # 50 hertz motor_pwm . duty ( 51 )","title":"Sample Coder"},{"location":"motors/02-transistor/#references","text":"Sparkfun Motor Lab from SIK Kit Nick Zoic MicroPython Motor Control Tutorial","title":"References"},{"location":"motors/03-h-bridge/","text":"H-Bridge Circuits H-Bridge circuits are use to drive a motor both forward and backward. The circuit is called an \"H-Bridge\" because the arrangement of the switches around a motor form the letter \"H\". H-Bridge Circuit Operation If you connect a 5 volt power supply to a motor you will turn the motor in a specific direction such as clockwise. If you reverse the connections to the motor, the motor will turn the opposite direction such as counter-clockwise. In order to turn on the motor, switches 1 and 4 must be closed to allow current to flow through the motor. Switches 2 and 3 must be turned off. To reverse the motor direction you must open switches 1 and 4 and close switches 2 and three in the upper right and lower left portion of the diagram. References Wikipedia Page on H-Bridge Circuits","title":"H-Bridge"},{"location":"motors/03-h-bridge/#h-bridge-circuits","text":"H-Bridge circuits are use to drive a motor both forward and backward. The circuit is called an \"H-Bridge\" because the arrangement of the switches around a motor form the letter \"H\".","title":"H-Bridge Circuits"},{"location":"motors/03-h-bridge/#h-bridge-circuit-operation","text":"If you connect a 5 volt power supply to a motor you will turn the motor in a specific direction such as clockwise. If you reverse the connections to the motor, the motor will turn the opposite direction such as counter-clockwise. In order to turn on the motor, switches 1 and 4 must be closed to allow current to flow through the motor. Switches 2 and 3 must be turned off. To reverse the motor direction you must open switches 1 and 4 and close switches 2 and three in the upper right and lower left portion of the diagram.","title":"H-Bridge Circuit Operation"},{"location":"motors/03-h-bridge/#references","text":"Wikipedia Page on H-Bridge Circuits","title":"References"},{"location":"motors/04-l293d/","text":"Controlling a Motor with the L293D Motor Controller Chip What is an H-Bridge? The L293D Circuit The L293D motor driver IC actually has two power input pins viz. \u2018Vcc1\u2019 and \u2018Vcc2\u2019. Vcc1 is used for driving the internal logic circuitry which should be 5V. From Vcc2 pin the H-Bridge gets its power for driving the motors which can be 4.5V to 36V. And they both sink to a common ground named GND. Sample Program Referenes Last Minute Engineer L293D DC Motor TutoriL (Arduino version)","title":"L293D Chip"},{"location":"motors/04-l293d/#controlling-a-motor-with-the-l293d-motor-controller-chip","text":"","title":"Controlling a Motor with the L293D Motor Controller Chip"},{"location":"motors/04-l293d/#what-is-an-h-bridge","text":"","title":"What is an H-Bridge?"},{"location":"motors/04-l293d/#the-l293d-circuit","text":"The L293D motor driver IC actually has two power input pins viz. \u2018Vcc1\u2019 and \u2018Vcc2\u2019. Vcc1 is used for driving the internal logic circuitry which should be 5V. From Vcc2 pin the H-Bridge gets its power for driving the motors which can be 4.5V to 36V. And they both sink to a common ground named GND.","title":"The L293D Circuit"},{"location":"motors/04-l293d/#sample-program","text":"","title":"Sample Program"},{"location":"motors/04-l293d/#referenes","text":"Last Minute Engineer L293D DC Motor TutoriL (Arduino version)","title":"Referenes"},{"location":"motors/05-controller-board/","text":"","title":"Controller Board"},{"location":"motors/06-servos/","text":"Controlling a Servo Motor with MicroPython Types of Servos Although there are may types of servos you can purchase, in our labs there are two main types of servos that we use: SG90 Micro Servo, 9 grams, 180 degree, plastic gears - $4 MG90S Micro Servo, 9 grams, 180 degree, metal gears - $5 There are other variations that have 360 degree or continuous rotation servos. Servo Connections Almost all servos have a three pin connector that are spaced 1/10th of an inch apart so they will work with our breadboards. Ground (black or brown wire) 5 volt power (always red) Data (orange or yellow) references SparkFun Servos Page SparkFun Category for Servos eBay Servo Plastic Servo eBay Servo Metal Gear Servo","title":"Servos"},{"location":"motors/06-servos/#controlling-a-servo-motor-with-micropython","text":"","title":"Controlling a Servo Motor with MicroPython"},{"location":"motors/06-servos/#types-of-servos","text":"Although there are may types of servos you can purchase, in our labs there are two main types of servos that we use: SG90 Micro Servo, 9 grams, 180 degree, plastic gears - $4 MG90S Micro Servo, 9 grams, 180 degree, metal gears - $5 There are other variations that have 360 degree or continuous rotation servos.","title":"Types of Servos"},{"location":"motors/06-servos/#servo-connections","text":"Almost all servos have a three pin connector that are spaced 1/10th of an inch apart so they will work with our breadboards. Ground (black or brown wire) 5 volt power (always red) Data (orange or yellow)","title":"Servo Connections"},{"location":"motors/06-servos/#references","text":"SparkFun Servos Page SparkFun Category for Servos eBay Servo Plastic Servo eBay Servo Metal Gear Servo","title":"references"},{"location":"motors/07-stepper-motors/","text":"Controlling a Stepper Motor with MicroPython Stepper motors are specialized motors that precisely control the angle of rotation of the shaft of a motor. They are often used to carefully position items that move along an axis. For example you can use stepper motors to control the position the printing head of a 3D printer. Stepper motors are also quite a bit more expensive than our DC hobby motors and mini servos, so we don't use them frequently in our classes. Sample Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Code example from YoungWorks blog on how to use a stepper motor # https://www.youngwonks.com/blog/How-to-use-a-stepper-motor-with-the-Raspberry-Pi-Pico from machine import Pin import utime pins = [ Pin ( 15 , Pin . Out ), Pin ( 14 , Pin . Out ), Pin ( 16 , Pin . Out ), Pin ( 17 , Pin . Out ), ] # one hot encoding vectors full_step_sequence = [ [ 1.0 . 0.0 ], [ 0.1 . 0.0 ], [ 0.0 . 1.0 ], [ 0.0 . 0.1 ] ] while True : for step in full_step_sequence : for i in rang ( len ( pins )): pins [ i ] . value ( step [ i ]) utime . sleep ( 0.001 ) References Wikipedia Page on Stepper Motors Raspberry Pi L293D Example Young Wonks Stepper Motor Example with a","title":"Stepper Motors"},{"location":"motors/07-stepper-motors/#controlling-a-stepper-motor-with-micropython","text":"Stepper motors are specialized motors that precisely control the angle of rotation of the shaft of a motor. They are often used to carefully position items that move along an axis. For example you can use stepper motors to control the position the printing head of a 3D printer. Stepper motors are also quite a bit more expensive than our DC hobby motors and mini servos, so we don't use them frequently in our classes.","title":"Controlling a Stepper Motor with MicroPython"},{"location":"motors/07-stepper-motors/#sample-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Code example from YoungWorks blog on how to use a stepper motor # https://www.youngwonks.com/blog/How-to-use-a-stepper-motor-with-the-Raspberry-Pi-Pico from machine import Pin import utime pins = [ Pin ( 15 , Pin . Out ), Pin ( 14 , Pin . Out ), Pin ( 16 , Pin . Out ), Pin ( 17 , Pin . Out ), ] # one hot encoding vectors full_step_sequence = [ [ 1.0 . 0.0 ], [ 0.1 . 0.0 ], [ 0.0 . 1.0 ], [ 0.0 . 0.1 ] ] while True : for step in full_step_sequence : for i in rang ( len ( pins )): pins [ i ] . value ( step [ i ]) utime . sleep ( 0.001 )","title":"Sample Code"},{"location":"motors/07-stepper-motors/#references","text":"Wikipedia Page on Stepper Motors Raspberry Pi L293D Example Young Wonks Stepper Motor Example with a","title":"References"},{"location":"oled/01-intro/","text":"Introduction to OLED displays We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect** via I2C and SPI. Just four wires for I2C and seven wires for SPI. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. You can program them with Python (our student's favorite language) They are crazy fun! The first step is to find out what type of display graphics chip is used in your OLED. In these lessons we will assume you have a 128X64 or similar OLED display. Many of these displays can be purchased for around $4 on eBay. Many of these displays use the popular SSD1306 chip to drive the displays. There are also to communication options: I2C - simple 2 wire connection (not including power and ground) SPI - five wires but also faster screen refresh rates Updating a 128X64 display using I2C takes around 37ms. When using the SPI interface, updating the display can be reduced to around 2.79ms. These labs will assume these parameters, but you can modify the labs to use different sizes and display driver chips by only modifying a few lines of code. I2C Scanner Because your microcontroller might have multiple displays on it, their must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) If you don't see a return value of \"60\" or similar, then you need to check your wiring and make sure that you have an I2C (not an SPI) device.","title":"Introduction"},{"location":"oled/01-intro/#introduction-to-oled-displays","text":"We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect** via I2C and SPI. Just four wires for I2C and seven wires for SPI. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. You can program them with Python (our student's favorite language) They are crazy fun! The first step is to find out what type of display graphics chip is used in your OLED. In these lessons we will assume you have a 128X64 or similar OLED display. Many of these displays can be purchased for around $4 on eBay. Many of these displays use the popular SSD1306 chip to drive the displays. There are also to communication options: I2C - simple 2 wire connection (not including power and ground) SPI - five wires but also faster screen refresh rates Updating a 128X64 display using I2C takes around 37ms. When using the SPI interface, updating the display can be reduced to around 2.79ms. These labs will assume these parameters, but you can modify the labs to use different sizes and display driver chips by only modifying a few lines of code.","title":"Introduction to OLED displays"},{"location":"oled/01-intro/#i2c-scanner","text":"Because your microcontroller might have multiple displays on it, their must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) If you don't see a return value of \"60\" or similar, then you need to check your wiring and make sure that you have an I2C (not an SPI) device.","title":"I2C Scanner"},{"location":"oled/02-oled-setup/","text":"OLED Setup At the beginning of of your Python programs there is usually a few lines of setup instruction to tell the system which libraries to use, what pins to assign and what devices to initialize. We will first look at the simple I2C setup. Then we will look at the SPI setup. I2C Scanner Because your microcontroller might have multiple I2C devices and displays on it, there must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) returns: [60] returns: [60] SSD1306 Examples SSD1306 I2C Setup 1 2 3 4 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show () SSD1306 SPI Setup Back connections: Front labels on OLED with SPI: Here is the connection diagram: Here is the code: 1 2 3 4 5 6 7 8 9 10 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show () SSH1106 I2C Setup 1 2 3 4 5 6 7 8 9 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) oled = SH1106_I2C ( 128 , 64 , i2c ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show () References https://github.com/micropython/micropython/blob/master/drivers/display/ssd1306.py","title":"Setup"},{"location":"oled/02-oled-setup/#oled-setup","text":"At the beginning of of your Python programs there is usually a few lines of setup instruction to tell the system which libraries to use, what pins to assign and what devices to initialize. We will first look at the simple I2C setup. Then we will look at the SPI setup.","title":"OLED Setup"},{"location":"oled/02-oled-setup/#i2c-scanner","text":"Because your microcontroller might have multiple I2C devices and displays on it, there must be some way to address the devices using an address. Most of the devices come with a default address of decimal value 60 (hex value X3C). To test this the i3c module has a i2c scan function. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) returns: [60] returns: [60]","title":"I2C Scanner"},{"location":"oled/02-oled-setup/#ssd1306-examples","text":"","title":"SSD1306 Examples"},{"location":"oled/02-oled-setup/#ssd1306-i2c-setup","text":"1 2 3 4 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show ()","title":"SSD1306 I2C Setup"},{"location":"oled/02-oled-setup/#ssd1306-spi-setup","text":"Back connections: Front labels on OLED with SPI: Here is the connection diagram: Here is the code: 1 2 3 4 5 6 7 8 9 10 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show ()","title":"SSD1306 SPI Setup"},{"location":"oled/02-oled-setup/#ssh1106-i2c-setup","text":"1 2 3 4 5 6 7 8 9 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) oled = SH1106_I2C ( 128 , 64 , i2c ) oled . text ( 'Hello World!' , 0 , 0 , 1 ) oled . show ()","title":"SSH1106 I2C Setup"},{"location":"oled/02-oled-setup/#references","text":"https://github.com/micropython/micropython/blob/master/drivers/display/ssd1306.py","title":"References"},{"location":"oled/03-oled-drawing/","text":"Basic Draw Functions For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function. Initializing the Framebuffer Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following: Full list of Drawing Functions Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state or color is 0=off (black) and 1=on (white). Function Description Example blit(fbuf, x, y, color) Bit Level Transfer blit(fbuf, 1, 1) fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x, x, length, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert() invert the display Filp the orientation of the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel(x,y, color) Draw a single point on the screen rect(x, y, width, height) Draw an empty rectangle scroll(x,y) Scroll the display text(x,y,color) Write text at a point vline(x,y,length, color) Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display() Initialize the display write_cmd Write a command to the display show() Update the display from the frame buffer poweroff() poweron() contrast() write_data() Pixel Drawing Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ICON = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], ] display . fill ( 0 ) # Clear the display for y , row in enumerate ( ICON ): for x , c in enumerate ( row ): display . pixel ( x , y , c ) display . show () References Driving I2C OLED displays with MicroPython - by Martin Fitzpatrick ST7735 Micropython Driver by Anthony Norman","title":"Drawing"},{"location":"oled/03-oled-drawing/#basic-draw-functions","text":"For our beginning labs we will just do some basic drawing. We will start out with just four functions: Initialize the display framebuffer memory with the right object class initialization Fill the framebuffer will zeros which are black pixels with the oled.fill(0) Draw white text in the framebuffer memory with the oled.text(\"Hello World!\", 40, 10) Send the entire framebuffer to the display over the bus with the oled.show() function.","title":"Basic Draw Functions"},{"location":"oled/03-oled-drawing/#initializing-the-framebuffer","text":"Let's assume that we have a four wire OLED that uses the popular SSD1306 chip with 128X64 pixels. We call our oled \"oled\" using the following line: 1 2 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) Function Description Parameters oled.fill(0) Fill the display with white or black 0=black and 1=white oled.text(\"Hello\", Draw text String, x (horizontal from left edge) and y (vertical from the top)Example: Draw \"Hello World\" 40 over and 10 down. oled.text(\"Hello World!\", 40, 10) show Show the display Send the current frame buffer to the display. You must do this after you make and changes to the Framebuffer. The full program would look like this: 1 2 3 4 5 from ssd1306 import SSD1306_I2C oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () This would display the following:","title":"Initializing the Framebuffer"},{"location":"oled/03-oled-drawing/#full-list-of-drawing-functions","text":"Every drawing library might have slightly different functions. But we can quickly see the functions that we want by using the dir() function on the SSD1306_I2C class. 1 2 from ssd1306 import SSD1306_I2C print ( dir ( SSD1306_I2C )) This returns the following list: 1 2 3 4 5 [ '__class__' , '__init__' , '__module__' , '__name__' , '__qualname__' , '__bases__' , '__dict__' , 'blit' , 'fill' , 'fill_rect' , 'hline' , 'invert' , 'line' , 'pixel' , 'rect' , 'scroll' , 'text' , 'vline' , 'init_display' , 'write_cmd' , 'show' , 'poweroff' , 'poweron' , 'contrast' , 'write_data' ] Technically, these are called methods of the SSD1306_I2C class. The ones that begin and end with double underscores are class methods for creating new object instances. The rest of the items on the list are the drawing functions. The following are relevant for the SSD1306_I2C display. The display has (0,0) in the upper left corner. X is horizontal (width) and Y is vertical (height). The state or color is 0=off (black) and 1=on (white). Function Description Example blit(fbuf, x, y, color) Bit Level Transfer blit(fbuf, 1, 1) fill(state) Fill Fill with black (0) or white(1) fill_rect Fill a rectangle hline(x, x, length, state) Draw a horizontal line Draw a horizontal line at the top of the display: oled.hline(0, 0, 127, 1) invert() invert the display Filp the orientation of the display line(x1,y1,x2,y2) draw a line at any angle Horizontal oled.line(0,0, 127, 63, 1) pixel(x,y, color) Draw a single point on the screen rect(x, y, width, height) Draw an empty rectangle scroll(x,y) Scroll the display text(x,y,color) Write text at a point vline(x,y,length, color) Draw a Vertical Line oled.vline(width - 1, 0, height - 1, 1) # right edge init_display() Initialize the display write_cmd Write a command to the display show() Update the display from the frame buffer poweroff() poweron() contrast() write_data()","title":"Full list of Drawing Functions"},{"location":"oled/03-oled-drawing/#pixel-drawing-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ICON = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], ] display . fill ( 0 ) # Clear the display for y , row in enumerate ( ICON ): for x , c in enumerate ( row ): display . pixel ( x , y , c ) display . show ()","title":"Pixel Drawing Example"},{"location":"oled/03-oled-drawing/#references","text":"Driving I2C OLED displays with MicroPython - by Martin Fitzpatrick ST7735 Micropython Driver by Anthony Norman","title":"References"},{"location":"oled/10-oled-bounce/","text":"OLED Bounce In this lesson, we will draw a box around the edge of the display using the commands that draw horizontal and vertical lines: hline and vline . Then we will draw a ball that bounces off these edges. Draw a border 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge oled . show () Make a Ball Bounce Around Inside the Wall 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 2 # start in the middle of the screen current_x = int ( width / 2 ) current_y = int ( height / 2 ) # start going down to the right direction_x = 1 direction_y = - 1 # delay_time = .0001 # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 2 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y","title":"OLED Bounce"},{"location":"oled/10-oled-bounce/#oled-bounce","text":"In this lesson, we will draw a box around the edge of the display using the commands that draw horizontal and vertical lines: hline and vline . Then we will draw a ball that bounces off these edges.","title":"OLED Bounce"},{"location":"oled/10-oled-bounce/#draw-a-border","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge oled . show ()","title":"Draw a border"},{"location":"oled/10-oled-bounce/#make-a-ball-bounce-around-inside-the-wall","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 oled = SSD1306_I2C ( width , height , i2c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 1 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 2 # start in the middle of the screen current_x = int ( width / 2 ) current_y = int ( height / 2 ) # start going down to the right direction_x = 1 direction_y = - 1 # delay_time = .0001 # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 2 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y","title":"Make a Ball Bounce Around Inside the Wall"},{"location":"oled/11-oled-ping/","text":"OLED PING Circuit Coder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from machine import Pin , I2C , Timer from ssd1306 import SSD1306_I2C import utime # global toggle button variable measure_on = False # debounce for button def debounce ( pin ): timer . init ( mode = Timer . ONE_SHOT , period = 200 , callback = on_pressed ) # if button pressed, toggle measure_on def on_pressed ( timer ): global measure_on measure_on = not measure_on # Init button button = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) timer = Timer () button . irq ( debounce , Pin . IRQ_RISING ) # Init Display i2c = I2C ( 0 , sda = Pin ( 0 ), scl = Pin ( 1 ), freq = 40000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) # Init HC-SR04 pins trigger = Pin ( 14 , Pin . OUT ) echo = Pin ( 13 , Pin . IN ) def ultra (): trigger . low () utime . sleep_us ( 2 ) trigger . high () utime . sleep_us ( 5 ) trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance try : while True : oled . fill ( 0 ) if measure_on : result = ultra () oled . text ( \"Distance:\" , 0 , 0 ) oled . text ( str ( result ) + \" cm\" , 0 , 10 ) oled . show () utime . sleep ( 1 ) except KeyboardInterrupt : pass","title":"OLED Ping"},{"location":"oled/11-oled-ping/#oled-ping","text":"","title":"OLED PING"},{"location":"oled/11-oled-ping/#circuit","text":"","title":"Circuit"},{"location":"oled/11-oled-ping/#coder","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from machine import Pin , I2C , Timer from ssd1306 import SSD1306_I2C import utime # global toggle button variable measure_on = False # debounce for button def debounce ( pin ): timer . init ( mode = Timer . ONE_SHOT , period = 200 , callback = on_pressed ) # if button pressed, toggle measure_on def on_pressed ( timer ): global measure_on measure_on = not measure_on # Init button button = Pin ( 16 , Pin . IN , Pin . PULL_DOWN ) timer = Timer () button . irq ( debounce , Pin . IRQ_RISING ) # Init Display i2c = I2C ( 0 , sda = Pin ( 0 ), scl = Pin ( 1 ), freq = 40000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) # Init HC-SR04 pins trigger = Pin ( 14 , Pin . OUT ) echo = Pin ( 13 , Pin . IN ) def ultra (): trigger . low () utime . sleep_us ( 2 ) trigger . high () utime . sleep_us ( 5 ) trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance try : while True : oled . fill ( 0 ) if measure_on : result = ultra () oled . text ( \"Distance:\" , 0 , 0 ) oled . text ( str ( result ) + \" cm\" , 0 , 10 ) oled . show () utime . sleep ( 1 ) except KeyboardInterrupt : pass","title":"Coder"},{"location":"oled/11-oled-sh1106-i2c/","text":"OLED SSD1306 I2C Examples We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect via SPI. Just four wires: GND, VCC, Clock and Data. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. The first step is to find out what type of display graphics chip is used in your OLED. SH1106 Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' ) Counter Example In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' ) Animated Box This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) ## note that we can only draw from 0 to 62 display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' ) Bounce on the SH1106 Display using I2C This example is a ball that bounces around the inside of a border rectangle. Is similar to other bounce examples with the exception that you can't draw on the last row of pixels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import machine import utime # from ssd1306 import SSD1306_I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 # we could make this be 63 but the init method should use the full value # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 5 current_x = int ( width / 2 ) current_y = int ( height / 2 ) direction_x = 1 direction_y = - 1 # delay_time = .0001 # oled.line(0, height-2, width-1, height-2, 1) # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 3 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y print ( 'done' )","title":"OLED SH1106 I2C Example"},{"location":"oled/11-oled-sh1106-i2c/#oled-ssd1306-i2c-examples","text":"We use small OLED displays in many of our labs because: They are inexpensive (around $4). They are easy to connect via SPI. Just four wires: GND, VCC, Clock and Data. They have a large area to display feedback. Most of them are 128X64 pixels. Once you get the drivers installed (not always easy) they are easy to program . You only need to initialize the device and run the oled.fill(), oled.text() and oled.show() functions. OLEDs, unlike LCDs, have high contrast over a large range of input voltages . This means that as your batteries slowly discharge, your OLEDs will keep their high-quality contrast. There is plenty of sample code and tutorials available. The first step is to find out what type of display graphics chip is used in your OLED.","title":"OLED SSD1306 I2C Examples"},{"location":"oled/11-oled-sh1106-i2c/#sh1106-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' )","title":"SH1106 Example"},{"location":"oled/11-oled-sh1106-i2c/#counter-example","text":"In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' )","title":"Counter Example"},{"location":"oled/11-oled-sh1106-i2c/#animated-box","text":"This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) ## note that we can only draw from 0 to 62 display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' )","title":"Animated Box"},{"location":"oled/11-oled-sh1106-i2c/#bounce-on-the-sh1106-display-using-i2c","text":"This example is a ball that bounces around the inside of a border rectangle. Is similar to other bounce examples with the exception that you can't draw on the last row of pixels. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import machine import utime # from ssd1306 import SSD1306_I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 # we could make this be 63 but the init method should use the full value # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # ok, not really a circle - just a square for now def draw_ball ( x , y , size , state ): if size == 1 : oled . pixel ( x , y , state ) # draw a single pixel else : for i in range ( 0 , size ): # draw a box of pixels of the right size for j in range ( 0 , size ): oled . pixel ( x + i , y + j , state ) # TODO: for size above 4 round the corners border ( width , height ) ball_size = 5 current_x = int ( width / 2 ) current_y = int ( height / 2 ) direction_x = 1 direction_y = - 1 # delay_time = .0001 # oled.line(0, height-2, width-1, height-2, 1) # Bounce forever while True : draw_ball ( current_x , current_y , ball_size , 1 ) oled . show () # utime.sleep(delay_time) draw_ball ( current_x , current_y , ball_size , 0 ) # reverse at the edges # left edge test if current_x < 2 : direction_x = 1 # right edge test if current_x > width - ball_size - 2 : direction_x = - 1 # top edge test if current_y < 2 : direction_y = 1 # bottom edge test if current_y > height - ball_size - 3 : direction_y = - 1 # update the ball current_x = current_x + direction_x current_y = current_y + direction_y print ( 'done' )","title":"Bounce on the SH1106 Display using I2C"},{"location":"oled/11-oled-ssd1306-i2c/","text":"OLED SSD1306 Examples Using the SSD1306 with I2C Interfaces Add the ssd1306 Python Module You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command. I2C Hello World 1 2 3 4 5 6 7 8 9 10 11 import machine from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () print ( 'Done' ) After this program runs you should see the text on your OLED display. SH1106 Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' ) Counter Example In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' ) Animated Box This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' ) Install SSD1306 Module ssd1306 module SSD1306 Library - click the RAW button and then right click to do a \"Save As\" SSD1306 vs. SH1106 There is only one small difference between SSD1306 and SH1106: The SH1106 controller has an internal RAM of 132x64 pixel. The SSD1306 only has 128x64 pixel. The SPI interface The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy. SPI Baudrate https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__spi.html#ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display: CS - Chip Select - pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin Pico Pins 1 2 3 4 5 6 7 8 9 10 # Sample code sections 28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res SCK is the clock - hook this to the oled SCL MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 SPI0_SCK - pin 6 SPI0_MOSI - pin 7 SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO 1 2 3 spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4) SPI Terms Master Out Slave In (MOSI) We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4) Sample Nonworking SPI Code From the documentation: From spi is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. dc is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. res is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. cs is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import machine import machine import utime import ssd1306 led = machine . Pin ( 25 , machine . Pin . OUT ) # From: https://github.com/robert-hh/SH1106 # display = sh1106.SH1106_SPI(width, height, spi, dc, res, cs) #MOSI=machine.Pin(7) #SCK=machine.Pin(6) #spi = machine.SPI(0, baudrate=400000, sck=SCK, mosi=MOSI) spi_sck = machine . Pin ( 6 ) spi_tx = machine . Pin ( 7 ) # spi_rx=machine.Pin(4) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 8 ) DC = machine . Pin ( 9 ) RES = machine . Pin ( 10 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled . fill ( 1 ) oled . show () utime . sleep ( 0.5 ) oled . fill ( 0 ) oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) oled . show () # flash the LED to show end led . high () utime . sleep ( 0.5 ) led . low () print ( 'Done' ) References robert-hh's SH1106 Driver https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description Using I2C Defaults","title":"OLED SSD1306 I2C"},{"location":"oled/11-oled-ssd1306-i2c/#oled-ssd1306-examples","text":"","title":"OLED SSD1306 Examples"},{"location":"oled/11-oled-ssd1306-i2c/#using-the-ssd1306-with-i2c-interfaces","text":"","title":"Using the SSD1306 with I2C Interfaces"},{"location":"oled/11-oled-ssd1306-i2c/#add-the-ssd1306-python-module","text":"You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command.","title":"Add the ssd1306 Python Module"},{"location":"oled/11-oled-ssd1306-i2c/#i2c-hello-world","text":"1 2 3 4 5 6 7 8 9 10 11 import machine from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) oled . fill ( 0 ) oled . text ( \"Hello World!\" , 0 , 0 ) oled . show () print ( 'Done' ) After this program runs you should see the text on your OLED display.","title":"I2C Hello World"},{"location":"oled/11-oled-ssd1306-i2c/#sh1106-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , I2C import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) display . text ( 'CoderDojo' , 0 , 0 , 1 ) display . show () print ( 'done' )","title":"SH1106 Example"},{"location":"oled/11-oled-ssd1306-i2c/#counter-example","text":"In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import machine import utime from ssd1306 import SSD1306_I2C sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) oled = SSD1306_I2C ( 128 , 64 , i2c ) for i in range ( 1 , 51 ): # count 1 to 50 oled . fill ( 0 ) # clear to black oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) # at x=0, y=0, white on black oled . text ( str ( i ), 40 , 20 , 1 ) # move 30 pixels horizontal and 20 down from the top oled . show () # update display utime . sleep ( 0.1 ) #wait 1/10th of a second print ( 'done' )","title":"Counter Example"},{"location":"oled/11-oled-ssd1306-i2c/#animated-box","text":"This draws a title and four lines around a drawing area. It then draws boxes that move to the right. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from machine import Pin , I2C import sh1106 import utime sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = I2C ( 0 , scl = scl , sda = sda , freq = 400000 ) display = sh1106 . SH1106_I2C ( 128 , 64 , i2c , Pin ( 4 ), 0x3c ) display . sleep ( False ) display . fill ( 0 ) # clear to black display . text ( 'CoderDojo Rocks' , 0 , 0 , 1 ) # at x=0, y=0, white on black # line under title display . hline ( 0 , 9 , 127 , 1 ) # bottom of display display . hline ( 0 , 30 , 127 , 1 ) # left edge display . vline ( 0 , 10 , 32 , 1 ) # right edge display . vline ( 127 , 10 , 32 , 1 ) for i in range ( 0 , 118 ): # box x0, y0, width, height, on display . fill_rect ( i , 10 , 10 , 10 , 1 ) # draw black behind number display . fill_rect ( 10 , 21 , 30 , 8 , 0 ) display . text ( str ( i ), 10 , 21 , 1 ) display . show () # update display # utime.sleep(0.001) print ( 'done' )","title":"Animated Box"},{"location":"oled/11-oled-ssd1306-i2c/#install-ssd1306-module","text":"","title":"Install SSD1306 Module"},{"location":"oled/11-oled-ssd1306-i2c/#ssd1306-module","text":"SSD1306 Library - click the RAW button and then right click to do a \"Save As\"","title":"ssd1306 module"},{"location":"oled/11-oled-ssd1306-i2c/#ssd1306-vs-sh1106","text":"There is only one small difference between SSD1306 and SH1106: The SH1106 controller has an internal RAM of 132x64 pixel. The SSD1306 only has 128x64 pixel.","title":"SSD1306 vs. SH1106"},{"location":"oled/11-oled-ssd1306-i2c/#the-spi-interface","text":"The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy.","title":"The SPI interface"},{"location":"oled/11-oled-ssd1306-i2c/#spi-baudrate","text":"https://raspberrypi.github.io/pico-sdk-doxygen/group__hardware__spi.html#ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display: CS - Chip Select - pin 4 DC - Data/Command - pin 5 RES - Reset - pin 6 SDA - Data - SPIO TX GP7 pin 10 SCL - Clock - Connect to SPIO SCK GP6 pin 9 VCC - Connect to the 3.3V Out pin 36 GND - pin 38 or 3 any other GND pin","title":"SPI Baudrate"},{"location":"oled/11-oled-ssd1306-i2c/#pico-pins","text":"1 2 3 4 5 6 7 8 9 10 # Sample code sections 28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res SCK is the clock - hook this to the oled SCL MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 SPI0_SCK - pin 6 SPI0_MOSI - pin 7 SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO 1 2 3 spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4)","title":"Pico Pins"},{"location":"oled/11-oled-ssd1306-i2c/#spi-terms","text":"Master Out Slave In (MOSI) We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4)","title":"SPI Terms"},{"location":"oled/11-oled-ssd1306-i2c/#sample-nonworking-spi-code","text":"From the documentation: From spi is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. dc is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. res is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. cs is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import machine import machine import utime import ssd1306 led = machine . Pin ( 25 , machine . Pin . OUT ) # From: https://github.com/robert-hh/SH1106 # display = sh1106.SH1106_SPI(width, height, spi, dc, res, cs) #MOSI=machine.Pin(7) #SCK=machine.Pin(6) #spi = machine.SPI(0, baudrate=400000, sck=SCK, mosi=MOSI) spi_sck = machine . Pin ( 6 ) spi_tx = machine . Pin ( 7 ) # spi_rx=machine.Pin(4) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 8 ) DC = machine . Pin ( 9 ) RES = machine . Pin ( 10 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled . fill ( 1 ) oled . show () utime . sleep ( 0.5 ) oled . fill ( 0 ) oled . text ( 'CoderDojo Rocks!' , 0 , 0 , 1 ) oled . show () # flash the LED to show end led . high () utime . sleep ( 0.5 ) led . low () print ( 'Done' )","title":"Sample Nonworking SPI Code"},{"location":"oled/11-oled-ssd1306-i2c/#references","text":"robert-hh's SH1106 Driver https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description Using I2C Defaults","title":"References"},{"location":"oled/11-oled-ssd1306-spi/","text":"OLED SSD1306 SPI Examples Using the SSD1306 with SPI Interfaces Add the ssd1306 Python Module You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command. Install SSD1306 Module ssd1306 module SSD1306 Library - click the RAW button and then right click to do a \"Save As\" SSD1306 Library Searchable The SPI interface The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy. Displaying SPI Defaults 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from machine import Pin from ssd1306 import SSD1306_SPI # default is data (MOSI) on GP7 and clock (sck) on GP6 spi = machine . SPI ( 0 ) print ( spi ) SPI ( 0 , baudrate = 992063 , polarity = 0 , phase = 0 , bits = 8 , sck = 6 , mosi = 7 , miso = 4 ) ### SPI Baudrate https : // raspberrypi . github . io / pico - sdk - doxygen / group__hardware__spi . html #ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display : ! []( img / oled - back - connections . png ) 1. CS - Chip Select - pin 4 2. DC - Data / Command - pin 5 3. RES - Reset - pin 6 4. SDA - Data - SPIO TX GP7 pin 10 5. SCL - Clock - Connect to SPIO SCK GP6 pin 9 6. VCC - Connect to the 3.3 V Out pin 36 7. GND - pin 38 or 3 any other GND pin ### Pico Pins Sample code sections 28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res 1 2 3 4 5 6 7 8 9 10 11 12 * SCK is the clock - hook this to the oled SCL * MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 1. SPI0_SCK - pin 6 2. SPI0_MOSI - pin 7 3. SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4) ## Sample Nonworking SPI Code From the documentation: !!! From Raspberry Pi Pico Documentation **spi** is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. **dc** is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. **res** is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. **cs** is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. ```py import machine import utime import ssd1306 led = machine.Pin(25, machine.Pin.OUT) spi_sck=machine.Pin(6) spi_tx=machine.Pin(7) # spi_rx=machine.Pin(4) spi=machine.SPI(0,baudrate=100000,sck=spi_sck, mosi=spi_tx) CS = machine.Pin(8) DC = machine.Pin(9) RES = machine.Pin(10) oled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS) # flash all pixels on oled.fill(1) oled.show() utime.sleep(0.5) oled.fill(0) oled.text('CoderDojo Rocks!', 0, 0, 1) oled.show() # flash the LED to show end led.high() utime.sleep(0.5) led.low() print('Done') References robert-hh's SH1106 Driver MicroPython SSD1306 Class https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description SSD1306 https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1306/ SSD1307 https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1307/","title":"OLED SSD1306 SPI V2"},{"location":"oled/11-oled-ssd1306-spi/#oled-ssd1306-spi-examples","text":"","title":"OLED SSD1306 SPI Examples"},{"location":"oled/11-oled-ssd1306-spi/#using-the-ssd1306-with-spi-interfaces","text":"","title":"Using the SSD1306 with SPI Interfaces"},{"location":"oled/11-oled-ssd1306-spi/#add-the-ssd1306-python-module","text":"You can now use the Thonny \"Tools -> Manage Packages...\" menu to add the Python driver for the SSD1306 device. You will need to do this for every new device you use. If the Manage Packages menu is disabled, then you will need to go into the shell and add it with the pip command.","title":"Add the ssd1306 Python Module"},{"location":"oled/11-oled-ssd1306-spi/#install-ssd1306-module","text":"","title":"Install SSD1306 Module"},{"location":"oled/11-oled-ssd1306-spi/#ssd1306-module","text":"SSD1306 Library - click the RAW button and then right click to do a \"Save As\" SSD1306 Library Searchable","title":"ssd1306 module"},{"location":"oled/11-oled-ssd1306-spi/#the-spi-interface","text":"The four wire I2C interface is great for kids that don't want to hook up more than four wires. But there are times when we want a higher performance screen with faster refresh times. This is when the SPI interface comes in handy.","title":"The SPI interface"},{"location":"oled/11-oled-ssd1306-spi/#displaying-spi-defaults","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from machine import Pin from ssd1306 import SSD1306_SPI # default is data (MOSI) on GP7 and clock (sck) on GP6 spi = machine . SPI ( 0 ) print ( spi ) SPI ( 0 , baudrate = 992063 , polarity = 0 , phase = 0 , bits = 8 , sck = 6 , mosi = 7 , miso = 4 ) ### SPI Baudrate https : // raspberrypi . github . io / pico - sdk - doxygen / group__hardware__spi . html #ga37f4c04ce4165ac8c129226336a0b66c The seven wires on the back of the SPI OLED screens are the following as read from the top to bottom looking at the back of the display : ! []( img / oled - back - connections . png ) 1. CS - Chip Select - pin 4 2. DC - Data / Command - pin 5 3. RES - Reset - pin 6 4. SDA - Data - SPIO TX GP7 pin 10 5. SCL - Clock - Connect to SPIO SCK GP6 pin 9 6. VCC - Connect to the 3.3 V Out pin 36 7. GND - pin 38 or 3 any other GND pin ### Pico Pins","title":"Displaying SPI Defaults"},{"location":"oled/11-oled-ssd1306-spi/#sample-code-sections","text":"28 # ------------ SPI ------------------ 29 # Pin Map SPI 30 # - 3v - xxxxxx - Vcc 31 # - G - xxxxxx - Gnd 32 # - D7 - GPIO 13 - Din / MOSI fixed 33 # - D5 - GPIO 14 - Clk / Sck fixed 34 # - D8 - GPIO 4 - CS (optional, if the only connected device) 35 # - D2 - GPIO 5 - D/C 36 # - D1 - GPIO 2 - Res 1 2 3 4 5 6 7 8 9 10 11 12 * SCK is the clock - hook this to the oled SCL * MOSI is the line taking data from your Pico to the peripheral device. Hook this to SDA From the SDK: https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-python-sdk.pdf Section 3.7 1. SPI0_SCK - pin 6 2. SPI0_MOSI - pin 7 3. SPI0_MISO - pin 8 This contradicts p122 in GET STARTED WITH MICROPYTHON ON RASPBERRY PI PICO spi_sck=machine.Pin(2) spi_tx=machine.Pin(3) spi_rx=machine.Pin(4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 We send the data to the SPI RX (Receive) port on the Pico. These are pin 1 (GP0) or pin 6 (GP4) ## Sample Nonworking SPI Code From the documentation: !!! From Raspberry Pi Pico Documentation **spi** is an SPI object, which has to be created beforehand and tells the ports for SCLJ and MOSI. MISO is not used. **dc** is the GPIO Pin object for the Data/Command selection. It will be initialized by the driver. **res** is the GPIO Pin object for the reset connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. **cs** is the GPIO Pin object for the CS connection. It will be initialized by the driver. If it is not needed, it can be set to None or omitted. In this case the default value of None applies. ```py import machine import utime import ssd1306 led = machine.Pin(25, machine.Pin.OUT) spi_sck=machine.Pin(6) spi_tx=machine.Pin(7) # spi_rx=machine.Pin(4) spi=machine.SPI(0,baudrate=100000,sck=spi_sck, mosi=spi_tx) CS = machine.Pin(8) DC = machine.Pin(9) RES = machine.Pin(10) oled = ssd1306.SSD1306_SPI(128, 64, spi, DC, RES, CS) # flash all pixels on oled.fill(1) oled.show() utime.sleep(0.5) oled.fill(0) oled.text('CoderDojo Rocks!', 0, 0, 1) oled.show() # flash the LED to show end led.high() utime.sleep(0.5) led.low() print('Done')","title":"Sample code sections"},{"location":"oled/11-oled-ssd1306-spi/#references","text":"robert-hh's SH1106 Driver MicroPython SSD1306 Class https://www.mfitzp.com/article/oled-displays-i2c-micropython/ https://github.com/adafruit/Adafruit_CircuitPython_SSD1306/blob/master/examples/ssd1306_stats.py https://github.com/robert-hh/SH1106/blob/master/sh1106.py DIY More OLED Product Description","title":"References"},{"location":"oled/11-oled-ssd1306-spi/#ssd1306","text":"https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1306/","title":"SSD1306"},{"location":"oled/11-oled-ssd1306-spi/#ssd1307","text":"https://www.solomon-systech.com/en/product/advanced-display/oled-display-driver-ic/ssd1307/","title":"SSD1307"},{"location":"oled/11-pong/","text":"Pong Using a low-cost OLED device you can write a pong game. If you use a small 128X64 OLED the price can be around $12. Part list Part Name Price Link Description Raspberry Pi Pico $4 Microcenter With 264K RAM it has plenty of room for storing the framebuffer 1/2 Size Solderless Breadboard $2 link 400 tie breadboard 128X64 OLED $5 eBay You can also get larger 2.42\" displays for around $20 2 10K Potentiometers $1.5 each eBay You can purchase these in QTY 10 for less. Use the part number B10K to narrow your search. Clear Plastic Box $4 The Container Store Shallow Narrow Stackable Rectangle Clear with Lids 8-1/4\" x 3-1/2\" x 1-7/8\" h. The link is to the white lids. Raspberry Pi Pico for $4. OLED with I2C Interface. Note the pins are VCC, GND, SCL (clock), SDA (data). 1/2 size 400 connector solderless breadboard 10K potentiometer with pre-soldered connectors. You will need two of these. You can use a male-to-male header to connect it to the breadboard. Connections Connect the GND of the OLED to GND of the Pico Connect the VCC of the OLED to 3V3 OUT (physical pin 36) Connect the SDA (data) of the OLED to the Pico GP0 (physical pin 1 on the top left with USB up) Connect the SCL (clock) of the OLED to GP1 (physical pin 2) Connect the center tap of both potentiometers to ADC0 (GP26 - pin 31) and ADC1 (GP27 - pin 32) Connect the outer connectors of the potentiometers to VCC and GND Getting the Right Python Libraries To run this program, you will need a MicroPython display driver. Our display in this example is the popular SSD1306 driver chip. Your OLED might have a slightly different driver type. Here is the line that must be customized for your display: 1 from ssd1306 import SSD1306_I2C Testing the OLED This test will verify that your OLED connections are correct. 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show () Drawing the Border 1 2 def border(WIDTH, HEIGHT): oled.rect(0, 0, WIDTH, HEIGHT, 1) Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 # Pong game on Raspberry Pi Pico with a OLED and two Potentimeters from machine import Pin , PWM , SPI import ssd1306 from utime import sleep import random # random direction for new ball spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # connect the center tops of the potentiometers to ADC0 and ADC1 pot_pin_1 = machine . ADC ( 26 ) pot_pin_2 = machine . ADC ( 26 ) # make them the same for testing # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # globals variables # static variables are constants are uppercase variable names WIDTH = 128 HALF_WIDTH = int ( WIDTH / 2 ) HEIGHT = 64 HALF_HEIGHT = HEIGHT BALL_SIZE = 3 # 2X2 pixels PAD_WIDTH = 2 PAD_HEIGHT = 8 HALF_PAD_WIDTH = int ( PAD_WIDTH / 2 ) HALF_PAD_HEIGHT = int ( PAD_HEIGHT / 2 ) POT_MIN = 3000 POT_MAX = 65534 MAX_ADC_VALUE = 65534 # Maximum value from the Analog to Digital Converter is 2^16 - 1 # dynamic global variables use lowercase paddle1_vel = 0 paddle2_vel = 0 l_score = 0 r_score = 0 # continiuous update of the paddle and ball # play_startup_sound() # start with the ball in the center ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) # set the initial directinon to down to the right ball_x_dir = 1 ball_y_dir = 1 def play_startup_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 25 ) speaker . freq ( 800 ) sleep ( . 25 ) speaker . freq ( 1200 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) def play_bounce_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 900 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) def play_score_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 25 ) speaker . freq ( 800 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( WIDTH , HEIGHT ): oled . rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a vertical bar def draw_paddle ( paddle_no , paddle_center ): if paddle_no == 1 : x = 0 else : x = WIDTH - 2 y = paddle_center - HALF_PAD_HEIGHT oled . fill_rect ( x , y , PAD_WIDTH , PAD_HEIGHT , 1 ) # fill with 1s def draw_ball (): oled . fill_rect ( ball_x , ball_y , BALL_SIZE , BALL_SIZE , 1 ) # square balls for now # The main event loop while True : oled . fill ( 0 ) # clear screen oled . vline ( int ( WIDTH / 2 ), 0 , HEIGHT , 1 ) # border(WIDTH, HEIGHT) # read both the pot values pot_val_1 = pot_pin_1 . read_u16 () pot_val_2 = pot_pin_1 . read_u16 () # print(pot_val_1) # scale the values from the max value of the input is a 2^16 or 65536 to 0 to HEIGHT - PAD_HEIGHT # ideally, it should range from 5 to 58 pot_val_1 = valmap ( pot_val_1 , POT_MIN , POT_MAX , HALF_PAD_HEIGHT , HEIGHT - HALF_PAD_HEIGHT - 2 ) pot_val_2 = valmap ( pot_val_2 , POT_MIN , POT_MAX , HALF_PAD_HEIGHT , HEIGHT - HALF_PAD_HEIGHT - 2 ) # print(pot_val, pot_scaled) draw_paddle ( 1 , pot_val_1 + HALF_PAD_HEIGHT ) draw_paddle ( 2 , pot_val_2 + HALF_PAD_HEIGHT ) draw_ball () #update ball position with the current directions ball_x = ball_x + ball_x_dir ball_y = ball_y + ball_y_dir # update the ball direction if we are at the top or bottom edge if ball_y < 0 : ball_y_dir = 1 #play_bounce_sound() if ball_y > HEIGHT - 3 : ball_y_dir = - 1 #play_bounce_sound() # if it hits the paddle bounce else score if ball_x < 1 : top_paddle = pot_val_1 - HALF_PAD_HEIGHT bottom_paddle = pot_val_1 + HALF_PAD_HEIGHT if ball_y > top_paddle and ball_y < bottom_paddle : # we have a hit ball_x_dir = 1 ball_x = 2 play_bounce_sound () print ( 'paddle hit on left edge' , pot_val_1 , top_paddle , bottom_paddle ) else : # we have a score for the right player play_score_sound () r_score += 1 ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) ball_x_dir = random . randint ( - 1 , 2 ) if ball_x_dir == 0 : ball_x_dir = 1 ball_y_dir = random . randint ( - 1 , 2 ) print ( 'score on left edge' , pot_val_1 , top_paddle , bottom_paddle ) sleep ( . 25 ) if ball_x > WIDTH - 3 : ball_x = WIDTH - 4 top_paddle = pot_val_2 - HALF_PAD_HEIGHT bottom_paddle = pot_val_2 + HALF_PAD_HEIGHT if ball_y > top_paddle and ball_y < bottom_paddle : ball_x_dir = - 1 print ( 'bounce on right paddle' , pot_val_1 , top_paddle , bottom_paddle ) else : l_score += 1 play_score_sound () ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) ball_x_dir = random . randint ( - 1 , 2 ) if ball_x_dir == 0 : ball_x_dir = 1 ball_y_dir = random . randint ( - 1 , 2 ) play_bounce_sound () print ( 'score on right edge' , pot_val_1 , top_paddle , bottom_paddle ) sleep ( . 25 ) oled . text ( str ( l_score ), HALF_WIDTH - 20 , 5 , 1 ) oled . text ( str ( r_score ), HALF_WIDTH + 5 , 5 , 1 ) oled . show () YouTube Video","title":"OLED Pong"},{"location":"oled/11-pong/#pong","text":"Using a low-cost OLED device you can write a pong game. If you use a small 128X64 OLED the price can be around $12.","title":"Pong"},{"location":"oled/11-pong/#part-list","text":"Part Name Price Link Description Raspberry Pi Pico $4 Microcenter With 264K RAM it has plenty of room for storing the framebuffer 1/2 Size Solderless Breadboard $2 link 400 tie breadboard 128X64 OLED $5 eBay You can also get larger 2.42\" displays for around $20 2 10K Potentiometers $1.5 each eBay You can purchase these in QTY 10 for less. Use the part number B10K to narrow your search. Clear Plastic Box $4 The Container Store Shallow Narrow Stackable Rectangle Clear with Lids 8-1/4\" x 3-1/2\" x 1-7/8\" h. The link is to the white lids. Raspberry Pi Pico for $4. OLED with I2C Interface. Note the pins are VCC, GND, SCL (clock), SDA (data). 1/2 size 400 connector solderless breadboard 10K potentiometer with pre-soldered connectors. You will need two of these. You can use a male-to-male header to connect it to the breadboard.","title":"Part list"},{"location":"oled/11-pong/#connections","text":"Connect the GND of the OLED to GND of the Pico Connect the VCC of the OLED to 3V3 OUT (physical pin 36) Connect the SDA (data) of the OLED to the Pico GP0 (physical pin 1 on the top left with USB up) Connect the SCL (clock) of the OLED to GP1 (physical pin 2) Connect the center tap of both potentiometers to ADC0 (GP26 - pin 31) and ADC1 (GP27 - pin 32) Connect the outer connectors of the potentiometers to VCC and GND","title":"Connections"},{"location":"oled/11-pong/#getting-the-right-python-libraries","text":"To run this program, you will need a MicroPython display driver. Our display in this example is the popular SSD1306 driver chip. Your OLED might have a slightly different driver type. Here is the line that must be customized for your display: 1 from ssd1306 import SSD1306_I2C","title":"Getting the Right Python Libraries"},{"location":"oled/11-pong/#testing-the-oled","text":"This test will verify that your OLED connections are correct. 1 2 3 4 5 6 7 8 9 10 11 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show ()","title":"Testing the OLED"},{"location":"oled/11-pong/#drawing-the-border","text":"1 2 def border(WIDTH, HEIGHT): oled.rect(0, 0, WIDTH, HEIGHT, 1)","title":"Drawing the Border"},{"location":"oled/11-pong/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 # Pong game on Raspberry Pi Pico with a OLED and two Potentimeters from machine import Pin , PWM , SPI import ssd1306 from utime import sleep import random # random direction for new ball spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # connect the center tops of the potentiometers to ADC0 and ADC1 pot_pin_1 = machine . ADC ( 26 ) pot_pin_2 = machine . ADC ( 26 ) # make them the same for testing # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # globals variables # static variables are constants are uppercase variable names WIDTH = 128 HALF_WIDTH = int ( WIDTH / 2 ) HEIGHT = 64 HALF_HEIGHT = HEIGHT BALL_SIZE = 3 # 2X2 pixels PAD_WIDTH = 2 PAD_HEIGHT = 8 HALF_PAD_WIDTH = int ( PAD_WIDTH / 2 ) HALF_PAD_HEIGHT = int ( PAD_HEIGHT / 2 ) POT_MIN = 3000 POT_MAX = 65534 MAX_ADC_VALUE = 65534 # Maximum value from the Analog to Digital Converter is 2^16 - 1 # dynamic global variables use lowercase paddle1_vel = 0 paddle2_vel = 0 l_score = 0 r_score = 0 # continiuous update of the paddle and ball # play_startup_sound() # start with the ball in the center ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) # set the initial directinon to down to the right ball_x_dir = 1 ball_y_dir = 1 def play_startup_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 25 ) speaker . freq ( 800 ) sleep ( . 25 ) speaker . freq ( 1200 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) def play_bounce_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 900 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) def play_score_sound (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 25 ) speaker . freq ( 800 ) sleep ( . 25 ) speaker . duty_u16 ( 0 ) # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( WIDTH , HEIGHT ): oled . rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a vertical bar def draw_paddle ( paddle_no , paddle_center ): if paddle_no == 1 : x = 0 else : x = WIDTH - 2 y = paddle_center - HALF_PAD_HEIGHT oled . fill_rect ( x , y , PAD_WIDTH , PAD_HEIGHT , 1 ) # fill with 1s def draw_ball (): oled . fill_rect ( ball_x , ball_y , BALL_SIZE , BALL_SIZE , 1 ) # square balls for now # The main event loop while True : oled . fill ( 0 ) # clear screen oled . vline ( int ( WIDTH / 2 ), 0 , HEIGHT , 1 ) # border(WIDTH, HEIGHT) # read both the pot values pot_val_1 = pot_pin_1 . read_u16 () pot_val_2 = pot_pin_1 . read_u16 () # print(pot_val_1) # scale the values from the max value of the input is a 2^16 or 65536 to 0 to HEIGHT - PAD_HEIGHT # ideally, it should range from 5 to 58 pot_val_1 = valmap ( pot_val_1 , POT_MIN , POT_MAX , HALF_PAD_HEIGHT , HEIGHT - HALF_PAD_HEIGHT - 2 ) pot_val_2 = valmap ( pot_val_2 , POT_MIN , POT_MAX , HALF_PAD_HEIGHT , HEIGHT - HALF_PAD_HEIGHT - 2 ) # print(pot_val, pot_scaled) draw_paddle ( 1 , pot_val_1 + HALF_PAD_HEIGHT ) draw_paddle ( 2 , pot_val_2 + HALF_PAD_HEIGHT ) draw_ball () #update ball position with the current directions ball_x = ball_x + ball_x_dir ball_y = ball_y + ball_y_dir # update the ball direction if we are at the top or bottom edge if ball_y < 0 : ball_y_dir = 1 #play_bounce_sound() if ball_y > HEIGHT - 3 : ball_y_dir = - 1 #play_bounce_sound() # if it hits the paddle bounce else score if ball_x < 1 : top_paddle = pot_val_1 - HALF_PAD_HEIGHT bottom_paddle = pot_val_1 + HALF_PAD_HEIGHT if ball_y > top_paddle and ball_y < bottom_paddle : # we have a hit ball_x_dir = 1 ball_x = 2 play_bounce_sound () print ( 'paddle hit on left edge' , pot_val_1 , top_paddle , bottom_paddle ) else : # we have a score for the right player play_score_sound () r_score += 1 ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) ball_x_dir = random . randint ( - 1 , 2 ) if ball_x_dir == 0 : ball_x_dir = 1 ball_y_dir = random . randint ( - 1 , 2 ) print ( 'score on left edge' , pot_val_1 , top_paddle , bottom_paddle ) sleep ( . 25 ) if ball_x > WIDTH - 3 : ball_x = WIDTH - 4 top_paddle = pot_val_2 - HALF_PAD_HEIGHT bottom_paddle = pot_val_2 + HALF_PAD_HEIGHT if ball_y > top_paddle and ball_y < bottom_paddle : ball_x_dir = - 1 print ( 'bounce on right paddle' , pot_val_1 , top_paddle , bottom_paddle ) else : l_score += 1 play_score_sound () ball_x = int ( WIDTH / 2 ) ball_y = int ( HEIGHT / 2 ) ball_x_dir = random . randint ( - 1 , 2 ) if ball_x_dir == 0 : ball_x_dir = 1 ball_y_dir = random . randint ( - 1 , 2 ) play_bounce_sound () print ( 'score on right edge' , pot_val_1 , top_paddle , bottom_paddle ) sleep ( . 25 ) oled . text ( str ( l_score ), HALF_WIDTH - 20 , 5 , 1 ) oled . text ( str ( r_score ), HALF_WIDTH + 5 , 5 , 1 ) oled . show () YouTube Video","title":"Full Program"},{"location":"oled/12-oled-pot/","text":"OLED Potentiometer Example In this lesson, we will use a potentiometer to change the value of an OLED display. We will use a small SSD1306 OLED with an I2C interface. A potentiometer has three wires. The two outside wires connect to GND and the 3.3 volt output. The center wire, called the \"tap\" wire will connect to the pin that converts an continuous analog voltage value into a digital number. Wikipedia Page on Potentiometer Circuit Diagram Sample Code Testing the POT Our first task is to find what pin to use for our first Analog to Digital concerter. GP26 is the same as ADC0. This is pin number 31 on the Pico. 1 2 3 4 5 6 import machine import utime pot = machine . ADC ( 26 ) while True : print ( pot . read_u16 ()) utime . sleep ( . 2 ) Sample 16 bit output A 16-bit integer can store 216 (or 65,536) distinct values. In an unsigned representation, these values are the integers between 0 and 65,535. So we are expecting numbers from 0 to 65,535. Sample results as we move the potentiometer from the minimum to the maximum values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 65535 52844 31047 7745 256 352 19140 41114 62239 65535 57277 33384 10114 352 288 19940 28086 Testing the OLED Getting the defaults 1 2 3 4 5 from machine import Pin , I2C # i2c=machine.I2C(0) i2c = machine . I2C ( 0 ) print ( \"Device found at decimal\" , i2c . scan ()) print ( i2c ) Results: This tells you the default pins and frequency that the I2C bus is running at. 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=9, sda=8) 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=1, sda=0) This tells us that the default pins are GP9 (row 12) for clock and GP8 (row 11) for data. 1 2 3 4 5 6 7 8 9 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show () Continuous Text Display on OLED 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 32 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) POT_PIN = machine . ADC ( 26 ) while True : oled . fill ( 0 ) oled . text ( POT_PIN . read_u16 ()) oled . show () utime . sleep ( . 2 ) Barchart and Text Display of Pot Value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import machine import utime import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) pot_pin = machine . ADC ( 26 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 half_height = int ( height / 2 ) # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a horizontal bar def draw_hbar ( inval , height , state ): oled . fill ( 0 ) # clear screen border ( width , height ) # draw a border oled . fill_rect ( 0 , 1 , inval , height , 1 ) # fill with 1 utime . sleep ( . 1 ) # wait a bit # continuous update while True : pot_val = int ( pot_pin . read_u16 ()) # the max value of the input is a 2^16 or 65536 pot_scaled = valmap ( pot_val , 0 , 65536 , 0 , 127 ) print ( pot_val , pot_scaled ) draw_hbar ( pot_scaled , half_height , 1 ) oled . text ( 'raw:' , 0 , half_height + 5 , 1 ) oled . text ( str ( pot_val ), 30 , half_height + 5 , 1 ) oled . text ( 'scaled:' , 0 , half_height + 15 , 1 ) oled . text ( str ( pot_scaled ), 60 , half_height + 15 , 1 ) oled . show () Gif of OLED Gif of small .96\" OLED Gif of larger 2.42\" OLED","title":"OLED Pot"},{"location":"oled/12-oled-pot/#oled-potentiometer-example","text":"In this lesson, we will use a potentiometer to change the value of an OLED display. We will use a small SSD1306 OLED with an I2C interface. A potentiometer has three wires. The two outside wires connect to GND and the 3.3 volt output. The center wire, called the \"tap\" wire will connect to the pin that converts an continuous analog voltage value into a digital number. Wikipedia Page on Potentiometer","title":"OLED Potentiometer Example"},{"location":"oled/12-oled-pot/#circuit-diagram","text":"","title":"Circuit Diagram"},{"location":"oled/12-oled-pot/#sample-code","text":"","title":"Sample Code"},{"location":"oled/12-oled-pot/#testing-the-pot","text":"Our first task is to find what pin to use for our first Analog to Digital concerter. GP26 is the same as ADC0. This is pin number 31 on the Pico. 1 2 3 4 5 6 import machine import utime pot = machine . ADC ( 26 ) while True : print ( pot . read_u16 ()) utime . sleep ( . 2 )","title":"Testing the POT"},{"location":"oled/12-oled-pot/#sample-16-bit-output","text":"A 16-bit integer can store 216 (or 65,536) distinct values. In an unsigned representation, these values are the integers between 0 and 65,535. So we are expecting numbers from 0 to 65,535. Sample results as we move the potentiometer from the minimum to the maximum values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 65535 52844 31047 7745 256 352 19140 41114 62239 65535 57277 33384 10114 352 288 19940 28086","title":"Sample 16 bit output"},{"location":"oled/12-oled-pot/#testing-the-oled","text":"","title":"Testing the OLED"},{"location":"oled/12-oled-pot/#getting-the-defaults","text":"1 2 3 4 5 from machine import Pin , I2C # i2c=machine.I2C(0) i2c = machine . I2C ( 0 ) print ( \"Device found at decimal\" , i2c . scan ()) print ( i2c ) Results: This tells you the default pins and frequency that the I2C bus is running at. 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=9, sda=8) 1 2 Device found at decimal [60] I2C(0, freq=399361, scl=1, sda=0) This tells us that the default pins are GP9 (row 12) for clock and GP8 (row 11) for data. 1 2 3 4 5 6 7 8 9 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 64 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks\" , 0 , 0 ) oled . show ()","title":"Getting the defaults"},{"location":"oled/12-oled-pot/#continuous-text-display-on-oled","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 from machine import Pin , I2C from ssd1306 import SSD1306_I2C WIDTH = 128 HEIGHT = 32 i2c = I2C ( 0 ) # Init I2C using I2C0 defaults SCL on GP9 (12) and SDA on GP8 (11) oled = SSD1306_I2C ( WIDTH , HEIGHT , i2c ) POT_PIN = machine . ADC ( 26 ) while True : oled . fill ( 0 ) oled . text ( POT_PIN . read_u16 ()) oled . show () utime . sleep ( . 2 )","title":"Continuous Text Display on OLED"},{"location":"oled/12-oled-pot/#barchart-and-text-display-of-pot-value","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import machine import utime import sh1106 sda = machine . Pin ( 0 ) scl = machine . Pin ( 1 ) pot_pin = machine . ADC ( 26 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Screen size width = 128 height = 64 half_height = int ( height / 2 ) # oled = SSD1306_I2C(width, height, i2c) oled = sh1106 . SH1106_I2C ( width , height , i2c , machine . Pin ( 4 ), 0x3c ) oled . fill ( 0 ) # clear to black # note that OLEDs have problems with screen burn it - don't leave this on too long! def border ( width , height ): oled . hline ( 0 , 0 , width - 1 , 1 ) # top edge oled . hline ( 0 , height - 2 , width - 1 , 1 ) # bottom edge oled . vline ( 0 , 0 , height - 1 , 1 ) # left edge oled . vline ( width - 1 , 0 , height - 1 , 1 ) # right edge # Takes an input number vale and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def valmap ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( value - istart ) / ( istop - istart ))) # draw a horizontal bar def draw_hbar ( inval , height , state ): oled . fill ( 0 ) # clear screen border ( width , height ) # draw a border oled . fill_rect ( 0 , 1 , inval , height , 1 ) # fill with 1 utime . sleep ( . 1 ) # wait a bit # continuous update while True : pot_val = int ( pot_pin . read_u16 ()) # the max value of the input is a 2^16 or 65536 pot_scaled = valmap ( pot_val , 0 , 65536 , 0 , 127 ) print ( pot_val , pot_scaled ) draw_hbar ( pot_scaled , half_height , 1 ) oled . text ( 'raw:' , 0 , half_height + 5 , 1 ) oled . text ( str ( pot_val ), 30 , half_height + 5 , 1 ) oled . text ( 'scaled:' , 0 , half_height + 15 , 1 ) oled . text ( str ( pot_scaled ), 60 , half_height + 15 , 1 ) oled . show ()","title":"Barchart and Text Display of Pot Value"},{"location":"oled/12-oled-pot/#gif-of-oled","text":"Gif of small .96\" OLED Gif of larger 2.42\" OLED","title":"Gif of OLED"},{"location":"oled/12-oled-ssd1306-spi-v1/","text":"OLED SPI Demo This code was provide by Jim Tannenbaum (aka Jet) Image Code 1 2 3 4 5 6 7 8 9 10 11 12 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled.fill(0) oled . show () oled . text ( 'Hello Jet' , 0 , 0 , 1 ) oled . show ()","title":"OLED SSD1306 SPI V1"},{"location":"oled/12-oled-ssd1306-spi-v1/#oled-spi-demo","text":"This code was provide by Jim Tannenbaum (aka Jet)","title":"OLED SPI Demo"},{"location":"oled/12-oled-ssd1306-spi-v1/#image","text":"","title":"Image"},{"location":"oled/12-oled-ssd1306-spi-v1/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 import machine import ssd1306 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # flash all pixels on oled.fill(0) oled . show () oled . text ( 'Hello Jet' , 0 , 0 , 1 ) oled . show ()","title":"Code"},{"location":"oled/13-pixel-draw/","text":"Sample Pixel-Based Drawing Program Code example provided by Jim Tannenbaum. This program will act like an Etch-A-Sketch(TM) program. It will use potentiometers with the center tap on GPIO pins GP26 and GP27 and draw as you move the potentiometers to control the X and Y dimensions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from machine import Pin , SPI , ADC import ssd1306 import time # Takes an input number value and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def scaled ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( int ( value ) - istart ) / ( istop - istart ))) # Define the pins for SPI Clock and Transmit spi_sck = Pin ( 2 ) spi_tx = Pin ( 3 ) spi = SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) # Define the pins for Chip Select, DC (Command), and Reset CS = Pin ( 1 ) DC = Pin ( 4 ) RES = Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # Turn all pixels off oled . fill ( 0 ) oled . show () # Provide info to user oled . text ( 'Etch-A-Sketch' , 0 , 0 , 1 ) oled . text ( 'Hit the reset' , 0 , 20 , 1 ) oled . text ( 'button to clear' , 0 , 30 , 1 ) oled . text ( 'the screen' , 0 , 40 , 1 ) oled . show () # Define the pin for the reset button resetButton = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) # Wait unti the user hits the button to clear the screen and start drawing while resetButton . value () != 1 : time . sleep ( . 25 ) oled . fill ( 0 ) oled . show () # Define the Horizontal and Vertical inputs from the Rheostats vert = ADC ( 26 ) horiz = ADC ( 27 ) # Calculate where to start the line x = newX = scaled ( vert . read_u16 (), 0 , 65536 , 0 , 128 ) y = newY = scaled ( horiz . read_u16 (), 0 , 65536 , 0 , 64 ) # Loop forever # Draw the line, look for a reset to clear the screen, and get the new end points for the line while True : oled . line ( x , y , newX , newY , 1 ) x = newX y = newY if resetButton . value (): oled . fill ( 0 ) oled . show () time . sleep ( . 2 ) newX = scaled ( vert . read_u16 (), 0 , 65536 , 0 , 128 ) newY = scaled ( horiz . read_u16 (), 0 , 65536 , 0 , 64 )","title":"OLED Pixel Draw"},{"location":"oled/13-pixel-draw/#sample-pixel-based-drawing-program","text":"Code example provided by Jim Tannenbaum. This program will act like an Etch-A-Sketch(TM) program. It will use potentiometers with the center tap on GPIO pins GP26 and GP27 and draw as you move the potentiometers to control the X and Y dimensions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from machine import Pin , SPI , ADC import ssd1306 import time # Takes an input number value and a range between high-and-low and returns it scaled to the new range # This is similar to the Arduino map() function def scaled ( value , istart , istop , ostart , ostop ): return int ( ostart + ( ostop - ostart ) * (( int ( value ) - istart ) / ( istop - istart ))) # Define the pins for SPI Clock and Transmit spi_sck = Pin ( 2 ) spi_tx = Pin ( 3 ) spi = SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) # Define the pins for Chip Select, DC (Command), and Reset CS = Pin ( 1 ) DC = Pin ( 4 ) RES = Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( 128 , 64 , spi , DC , RES , CS ) # Turn all pixels off oled . fill ( 0 ) oled . show () # Provide info to user oled . text ( 'Etch-A-Sketch' , 0 , 0 , 1 ) oled . text ( 'Hit the reset' , 0 , 20 , 1 ) oled . text ( 'button to clear' , 0 , 30 , 1 ) oled . text ( 'the screen' , 0 , 40 , 1 ) oled . show () # Define the pin for the reset button resetButton = Pin ( 14 , Pin . IN , Pin . PULL_DOWN ) # Wait unti the user hits the button to clear the screen and start drawing while resetButton . value () != 1 : time . sleep ( . 25 ) oled . fill ( 0 ) oled . show () # Define the Horizontal and Vertical inputs from the Rheostats vert = ADC ( 26 ) horiz = ADC ( 27 ) # Calculate where to start the line x = newX = scaled ( vert . read_u16 (), 0 , 65536 , 0 , 128 ) y = newY = scaled ( horiz . read_u16 (), 0 , 65536 , 0 , 64 ) # Loop forever # Draw the line, look for a reset to clear the screen, and get the new end points for the line while True : oled . line ( x , y , newX , newY , 1 ) x = newX y = newY if resetButton . value (): oled . fill ( 0 ) oled . show () time . sleep ( . 2 ) newX = scaled ( vert . read_u16 (), 0 , 65536 , 0 , 128 ) newY = scaled ( horiz . read_u16 (), 0 , 65536 , 0 , 64 )","title":"Sample Pixel-Based Drawing Program"},{"location":"oled/14-random-hearts/","text":"Draw Random Hearts This program uses the MicroPython urandom library to generate random X and Y positions on the display. It then uses an array of binary values to draw a heart icon at that location. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from machine import Pin , PWM , SPI import urandom import ssd1306 from utime import sleep import random # random direction for new ball WIDTH = 128 HEIGHT = 64 CS = machine . Pin ( 1 ) spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) HEART = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], ] def draw_heart ( xofs , yofs ): for y , row in enumerate ( HEART ): for x , c in enumerate ( row ): oled . pixel ( x + xofs , y + yofs , c ) def random_heart (): xofs = urandom . getrandbits ( 7 ) yofs = urandom . getrandbits ( 6 ) print ( xofs , yofs ) draw_heart ( xofs , yofs ) oled . fill ( 0 ) for n in range ( 10 ): random_heart () oled . show ()","title":"Random Hearts"},{"location":"oled/14-random-hearts/#draw-random-hearts","text":"This program uses the MicroPython urandom library to generate random X and Y positions on the display. It then uses an array of binary values to draw a heart icon at that location. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from machine import Pin , PWM , SPI import urandom import ssd1306 from utime import sleep import random # random direction for new ball WIDTH = 128 HEIGHT = 64 CS = machine . Pin ( 1 ) spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) HEART = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], ] def draw_heart ( xofs , yofs ): for y , row in enumerate ( HEART ): for x , c in enumerate ( row ): oled . pixel ( x + xofs , y + yofs , c ) def random_heart (): xofs = urandom . getrandbits ( 7 ) yofs = urandom . getrandbits ( 6 ) print ( xofs , yofs ) draw_heart ( xofs , yofs ) oled . fill ( 0 ) for n in range ( 10 ): random_heart () oled . show ()","title":"Draw Random Hearts"},{"location":"oled/15-oled-patterns/","text":"OLED Patterns In this lesson, we will show how you can display interesting repeating patterns on your OLED screen. Our program will write a pattern into the framebuffer using a simple math equation. The oled.show() will then update the pattern on the display. This lesson was suggested by Parker Erickson. Math Functions We will use a few unusual functions to create repeating patterns: Modulo (%) Bitwise AND (&) The modulo function is written % . It returns the integer remainder after a division. So 7 % 3 is 1 and 7 % 4 is 3. The Power function of X to the Y power is written in python as pow(x,y) . For example pow(7, 2) is seven squared = 49. The bitwise and is written as x & y 1 2 for i in range ( 8 ): 13 & i Function Returns 13 & 0 0 13 & 1 1 13 & 2 0 13 & 3 1 13 & 4 4 13 & 5 5 13 & 6 4 13 & 7 5 13 & 8 8 13 & 9 9 13 & 10 8 13 & 11 9 13 & 12 12 Some Sample Equations x & y x % y (x ^ y) % 9 (x ^ y) % 5 (x ^ y) % 17 (x ^ y) % 33 (x * y) & 64 (x * y) & 24 (x * y) & 47 (x * 2) % y (x * 64) % y (x * 31) % y ((x-128) * 64) % (y-128) (x % y) % 4 (y % x) % 20 40 % (x % y) Note there are other patterns that use the power pow(x,y) or Exponentiation ** function but I can't get these to work with Micropython. Sample Code This program evaluates the function x % (y+1) for each of the pixels on the screen. If the function returns a non-zero the pixel will be off. If the pixel is zero, the pixel will be on. draw-patterns-ssd1306-spi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import machine import ssd1306 WIDTH = 128 HEIGHT = 64 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) oled . fill ( 0 ) # clear display for x in range ( WIDTH ): for y in range ( HEIGHT ): if x % ( y + 1 ): oled . pixel ( x , y , 0 ) else : oled . pixel ( x , y , 1 ) oled . show () Adding a List of Patterns The Eval Function The eval() function takes any string and passes it to the python interpreter for evaluation within the current context of variables that are in scope. We can use eval to pass an expression that should be evaluated to any function. 1 2 3 4 5 6 7 8 list = [ \"x+y\" , \"x-y\" , \"x*y\" , \"x % (y+1)\" ] for i in range ( 0 , 4 ): print ( list [ i ], ': ' , sep = '' , end = '' ) for x in range ( 5 ): for y in range ( 5 ): print ( eval ( list [ i ]), '' , end = '' ) print ( '' ) Output: 1 2 3 4 x+y: 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 x-y: 0 -1 -2 -3 -4 1 0 -1 -2 -3 2 1 0 -1 -2 3 2 1 0 -1 4 3 2 1 0 x*y: 0 0 0 0 0 0 1 2 3 4 0 2 4 6 8 0 3 6 9 12 0 4 8 12 16 x % (y+1): 0 0 0 0 0 0 1 1 1 1 0 0 2 2 2 0 1 0 3 3 0 0 1 0 4 The Command Design Pattern The command pattern holds a list of commands in an array. Each command is executed in the sequence it appears in the list of commands. In the following program we have the equations in a list. The program steps through each item in the list and displays that equation on the OLED display. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import machine import ssd1306 from utime import sleep , time WIDTH = 128 HEIGHT = 64 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) equations = [ '(x * y) & 24' , '(x * y) & 47' , '(x * y) & 64' , 'x & y' , 'x % y' , '(x % y) % 4' , '40 % (x % y+1)' ] for eqn in range ( 0 , len ( equations )): start = time () oled . fill ( 0 ) # clear display oled . text ( 'calculating' , 0 , 0 , 1 ) oled . text ( equations [ eqn ], 0 , 10 , 1 ) oled . show () for x in range ( WIDTH ): for y in range ( 1 , HEIGHT ): if eval ( equations [ eqn ]): oled . pixel ( x , y , 0 ) else : oled . pixel ( x , y , 1 ) oled . show () sleep ( 5 ) end = time () duration = str ( end - start ) print ( equations [ eqn ]) print ( duration , ' seconds' ) oled . text ( 'done' , 0 , 0 , 1 ) oled . show () print ( 'done' ) Sample Screen Images X Modulo Y x % y (x % y) % 4 Sierpinsky Triangles (x & y) Sierpinsky Triangles Bitwise and of x and y (x * y) & 24 (x * y) & 64 40 % x % (y+1) Reference Martin Kleppe Post on Twitter","title":"OLED Patterns"},{"location":"oled/15-oled-patterns/#oled-patterns","text":"In this lesson, we will show how you can display interesting repeating patterns on your OLED screen. Our program will write a pattern into the framebuffer using a simple math equation. The oled.show() will then update the pattern on the display. This lesson was suggested by Parker Erickson.","title":"OLED Patterns"},{"location":"oled/15-oled-patterns/#math-functions","text":"We will use a few unusual functions to create repeating patterns: Modulo (%) Bitwise AND (&) The modulo function is written % . It returns the integer remainder after a division. So 7 % 3 is 1 and 7 % 4 is 3. The Power function of X to the Y power is written in python as pow(x,y) . For example pow(7, 2) is seven squared = 49. The bitwise and is written as x & y 1 2 for i in range ( 8 ): 13 & i Function Returns 13 & 0 0 13 & 1 1 13 & 2 0 13 & 3 1 13 & 4 4 13 & 5 5 13 & 6 4 13 & 7 5 13 & 8 8 13 & 9 9 13 & 10 8 13 & 11 9 13 & 12 12","title":"Math Functions"},{"location":"oled/15-oled-patterns/#some-sample-equations","text":"x & y x % y (x ^ y) % 9 (x ^ y) % 5 (x ^ y) % 17 (x ^ y) % 33 (x * y) & 64 (x * y) & 24 (x * y) & 47 (x * 2) % y (x * 64) % y (x * 31) % y ((x-128) * 64) % (y-128) (x % y) % 4 (y % x) % 20 40 % (x % y) Note there are other patterns that use the power pow(x,y) or Exponentiation ** function but I can't get these to work with Micropython.","title":"Some Sample Equations"},{"location":"oled/15-oled-patterns/#sample-code","text":"This program evaluates the function x % (y+1) for each of the pixels on the screen. If the function returns a non-zero the pixel will be off. If the pixel is zero, the pixel will be on. draw-patterns-ssd1306-spi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import machine import ssd1306 WIDTH = 128 HEIGHT = 64 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) oled . fill ( 0 ) # clear display for x in range ( WIDTH ): for y in range ( HEIGHT ): if x % ( y + 1 ): oled . pixel ( x , y , 0 ) else : oled . pixel ( x , y , 1 ) oled . show ()","title":"Sample Code"},{"location":"oled/15-oled-patterns/#adding-a-list-of-patterns","text":"","title":"Adding a List of Patterns"},{"location":"oled/15-oled-patterns/#the-eval-function","text":"The eval() function takes any string and passes it to the python interpreter for evaluation within the current context of variables that are in scope. We can use eval to pass an expression that should be evaluated to any function. 1 2 3 4 5 6 7 8 list = [ \"x+y\" , \"x-y\" , \"x*y\" , \"x % (y+1)\" ] for i in range ( 0 , 4 ): print ( list [ i ], ': ' , sep = '' , end = '' ) for x in range ( 5 ): for y in range ( 5 ): print ( eval ( list [ i ]), '' , end = '' ) print ( '' ) Output: 1 2 3 4 x+y: 0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 x-y: 0 -1 -2 -3 -4 1 0 -1 -2 -3 2 1 0 -1 -2 3 2 1 0 -1 4 3 2 1 0 x*y: 0 0 0 0 0 0 1 2 3 4 0 2 4 6 8 0 3 6 9 12 0 4 8 12 16 x % (y+1): 0 0 0 0 0 0 1 1 1 1 0 0 2 2 2 0 1 0 3 3 0 0 1 0 4","title":"The Eval Function"},{"location":"oled/15-oled-patterns/#the-command-design-pattern","text":"The command pattern holds a list of commands in an array. Each command is executed in the sequence it appears in the list of commands. In the following program we have the equations in a list. The program steps through each item in the list and displays that equation on the OLED display. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import machine import ssd1306 from utime import sleep , time WIDTH = 128 HEIGHT = 64 spi_sck = machine . Pin ( 2 ) spi_tx = machine . Pin ( 3 ) spi = machine . SPI ( 0 , baudrate = 100000 , sck = spi_sck , mosi = spi_tx ) CS = machine . Pin ( 1 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) equations = [ '(x * y) & 24' , '(x * y) & 47' , '(x * y) & 64' , 'x & y' , 'x % y' , '(x % y) % 4' , '40 % (x % y+1)' ] for eqn in range ( 0 , len ( equations )): start = time () oled . fill ( 0 ) # clear display oled . text ( 'calculating' , 0 , 0 , 1 ) oled . text ( equations [ eqn ], 0 , 10 , 1 ) oled . show () for x in range ( WIDTH ): for y in range ( 1 , HEIGHT ): if eval ( equations [ eqn ]): oled . pixel ( x , y , 0 ) else : oled . pixel ( x , y , 1 ) oled . show () sleep ( 5 ) end = time () duration = str ( end - start ) print ( equations [ eqn ]) print ( duration , ' seconds' ) oled . text ( 'done' , 0 , 0 , 1 ) oled . show () print ( 'done' )","title":"The Command Design Pattern"},{"location":"oled/15-oled-patterns/#sample-screen-images","text":"","title":"Sample Screen Images"},{"location":"oled/15-oled-patterns/#x-modulo-y","text":"x % y","title":"X Modulo Y"},{"location":"oled/15-oled-patterns/#x-y-4","text":"","title":"(x % y) % 4"},{"location":"oled/15-oled-patterns/#sierpinsky-triangles-x-y","text":"Sierpinsky Triangles Bitwise and of x and y","title":"Sierpinsky Triangles (x &amp; y)"},{"location":"oled/15-oled-patterns/#x-y-24","text":"","title":"(x * y) &amp; 24"},{"location":"oled/15-oled-patterns/#x-y-64","text":"","title":"(x * y) &amp; 64"},{"location":"oled/15-oled-patterns/#40-x-y1","text":"","title":"40 % x % (y+1)"},{"location":"oled/15-oled-patterns/#reference","text":"Martin Kleppe Post on Twitter","title":"Reference"},{"location":"oled/40-oled-references/","text":"OLED References Analysis of OLED drawing performance using SPI interface Analysis of OLED drawing performance using SPI interface Example of displaying a complex animation on an OLED with SPI Video of the Above on YouTube Peter Hinch's MicroPython Nano GUI","title":"OLED References"},{"location":"oled/40-oled-references/#oled-references","text":"Analysis of OLED drawing performance using SPI interface Analysis of OLED drawing performance using SPI interface Example of displaying a complex animation on an OLED with SPI Video of the Above on YouTube Peter Hinch's MicroPython Nano GUI","title":"OLED References"},{"location":"robots/01-intro/","text":"Introduction to CoderDojo Pico Robots Robots are the most powerful learning machines in our CoderDojo project collections. The allow our students to control motion with their own programs. Not only are they incredibly fun for our students, they enable them to quickly proceed to our advanced AI Racing League projects. Robot Journey Map This section of the course takes you on a tour of our base $25 collision avoidance robots. It then builds on this robot by adding an OLED display, programming controls and servos. Here is a Journey Map of these lessons: Note that the $25 price assumes you purchase low-cost parts from suppliers like eBay. You can lower the cost per robot by purchasing the parts in higher quantities for classroom use. You can also purchase older Arduino robot kits and upgrade the processors to use the Raspberry Pi Pico. Base Bot - This is the foundational robot that the other projects are built on. The base includes a standard Smart Car chassis, two DC hobby motors, a battery pack and wheels. On top of the chassis we add a breadboard, jumpers, a motor controller, a distance sensor, and our $4 Raspberry Pi microcontroller. Rainbow Bot This takes our base robot and adds a low-cost LED strip so that students can change the color of the LED based on what the robot is sensing and doing. For example when the robot is turning right the LEDs can turn red. IR Sensor Bot This takes our base robot and adds a low-cost LED strip so that students can change the color of the LED based on what the robot is sensing and doing. For example when the robot is turning right the LEDs can turn red. Face Bot - We extend the Base Bot by adding a $4 128x64 OLED display. This allows students to see the values of the distance sensor and to hear a sound when a key event occurs. Parameter Bot - We extend the fac-bot to add some buttons and knobs to allow our users to change the collision avoidance parameters such as forward speed and turning threshold distance. Parts Our beginning Base Bot Chassis SmartCar Chassis Sensors Ping Ultrasonic Distance Sensor IR sensors Motor Controllers","title":"Introduction"},{"location":"robots/01-intro/#introduction-to-coderdojo-pico-robots","text":"Robots are the most powerful learning machines in our CoderDojo project collections. The allow our students to control motion with their own programs. Not only are they incredibly fun for our students, they enable them to quickly proceed to our advanced AI Racing League projects.","title":"Introduction to CoderDojo Pico Robots"},{"location":"robots/01-intro/#robot-journey-map","text":"This section of the course takes you on a tour of our base $25 collision avoidance robots. It then builds on this robot by adding an OLED display, programming controls and servos. Here is a Journey Map of these lessons: Note that the $25 price assumes you purchase low-cost parts from suppliers like eBay. You can lower the cost per robot by purchasing the parts in higher quantities for classroom use. You can also purchase older Arduino robot kits and upgrade the processors to use the Raspberry Pi Pico. Base Bot - This is the foundational robot that the other projects are built on. The base includes a standard Smart Car chassis, two DC hobby motors, a battery pack and wheels. On top of the chassis we add a breadboard, jumpers, a motor controller, a distance sensor, and our $4 Raspberry Pi microcontroller. Rainbow Bot This takes our base robot and adds a low-cost LED strip so that students can change the color of the LED based on what the robot is sensing and doing. For example when the robot is turning right the LEDs can turn red. IR Sensor Bot This takes our base robot and adds a low-cost LED strip so that students can change the color of the LED based on what the robot is sensing and doing. For example when the robot is turning right the LEDs can turn red. Face Bot - We extend the Base Bot by adding a $4 128x64 OLED display. This allows students to see the values of the distance sensor and to hear a sound when a key event occurs. Parameter Bot - We extend the fac-bot to add some buttons and knobs to allow our users to change the collision avoidance parameters such as forward speed and turning threshold distance.","title":"Robot Journey Map"},{"location":"robots/01-intro/#parts","text":"Our beginning Base Bot","title":"Parts"},{"location":"robots/01-intro/#chassis","text":"SmartCar Chassis","title":"Chassis"},{"location":"robots/01-intro/#sensors","text":"Ping Ultrasonic Distance Sensor IR sensors","title":"Sensors"},{"location":"robots/01-intro/#motor-controllers","text":"","title":"Motor Controllers"},{"location":"robots/02-base-bot/","text":"Raspberry Pi Pico Micropython Base Robot This lesson describes out base robot kit in the CoderDojo Twin Cities coding club. This is a new robot that in programmed entirely in python to be consistent with our Python Courses . Base Robot Design Our goal is to build a robotics platform for teaching computational thinking. Here are our main design goals: Low cost (under $25) so that most students can afford their own robot Open platform to make it easy to upgrade (sustainably) Interchangeable parts Minimal amount of soldering Video Here is a video of the collision avoidance robot in action: YouTube Video Note that the forward-speed and distance-before-you-turn can be adjusted. You can see I didn't quite get the distance right and the robot bumps into some of the barriers. Connection Diagram Here is a connection diagram of the base robot. Power Regulation Note that the power comes from the battery at 6 volts and is connected to the input voltage of the motor controller board. The motor controller has a voltage regulator that converts any input voltage from 6 to 12 volts down to 5 volts. The output voltage of the motor controller is then connected to the power rail on the left, which is in turn connected to the VSYS input to the Pico. The Pico, in turn, has another voltage regulator that drop the input from VSYS down to 3.3 volts on the 3.3V OUT pin. This voltage is then used to power the distance sensor. One of the downsides to this design is that as the batteries get low, once they drop below around 5 volts the double voltage drops cause the 3.3 OUT to become too low and the sensor becomes unreliable. A better design would be to find a motor controller that produces a stable 3.3 volts as the batteries slowly run down. Let us know if you can find one of these designs that cost under $2. Hardware Description Here is a summary of some of the parts we use in this robot and their approximate prices as of June 2021. Some parts come from China so you might need to wait 2-3 weeks for them to arrive. Here is a Google sheet with these parts: Detailed Parts List Google Sheet Motor Driver Time-of-Flight Distance Sensor Software All software is written in Python. You must include the driver for the Distance Sensor We are using the VL53L0X time-of-flight distance sensor. This works on an I2C bus. After you have hooked up the Power (VCC to the 3.3 rail and GND) you must hook up the I2C data and clock. 1 2 3 sda = machine . Pin ( 16 ) # Lower right corner of the Pico with the USB on top scl = machine . Pin ( 17 ) # One up from the lower right corner of the Pico i2c = machine . I2C ( 0 , sda = sda , scl = scl ) Testing the Sensor Connections with the I2C Scanner 1 2 3 4 5 import machine sda = machine . Pin ( 16 ) # Lower right corner of the Pico with the USB on top scl = machine . Pin ( 17 ) # One up from the lower right corner of the Pico i2c = machine . I2C ( 0 , sda = sda , scl = scl ) print ( \"Device found at decimal\" , i2c . scan ()) You should see a decimal number returned. By default the I2C address is 41 (decimal) or x29 (hexadecimal). Download the VL53L0X Driver You will need to add a VL53L0X driver file to the file system on the pico. We have a copy here: https://raw.githubusercontent.com/CoderDojoTC/micropython/main/src/drivers/VL53L0X.py Time-of-Flight Sensor Test Once the driver file is loaded we are ready to test the time-of-flight distance sensor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import time from machine import Pin from machine import I2C import VL53L0X sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) tof . start () # startup the sensor while True : # Start ranging dist = tof . read () print ( dist ) time . sleep ( . 1 ) When you run this program a sequence of integers will appear in the console. The numbers usually will range from around 30 if there is an object directly in front of the sensor to a number around 1,300 for a object that is about 1.3 meters away from the sensor. There is a 1/10th of a second pause between each measurement. This can be changed in the last line of the program. Motor Drive Test After we have the four wires connected to the motor driver, we need to make sure we get the right wires to the right motors and motor directions. This program will help you debug this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from machine import Pin , PWM import time # sleep POWER_LEVEL = 65025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse ) One thing to remember is that the \"Right\" refers to our orientation from the rear of the car or if we were sitting inside the car. If the robot is facing you with the sensor in the front, it is the wheel on the left that we call the \"RIGHT\" wheel. Very confusing! Using this naming convention will pay of as we are walking behind larger robots. Sample Drive and Turn Functions We will need a set of function to drive our robot: Forward: both wheels going forward Reverse: both wheels going in reverse Turn Right: The right wheel turning backward and the left going forward Turn Left: The left wheel turning backward and the right wheel going forward Stop: all motors off Our challenge is for each of these operations we must change the value of all four PWM signals. We can never have a motor be going both forward and reverse. Here are some sample drive functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) Turning Logic 1 2 3 4 5 6 7 8 9 10 while True : dist = read_sensor () if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () sleep ( BACKUP_TIME ) turn_right () sleep ( TURN_TIME ) else : forward () Test Motor Connections 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from machine import Pin , PWM import time # sleep POWER_LEVEL = 65025 # usually a number from 30,000 to max of 65,025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse ) After you load this program, watch which wheels turn and in what direction. Drive Functions We will define Python functions for forward, reverse, turn right and turn left. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 POWER_LEVEL = 65025 def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) Stop All Motors Program One other thing to remember is that the PWM signals continue to be generated even after the main loop has stopped. This is because on the Pico, the four PWM signals are being continuously generated by an independent processors. To stop the motors you must run a separate stop program like this: stop-all-motors.py: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from machine import Pin , PWM from time import sleep # lower right pins with USB on top RIGHT_FORWARD_PIN = 19 RIGHT_REVERSE_PIN = 21 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 20 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) right_forward . duty_u16 ( 0 ) right_reverse . duty_u16 ( 0 ) left_forward . duty_u16 ( 0 ) left_reverse . duty_u16 ( 0 ) This can be frustrating at times when you can't find the stop program. I like to bring the stop program up in a separate tab when I am writing robot motor code. To figure out how to write an interrup handler so that when the IDE STOP function is pressed the stop motors (and speaker) are stopped. Collision Avoidance Logic Final Program To get this to work on battery power up you must name the program main.py and save it on the Raspberry Pi Pico. Note Make sure you have the VL53L0X distance sensor driver installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 from machine import Pin , PWM from utime import sleep import VL53L0X # used to blink the onboard LED led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) # driving parameters POWER_LEVEL = 65025 # use a value from 20000 to 65025 TURN_THRESHOLD = 400 # 25 cm TURN_TIME = . 25 # seconds of turning BACKUP_TIME = . 75 # seconds of backing up if obstacle detected # Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 # setup the PWM objects right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) def read_sensor_avg (): total = 0 for i in range ( 10 ): total = total + tof . read () sleep ( . 01 ) return int ( total / 10 ) tof . start () # startup the sensor while True : dist = read_sensor_avg (); print ( dist ) if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () sleep ( BACKUP_TIME ) led_onboard . high () turn_right () sleep ( TURN_TIME ) else : if dist > 1300 : print ( 'no signal' ) led_onboard . low () else : print ( 'Go forward' ) led_onboard . high () forward () More To Explore Labs Can you change the hard-coded parameters at the begging of the program? What happens when you make the POWER_LEVEL go too high and the TURN_THRESHOLD too low? What is the lowest POWER_LEVEL that will allow the robot to move? What if you changed the power from 6 volts to be 9 volts by adding two more AA batteries? Can you randomly turn right or left if you encounter and object? Note you will need to import the random library and generate a random number between 0 and 2 with the random.randint(0,2) function. How would you design a robot that you could adjust the parameters? What parameters would you change? What would their valid ranges be?","title":"Base Bot"},{"location":"robots/02-base-bot/#raspberry-pi-pico-micropython-base-robot","text":"This lesson describes out base robot kit in the CoderDojo Twin Cities coding club. This is a new robot that in programmed entirely in python to be consistent with our Python Courses .","title":"Raspberry Pi Pico Micropython Base Robot"},{"location":"robots/02-base-bot/#base-robot-design","text":"Our goal is to build a robotics platform for teaching computational thinking. Here are our main design goals: Low cost (under $25) so that most students can afford their own robot Open platform to make it easy to upgrade (sustainably) Interchangeable parts Minimal amount of soldering","title":"Base Robot Design"},{"location":"robots/02-base-bot/#video","text":"Here is a video of the collision avoidance robot in action: YouTube Video Note that the forward-speed and distance-before-you-turn can be adjusted. You can see I didn't quite get the distance right and the robot bumps into some of the barriers.","title":"Video"},{"location":"robots/02-base-bot/#connection-diagram","text":"Here is a connection diagram of the base robot.","title":"Connection Diagram"},{"location":"robots/02-base-bot/#power-regulation","text":"Note that the power comes from the battery at 6 volts and is connected to the input voltage of the motor controller board. The motor controller has a voltage regulator that converts any input voltage from 6 to 12 volts down to 5 volts. The output voltage of the motor controller is then connected to the power rail on the left, which is in turn connected to the VSYS input to the Pico. The Pico, in turn, has another voltage regulator that drop the input from VSYS down to 3.3 volts on the 3.3V OUT pin. This voltage is then used to power the distance sensor. One of the downsides to this design is that as the batteries get low, once they drop below around 5 volts the double voltage drops cause the 3.3 OUT to become too low and the sensor becomes unreliable. A better design would be to find a motor controller that produces a stable 3.3 volts as the batteries slowly run down. Let us know if you can find one of these designs that cost under $2.","title":"Power Regulation"},{"location":"robots/02-base-bot/#hardware-description","text":"Here is a summary of some of the parts we use in this robot and their approximate prices as of June 2021. Some parts come from China so you might need to wait 2-3 weeks for them to arrive. Here is a Google sheet with these parts: Detailed Parts List Google Sheet","title":"Hardware Description"},{"location":"robots/02-base-bot/#motor-driver","text":"","title":"Motor Driver"},{"location":"robots/02-base-bot/#time-of-flight-distance-sensor","text":"","title":"Time-of-Flight Distance Sensor"},{"location":"robots/02-base-bot/#software","text":"All software is written in Python. You must include the driver for the","title":"Software"},{"location":"robots/02-base-bot/#distance-sensor","text":"We are using the VL53L0X time-of-flight distance sensor. This works on an I2C bus. After you have hooked up the Power (VCC to the 3.3 rail and GND) you must hook up the I2C data and clock. 1 2 3 sda = machine . Pin ( 16 ) # Lower right corner of the Pico with the USB on top scl = machine . Pin ( 17 ) # One up from the lower right corner of the Pico i2c = machine . I2C ( 0 , sda = sda , scl = scl )","title":"Distance Sensor"},{"location":"robots/02-base-bot/#testing-the-sensor-connections-with-the-i2c-scanner","text":"1 2 3 4 5 import machine sda = machine . Pin ( 16 ) # Lower right corner of the Pico with the USB on top scl = machine . Pin ( 17 ) # One up from the lower right corner of the Pico i2c = machine . I2C ( 0 , sda = sda , scl = scl ) print ( \"Device found at decimal\" , i2c . scan ()) You should see a decimal number returned. By default the I2C address is 41 (decimal) or x29 (hexadecimal).","title":"Testing the Sensor Connections with the I2C Scanner"},{"location":"robots/02-base-bot/#download-the-vl53l0x-driver","text":"You will need to add a VL53L0X driver file to the file system on the pico. We have a copy here: https://raw.githubusercontent.com/CoderDojoTC/micropython/main/src/drivers/VL53L0X.py","title":"Download the VL53L0X Driver"},{"location":"robots/02-base-bot/#time-of-flight-sensor-test","text":"Once the driver file is loaded we are ready to test the time-of-flight distance sensor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import time from machine import Pin from machine import I2C import VL53L0X sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) tof . start () # startup the sensor while True : # Start ranging dist = tof . read () print ( dist ) time . sleep ( . 1 ) When you run this program a sequence of integers will appear in the console. The numbers usually will range from around 30 if there is an object directly in front of the sensor to a number around 1,300 for a object that is about 1.3 meters away from the sensor. There is a 1/10th of a second pause between each measurement. This can be changed in the last line of the program.","title":"Time-of-Flight Sensor Test"},{"location":"robots/02-base-bot/#motor-drive-test","text":"After we have the four wires connected to the motor driver, we need to make sure we get the right wires to the right motors and motor directions. This program will help you debug this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from machine import Pin , PWM import time # sleep POWER_LEVEL = 65025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse ) One thing to remember is that the \"Right\" refers to our orientation from the rear of the car or if we were sitting inside the car. If the robot is facing you with the sensor in the front, it is the wheel on the left that we call the \"RIGHT\" wheel. Very confusing! Using this naming convention will pay of as we are walking behind larger robots.","title":"Motor Drive Test"},{"location":"robots/02-base-bot/#sample-drive-and-turn-functions","text":"We will need a set of function to drive our robot: Forward: both wheels going forward Reverse: both wheels going in reverse Turn Right: The right wheel turning backward and the left going forward Turn Left: The left wheel turning backward and the right wheel going forward Stop: all motors off Our challenge is for each of these operations we must change the value of all four PWM signals. We can never have a motor be going both forward and reverse. Here are some sample drive functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse )","title":"Sample Drive and Turn Functions"},{"location":"robots/02-base-bot/#turning-logic","text":"1 2 3 4 5 6 7 8 9 10 while True : dist = read_sensor () if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () sleep ( BACKUP_TIME ) turn_right () sleep ( TURN_TIME ) else : forward ()","title":"Turning Logic"},{"location":"robots/02-base-bot/#test-motor-connections","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from machine import Pin , PWM import time # sleep POWER_LEVEL = 65025 # usually a number from 30,000 to max of 65,025 # lower right pins with USB on top RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) def spin_wheel ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) time . sleep ( 3 ) pwm . duty_u16 ( 0 ) time . sleep ( 2 ) while True : print ( 'right forward' ) spin_wheel ( right_forward ) print ( 'right reverse' ) spin_wheel ( right_reverse ) print ( 'left foward' ) spin_wheel ( left_forward ) print ( 'left_reverse' ) spin_wheel ( left_reverse ) After you load this program, watch which wheels turn and in what direction.","title":"Test Motor Connections"},{"location":"robots/02-base-bot/#drive-functions","text":"We will define Python functions for forward, reverse, turn right and turn left. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 POWER_LEVEL = 65025 def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse )","title":"Drive Functions"},{"location":"robots/02-base-bot/#stop-all-motors-program","text":"One other thing to remember is that the PWM signals continue to be generated even after the main loop has stopped. This is because on the Pico, the four PWM signals are being continuously generated by an independent processors. To stop the motors you must run a separate stop program like this: stop-all-motors.py: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from machine import Pin , PWM from time import sleep # lower right pins with USB on top RIGHT_FORWARD_PIN = 19 RIGHT_REVERSE_PIN = 21 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 20 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) right_forward . duty_u16 ( 0 ) right_reverse . duty_u16 ( 0 ) left_forward . duty_u16 ( 0 ) left_reverse . duty_u16 ( 0 ) This can be frustrating at times when you can't find the stop program. I like to bring the stop program up in a separate tab when I am writing robot motor code. To figure out how to write an interrup handler so that when the IDE STOP function is pressed the stop motors (and speaker) are stopped.","title":"Stop All Motors Program"},{"location":"robots/02-base-bot/#collision-avoidance-logic","text":"","title":"Collision Avoidance Logic"},{"location":"robots/02-base-bot/#final-program","text":"To get this to work on battery power up you must name the program main.py and save it on the Raspberry Pi Pico. Note Make sure you have the VL53L0X distance sensor driver installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 from machine import Pin , PWM from utime import sleep import VL53L0X # used to blink the onboard LED led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) # driving parameters POWER_LEVEL = 65025 # use a value from 20000 to 65025 TURN_THRESHOLD = 400 # 25 cm TURN_TIME = . 25 # seconds of turning BACKUP_TIME = . 75 # seconds of backing up if obstacle detected # Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 21 RIGHT_REVERSE_PIN = 20 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 # setup the PWM objects right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) def read_sensor_avg (): total = 0 for i in range ( 10 ): total = total + tof . read () sleep ( . 01 ) return int ( total / 10 ) tof . start () # startup the sensor while True : dist = read_sensor_avg (); print ( dist ) if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () sleep ( BACKUP_TIME ) led_onboard . high () turn_right () sleep ( TURN_TIME ) else : if dist > 1300 : print ( 'no signal' ) led_onboard . low () else : print ( 'Go forward' ) led_onboard . high () forward ()","title":"Final Program"},{"location":"robots/02-base-bot/#more-to-explore-labs","text":"Can you change the hard-coded parameters at the begging of the program? What happens when you make the POWER_LEVEL go too high and the TURN_THRESHOLD too low? What is the lowest POWER_LEVEL that will allow the robot to move? What if you changed the power from 6 volts to be 9 volts by adding two more AA batteries? Can you randomly turn right or left if you encounter and object? Note you will need to import the random library and generate a random number between 0 and 2 with the random.randint(0,2) function. How would you design a robot that you could adjust the parameters? What parameters would you change? What would their valid ranges be?","title":"More To Explore Labs"},{"location":"robots/03-ir-sensor-bot/","text":"IR Collision Avoidance Bot Instead of our time-of-flight sensor used in our base robot, this robot uses three low-cost IR distance sensors. Purchasing IR Distance Sensors Connecting the IR Sensors 1 2 3 4 # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) Connecting the Speaker This robot has an optional speaker connected to GPIO Pin 21. This allows us to \"hear\" what signals are coming into the robot It will generate a different tone if the left, center or right sensor is detecting an object and an different tone for going straight, reversing and turning. The speaker is a small buzzer or a Piezoelectric speaker that can be purchased for around $1. It has one wire connected to the GPIO pin and the other connected to any GND pin or GND rail on the breadboard. Here are the lines related to setting up the speaker code. 1 2 3 SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) Drive Logic The three IR sensors go LOW if there is an item in front of them. So the statement: 1 center . value () will normally be HIGH if there is nothing in front of the robot. Our main logic look will look like the following: 1 2 3 4 5 6 7 8 9 while True : if left . value () == 0 : turn_right () if center . value () == 0 : reverse () if right . value () == 0 : turn_left () if left . value () and center . value () and right . value (): forward () Full Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 from machine import Pin , PWM from utime import sleep import ssd1306 # Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 17 RIGHT_REVERSE_PIN = 16 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) WIDTH = 128 HEIGHT = 64 CS = machine . Pin ( 1 ) SCL = machine . Pin ( 2 ) SDA = machine . Pin ( 3 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) spi = machine . SPI ( 0 , sck = SCL , mosi = SDA ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) def turn_motor_on ( pwm ): pwm . duty_u16 ( 65025 ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) def sound_off (): speaker . duty_u16 ( 0 ) def left_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 700 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second sound_off () def center_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 900 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 5 ) sound_off () def forward_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 1 ) speaker . freq ( 900 ) sleep ( . 1 ) speaker . freq ( 1200 ) sleep ( . 1 ) sound_off () def update_oled (): oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks!\" , 0 , 0 , 1 ) oled . text ( \"Left:\" , 0 , 10 , 1 ) oled . text ( str ( left . value ()), 50 , 10 , 1 ) oled . text ( \"Center:\" , 0 , 20 , 1 ) oled . text ( str ( center . value ()), 60 , 20 , 1 ) oled . text ( \"Right:\" , 0 , 30 , 1 ) oled . text ( str ( right . value ()), 55 , 30 , 1 ) BAR_WIDTH = 40 BAR_HEIGHT = 20 if left . value (): oled . fill_rect ( WIDTH - 40 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( WIDTH - 40 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) if center . value (): oled . fill_rect ( 50 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( 50 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) if right . value (): oled . fill_rect ( 0 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( 0 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) oled . show () # 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 counter = 0 while True : if left . value () == 0 : print ( 'Left' ) #left_tone() turn_right () update_oled () drive_state = 2 if center . value () == 0 : print ( 'Center' ) center_tone () reverse () update_oled () drive_state = 0 if right . value () == 0 : print ( 'Right' ) #right_tone() turn_left () update_oled () drive_state = 3 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left . value () and center . value () and right . value (): print ( 'Go forward!' ) drive_state = 1 # forward_tone() forward () update_oled () print ( \"counter: \" , counter ) counter += 1 sleep ( . 25 ) Pins GP6, 7, 8 and 9","title":"IR Sensor Bot"},{"location":"robots/03-ir-sensor-bot/#ir-collision-avoidance-bot","text":"Instead of our time-of-flight sensor used in our base robot, this robot uses three low-cost IR distance sensors.","title":"IR Collision Avoidance Bot"},{"location":"robots/03-ir-sensor-bot/#purchasing-ir-distance-sensors","text":"","title":"Purchasing IR Distance Sensors"},{"location":"robots/03-ir-sensor-bot/#connecting-the-ir-sensors","text":"1 2 3 4 # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN )","title":"Connecting the IR Sensors"},{"location":"robots/03-ir-sensor-bot/#connecting-the-speaker","text":"This robot has an optional speaker connected to GPIO Pin 21. This allows us to \"hear\" what signals are coming into the robot It will generate a different tone if the left, center or right sensor is detecting an object and an different tone for going straight, reversing and turning. The speaker is a small buzzer or a Piezoelectric speaker that can be purchased for around $1. It has one wire connected to the GPIO pin and the other connected to any GND pin or GND rail on the breadboard. Here are the lines related to setting up the speaker code. 1 2 3 SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN ))","title":"Connecting the Speaker"},{"location":"robots/03-ir-sensor-bot/#drive-logic","text":"The three IR sensors go LOW if there is an item in front of them. So the statement: 1 center . value () will normally be HIGH if there is nothing in front of the robot. Our main logic look will look like the following: 1 2 3 4 5 6 7 8 9 while True : if left . value () == 0 : turn_right () if center . value () == 0 : reverse () if right . value () == 0 : turn_left () if left . value () and center . value () and right . value (): forward ()","title":"Drive Logic"},{"location":"robots/03-ir-sensor-bot/#full-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 from machine import Pin , PWM from utime import sleep import ssd1306 # Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 17 RIGHT_REVERSE_PIN = 16 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) WIDTH = 128 HEIGHT = 64 CS = machine . Pin ( 1 ) SCL = machine . Pin ( 2 ) SDA = machine . Pin ( 3 ) DC = machine . Pin ( 4 ) RES = machine . Pin ( 5 ) spi = machine . SPI ( 0 , sck = SCL , mosi = SDA ) oled = ssd1306 . SSD1306_SPI ( WIDTH , HEIGHT , spi , DC , RES , CS ) def turn_motor_on ( pwm ): pwm . duty_u16 ( 65025 ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) def sound_off (): speaker . duty_u16 ( 0 ) def left_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 700 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second sound_off () def center_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 900 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 600 ) sleep ( . 5 ) sound_off () def forward_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 1 ) speaker . freq ( 900 ) sleep ( . 1 ) speaker . freq ( 1200 ) sleep ( . 1 ) sound_off () def update_oled (): oled . fill ( 0 ) oled . text ( \"CoderDojo Rocks!\" , 0 , 0 , 1 ) oled . text ( \"Left:\" , 0 , 10 , 1 ) oled . text ( str ( left . value ()), 50 , 10 , 1 ) oled . text ( \"Center:\" , 0 , 20 , 1 ) oled . text ( str ( center . value ()), 60 , 20 , 1 ) oled . text ( \"Right:\" , 0 , 30 , 1 ) oled . text ( str ( right . value ()), 55 , 30 , 1 ) BAR_WIDTH = 40 BAR_HEIGHT = 20 if left . value (): oled . fill_rect ( WIDTH - 40 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( WIDTH - 40 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) if center . value (): oled . fill_rect ( 50 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( 50 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) if right . value (): oled . fill_rect ( 0 , 50 , BAR_WIDTH , BAR_HEIGHT , 0 ) else : oled . fill_rect ( 0 , 50 , BAR_WIDTH , BAR_HEIGHT , 1 ) oled . show () # 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 counter = 0 while True : if left . value () == 0 : print ( 'Left' ) #left_tone() turn_right () update_oled () drive_state = 2 if center . value () == 0 : print ( 'Center' ) center_tone () reverse () update_oled () drive_state = 0 if right . value () == 0 : print ( 'Right' ) #right_tone() turn_left () update_oled () drive_state = 3 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left . value () and center . value () and right . value (): print ( 'Go forward!' ) drive_state = 1 # forward_tone() forward () update_oled () print ( \"counter: \" , counter ) counter += 1 sleep ( . 25 ) Pins GP6, 7, 8 and 9","title":"Full Program"},{"location":"robots/03-rainbow-bot/","text":"Rainbow Bot This robot takes our base robot and adds an LED strip arranged in a 12X6 pixel grid to display colors and patterns based on what the robot is doing or thinking about. We use the same materials as our Base Robot but we add a low-cost addressable LED strips that are easy to hook up with just power, ground and data wires added to our breadboard. The LED is known as an addressable LED strip since you can individually program each LED. The standard is called the WS-2812B LED strip and is often called a NeoPixel LED strip (The Adafruit Term). We also used a Python library called a Neopixel micropython library, although the library is not created or maintained by Adafruit. Of course, you can also add longer LED strips and program the patterns in interesting ways. Part 1: Ordering The LED Strip The LED strips come in a variety of lengths, density and packing. We use the 1 meter long strips that have 60 pixels/meter. These strips are easy to cut apart and solder. We like the black backgrounds but they also come with white. The LED strips come with three packaging options: No waterproofing - these are fine for our indoor robots Waterproofing with the strips coated in silicon rubber called IP65 waterproofing Waterproofing with the strips encased in a flexible rubber sleeve The waterproofing options tend to be a little more expensive but can also provide a bit more protection for the components on the strips. Waterproofing keeps moisture and dust out of the circuits, but does not mean that they can be submerged under water. A sample place to purchase them is here We can take a $3 strip of 60 LEDs and cut them up into six segments of 10 LEDs each for a cost of around 50 cents per strip. We solder stranded wire to the segments and then put 22 gauge solid wire to make them easy to put in the breadboards. Connecting the LED Strips Adding a Standoff Upgrading to 9 Volt Power Our base robot only needed power for the motors. This robot has 72 RGB LEDs so it might draw more power. So we upgraded the 6 volt battery pack with 4 AA batteries to two packs of 3 batteries for a total of 9 volts. This allows the robot to continue to run even when the batteries are partially drained. The battery packs must be wired in series to deliver the full 9 volts to the input of the motor controller where it powers the motors and also runs though a voltage regulator to power the reset of the robot. 72 Pixel Configuration Here is the top view of the LEDs shining through the clear plexiglass. You can see the individual LEDs in this configuration. By adding a small space between the plexiglass and a diffusion layer you can get a much more uniform color distribution over the top surface of the robot. Part 2: Making The Connections The LED strips use 5 volts of power and have a GND and a data connector. To make the connections we connect the center pin to Pin 0 (upper left corner of the Pico), the GND to the ground rail and the 5 volt to the 5 volt power rail. Part 3: Adding the Neopixel Library Part 4: Testing Your Code In our first test, we will just make the first pixel on the LED strip blink bright red. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import machine , neopixel , time # Set the pin number and number of pixels LED_PIN = machine . Pin ( 4 ) NUMBER_PIXELS = 12 np = neopixel . NeoPixel ( LED_PIN , NUMBER_PIXELS ) # blink the first pixel red while True : np [ 0 ] = ( 255 , 0 , 0 ) np . write () time . sleep ( 1 ) np [ 0 ] = ( 0 , 0 , 0 ) np . write () time . sleep ( 1 ) Functions For Drawing on Matrix The numbering of the pixels is a bit odd. The first 12 are 0 to 11, but the second 12 pixels are in reverse order, so the second row counts from 23 down to 13. Here are some functions that demonstrate this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import time from neopixel import Neopixel numpix = 72 strip = Neopixel ( numpix , 0 , 0 , \"GRB\" ) red = ( 255 , 0 , 0 ) orange = ( 255 , 150 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) colors = ( red , orange , yellow , green , blue , indigo , violet ) strip . brightness ( 255 ) def color_wipe (): for color in colors : for i in range ( numpix ): strip . set_pixel ( i , color ) strip . show () time . sleep ( 0.01 ) def color_wipe_2 (): for color in colors : for i in range ( 12 ): strip . set_pixel ( i , color ) strip . set_pixel ( i + 12 , color ) strip . set_pixel ( i + 24 , color ) strip . set_pixel ( i + 36 , color ) strip . set_pixel ( i + 48 , color ) strip . set_pixel ( i + 60 , color ) strip . show () time . sleep ( 0.01 ) def color_wipe_3 (): for color in colors : for i in range ( 12 ): strip . set_pixel ( i , color ) strip . set_pixel ( 23 - i , color ) strip . set_pixel ( i + 24 , color ) strip . set_pixel ( 47 - i , color ) strip . set_pixel ( 48 + i , color ) strip . set_pixel ( 71 - i , color ) strip . show () time . sleep ( 0.3 ) # offset is the color to start (0 to 6) # dir is 1 for forward and -1 for reverse def color_wipe_4 ( offset , dir ): for i in range ( 12 ): if dir == 1 : this_color = colors [ (( i - offset ) % 7 )] else : this_color = colors [ (( i + offset ) % 7 )] strip . set_pixel ( i , this_color ) strip . set_pixel ( 23 - i , this_color ) strip . set_pixel ( i + 24 , this_color ) strip . set_pixel ( 47 - i , this_color ) strip . set_pixel ( 48 + i , this_color ) strip . set_pixel ( 71 - i , this_color ) strip . show () # time.sleep(0.01) while True : for counter in range ( 100 ): color_wipe_4 ( counter % 7 , 1 ) for counter in range ( 100 ): color_wipe_4 ( counter % 7 , - 1 ) Full Source Code We now combine the motor controls, the distance sensor and the LED functions so that a moving rainbow pattern moves from to back as the robot moves forward. If the robot encounters an obstacle, the robot will backup and change the direction of the rainbow. After it backs up a bit it will turn and move forward again. main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 from machine import Pin , PWM from time import sleep from machine import Pin from machine import I2C import VL53L0X from neopixel import Neopixel # Motor Code # lower right pins with USB on top RIGHT_FORWARD_PIN = 19 RIGHT_REVERSE_PIN = 18 LEFT_FORWARD_PIN = 20 LEFT_REVERSE_PIN = 21 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # Sensor Code sda = machine . Pin ( 16 ) scl = machine . Pin ( 17 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) tof . start () # startup the sensor # used to blink the onboard LED led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) # LED Code numpix = 72 strip = Neopixel ( numpix , 0 , 0 , \"GRB\" ) # we turn the brightness way down to not oversaturate the brightness in the video strip . brightness ( 20 ) # driving parameters POWER_LEVEL = 30000 # use a value from 20000 to 65025 TURN_THRESHOLD = 400 # 25 cm TURN_TIME = . 25 # seconds of turning BACKUP_TIME = . 75 # seconds of backing up if obstacle detected red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) colors = ( red , orange , yellow , green , blue , indigo , violet ) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) #for i in range(numpix): # strip.set_pixel(i, green) #strip.show() def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) #for i in range(numpix): # strip.set_pixel(i, red) #strip.show() def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) #for i in range(numpix): # strip.set_pixel(i, blue) #strip.show() def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) #for i in range(numpix): # strip.set_pixel(i, yellow) #strip.show() def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) for i in range ( numpix ): strip . set_pixel ( i , violet ) strip . show () def read_sensor_avg (): total = 0 for i in range ( 10 ): total = total + tof . read () sleep ( . 01 ) return int ( total / 10 ) # offset is the color to start (0 to 6) # dir is 1 for forward and -1 for reverse def color_wipe_4 ( offset , dir ): for i in range ( 12 ): if dir == 1 : this_color = colors [ (( i - offset ) % 7 )] else : this_color = colors [ (( i + offset ) % 7 )] strip . set_pixel ( i , this_color ) strip . set_pixel ( 23 - i , this_color ) strip . set_pixel ( i + 24 , this_color ) strip . set_pixel ( 47 - i , this_color ) strip . set_pixel ( 48 + i , this_color ) strip . set_pixel ( 71 - i , this_color ) strip . show () # time.sleep(0.01) counter = 0 while True : dist = read_sensor_avg () if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 turn_right () color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 else : forward () color_wipe_4 ( counter % 7 , 1 ) counter += 1 Rainbow Bot Source Code References Micropython NeoPixel Library","title":"Rainbow Bot"},{"location":"robots/03-rainbow-bot/#rainbow-bot","text":"This robot takes our base robot and adds an LED strip arranged in a 12X6 pixel grid to display colors and patterns based on what the robot is doing or thinking about. We use the same materials as our Base Robot but we add a low-cost addressable LED strips that are easy to hook up with just power, ground and data wires added to our breadboard. The LED is known as an addressable LED strip since you can individually program each LED. The standard is called the WS-2812B LED strip and is often called a NeoPixel LED strip (The Adafruit Term). We also used a Python library called a Neopixel micropython library, although the library is not created or maintained by Adafruit. Of course, you can also add longer LED strips and program the patterns in interesting ways.","title":"Rainbow Bot"},{"location":"robots/03-rainbow-bot/#part-1-ordering-the-led-strip","text":"The LED strips come in a variety of lengths, density and packing. We use the 1 meter long strips that have 60 pixels/meter. These strips are easy to cut apart and solder. We like the black backgrounds but they also come with white. The LED strips come with three packaging options: No waterproofing - these are fine for our indoor robots Waterproofing with the strips coated in silicon rubber called IP65 waterproofing Waterproofing with the strips encased in a flexible rubber sleeve The waterproofing options tend to be a little more expensive but can also provide a bit more protection for the components on the strips. Waterproofing keeps moisture and dust out of the circuits, but does not mean that they can be submerged under water. A sample place to purchase them is here We can take a $3 strip of 60 LEDs and cut them up into six segments of 10 LEDs each for a cost of around 50 cents per strip. We solder stranded wire to the segments and then put 22 gauge solid wire to make them easy to put in the breadboards.","title":"Part 1: Ordering The LED Strip"},{"location":"robots/03-rainbow-bot/#connecting-the-led-strips","text":"","title":"Connecting the LED Strips"},{"location":"robots/03-rainbow-bot/#adding-a-standoff","text":"","title":"Adding a Standoff"},{"location":"robots/03-rainbow-bot/#upgrading-to-9-volt-power","text":"Our base robot only needed power for the motors. This robot has 72 RGB LEDs so it might draw more power. So we upgraded the 6 volt battery pack with 4 AA batteries to two packs of 3 batteries for a total of 9 volts. This allows the robot to continue to run even when the batteries are partially drained. The battery packs must be wired in series to deliver the full 9 volts to the input of the motor controller where it powers the motors and also runs though a voltage regulator to power the reset of the robot.","title":"Upgrading to 9 Volt Power"},{"location":"robots/03-rainbow-bot/#72-pixel-configuration","text":"Here is the top view of the LEDs shining through the clear plexiglass. You can see the individual LEDs in this configuration. By adding a small space between the plexiglass and a diffusion layer you can get a much more uniform color distribution over the top surface of the robot.","title":"72 Pixel Configuration"},{"location":"robots/03-rainbow-bot/#part-2-making-the-connections","text":"The LED strips use 5 volts of power and have a GND and a data connector. To make the connections we connect the center pin to Pin 0 (upper left corner of the Pico), the GND to the ground rail and the 5 volt to the 5 volt power rail.","title":"Part 2: Making The Connections"},{"location":"robots/03-rainbow-bot/#part-3-adding-the-neopixel-library","text":"","title":"Part 3: Adding the Neopixel Library"},{"location":"robots/03-rainbow-bot/#part-4-testing-your-code","text":"In our first test, we will just make the first pixel on the LED strip blink bright red. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import machine , neopixel , time # Set the pin number and number of pixels LED_PIN = machine . Pin ( 4 ) NUMBER_PIXELS = 12 np = neopixel . NeoPixel ( LED_PIN , NUMBER_PIXELS ) # blink the first pixel red while True : np [ 0 ] = ( 255 , 0 , 0 ) np . write () time . sleep ( 1 ) np [ 0 ] = ( 0 , 0 , 0 ) np . write () time . sleep ( 1 )","title":"Part 4: Testing Your Code"},{"location":"robots/03-rainbow-bot/#functions-for-drawing-on-matrix","text":"The numbering of the pixels is a bit odd. The first 12 are 0 to 11, but the second 12 pixels are in reverse order, so the second row counts from 23 down to 13. Here are some functions that demonstrate this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import time from neopixel import Neopixel numpix = 72 strip = Neopixel ( numpix , 0 , 0 , \"GRB\" ) red = ( 255 , 0 , 0 ) orange = ( 255 , 150 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) colors = ( red , orange , yellow , green , blue , indigo , violet ) strip . brightness ( 255 ) def color_wipe (): for color in colors : for i in range ( numpix ): strip . set_pixel ( i , color ) strip . show () time . sleep ( 0.01 ) def color_wipe_2 (): for color in colors : for i in range ( 12 ): strip . set_pixel ( i , color ) strip . set_pixel ( i + 12 , color ) strip . set_pixel ( i + 24 , color ) strip . set_pixel ( i + 36 , color ) strip . set_pixel ( i + 48 , color ) strip . set_pixel ( i + 60 , color ) strip . show () time . sleep ( 0.01 ) def color_wipe_3 (): for color in colors : for i in range ( 12 ): strip . set_pixel ( i , color ) strip . set_pixel ( 23 - i , color ) strip . set_pixel ( i + 24 , color ) strip . set_pixel ( 47 - i , color ) strip . set_pixel ( 48 + i , color ) strip . set_pixel ( 71 - i , color ) strip . show () time . sleep ( 0.3 ) # offset is the color to start (0 to 6) # dir is 1 for forward and -1 for reverse def color_wipe_4 ( offset , dir ): for i in range ( 12 ): if dir == 1 : this_color = colors [ (( i - offset ) % 7 )] else : this_color = colors [ (( i + offset ) % 7 )] strip . set_pixel ( i , this_color ) strip . set_pixel ( 23 - i , this_color ) strip . set_pixel ( i + 24 , this_color ) strip . set_pixel ( 47 - i , this_color ) strip . set_pixel ( 48 + i , this_color ) strip . set_pixel ( 71 - i , this_color ) strip . show () # time.sleep(0.01) while True : for counter in range ( 100 ): color_wipe_4 ( counter % 7 , 1 ) for counter in range ( 100 ): color_wipe_4 ( counter % 7 , - 1 )","title":"Functions For Drawing on Matrix"},{"location":"robots/03-rainbow-bot/#full-source-code","text":"We now combine the motor controls, the distance sensor and the LED functions so that a moving rainbow pattern moves from to back as the robot moves forward. If the robot encounters an obstacle, the robot will backup and change the direction of the rainbow. After it backs up a bit it will turn and move forward again. main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 from machine import Pin , PWM from time import sleep from machine import Pin from machine import I2C import VL53L0X from neopixel import Neopixel # Motor Code # lower right pins with USB on top RIGHT_FORWARD_PIN = 19 RIGHT_REVERSE_PIN = 18 LEFT_FORWARD_PIN = 20 LEFT_REVERSE_PIN = 21 right_forward = PWM ( Pin ( RIGHT_FORWARD_PIN )) right_reverse = PWM ( Pin ( RIGHT_REVERSE_PIN )) left_forward = PWM ( Pin ( LEFT_FORWARD_PIN )) left_reverse = PWM ( Pin ( LEFT_REVERSE_PIN )) # Sensor Code sda = machine . Pin ( 16 ) scl = machine . Pin ( 17 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) tof . start () # startup the sensor # used to blink the onboard LED led_onboard = machine . Pin ( 25 , machine . Pin . OUT ) # LED Code numpix = 72 strip = Neopixel ( numpix , 0 , 0 , \"GRB\" ) # we turn the brightness way down to not oversaturate the brightness in the video strip . brightness ( 20 ) # driving parameters POWER_LEVEL = 30000 # use a value from 20000 to 65025 TURN_THRESHOLD = 400 # 25 cm TURN_TIME = . 25 # seconds of turning BACKUP_TIME = . 75 # seconds of backing up if obstacle detected red = ( 255 , 0 , 0 ) orange = ( 255 , 165 , 0 ) yellow = ( 255 , 255 , 0 ) green = ( 0 , 255 , 0 ) blue = ( 0 , 0 , 255 ) indigo = ( 75 , 0 , 130 ) violet = ( 138 , 43 , 226 ) colors = ( red , orange , yellow , green , blue , indigo , violet ) def turn_motor_on ( pwm ): pwm . duty_u16 ( POWER_LEVEL ) def turn_motor_off ( pwm ): pwm . duty_u16 ( 0 ) def forward (): turn_motor_on ( right_forward ) turn_motor_on ( left_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_reverse ) #for i in range(numpix): # strip.set_pixel(i, green) #strip.show() def reverse (): turn_motor_on ( right_reverse ) turn_motor_on ( left_reverse ) turn_motor_off ( right_forward ) turn_motor_off ( left_forward ) #for i in range(numpix): # strip.set_pixel(i, red) #strip.show() def turn_right (): turn_motor_on ( right_forward ) turn_motor_on ( left_reverse ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) #for i in range(numpix): # strip.set_pixel(i, blue) #strip.show() def turn_left (): turn_motor_on ( right_reverse ) turn_motor_on ( left_forward ) turn_motor_off ( right_forward ) turn_motor_off ( left_reverse ) #for i in range(numpix): # strip.set_pixel(i, yellow) #strip.show() def stop (): turn_motor_off ( right_forward ) turn_motor_off ( right_reverse ) turn_motor_off ( left_forward ) turn_motor_off ( left_reverse ) for i in range ( numpix ): strip . set_pixel ( i , violet ) strip . show () def read_sensor_avg (): total = 0 for i in range ( 10 ): total = total + tof . read () sleep ( . 01 ) return int ( total / 10 ) # offset is the color to start (0 to 6) # dir is 1 for forward and -1 for reverse def color_wipe_4 ( offset , dir ): for i in range ( 12 ): if dir == 1 : this_color = colors [ (( i - offset ) % 7 )] else : this_color = colors [ (( i + offset ) % 7 )] strip . set_pixel ( i , this_color ) strip . set_pixel ( 23 - i , this_color ) strip . set_pixel ( i + 24 , this_color ) strip . set_pixel ( 47 - i , this_color ) strip . set_pixel ( 48 + i , this_color ) strip . set_pixel ( 71 - i , this_color ) strip . show () # time.sleep(0.01) counter = 0 while True : dist = read_sensor_avg () if dist < TURN_THRESHOLD : print ( 'object detected' ) reverse () color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 turn_right () color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 color_wipe_4 ( counter % 7 , - 1 ) sleep ( . 1 ) counter += 1 else : forward () color_wipe_4 ( counter % 7 , 1 ) counter += 1 Rainbow Bot Source Code","title":"Full Source Code"},{"location":"robots/03-rainbow-bot/#references","text":"Micropython NeoPixel Library","title":"References"},{"location":"robots/04-face-bot/","text":"","title":"Face Bot"},{"location":"robots/05-param-bot/","text":"","title":"Param Bot"},{"location":"robots/20-faqs/","text":"Robots Frequently Asked Questions Why a two-motor three wheel robot, not four motor four wheel robot? We evaluated both the two-motor three wheel robot and the four motor four wheel robots and found that we could achieve all our learning objectives with the two-motor three wheel version. The kits are lower cost, have a simpler assembly process and have plenty of power for our projects. Why do we use the L293D vs L298N Motor Driver? Both of these popular motor driver chips are commonly used in robot kits. Our focus is teaching the principals of computational thinking using low-cost parts. Since the L293D is lower cost and has plenty of power for our two-motor robots we chose that. There is a detailed side-by-side comparison [here] (https://www.etechnophiles.com/l293d-vs-l298n-motor-driver-differences-specifications-and-pinouts/) Why don't we just create a remote control robot car? Remote control cars are very fun to play with. But we find that it often detracts from our mission of learning how to code. So we try to minimize the time students spend just driving their cars around our tracks.","title":"FAQs"},{"location":"robots/20-faqs/#robots-frequently-asked-questions","text":"","title":"Robots Frequently Asked Questions"},{"location":"robots/20-faqs/#why-a-two-motor-three-wheel-robot-not-four-motor-four-wheel-robot","text":"We evaluated both the two-motor three wheel robot and the four motor four wheel robots and found that we could achieve all our learning objectives with the two-motor three wheel version. The kits are lower cost, have a simpler assembly process and have plenty of power for our projects.","title":"Why a two-motor three wheel robot, not four motor four wheel robot?"},{"location":"robots/20-faqs/#why-do-we-use-the-l293d-vs-l298n-motor-driver","text":"Both of these popular motor driver chips are commonly used in robot kits. Our focus is teaching the principals of computational thinking using low-cost parts. Since the L293D is lower cost and has plenty of power for our two-motor robots we chose that. There is a detailed side-by-side comparison [here] (https://www.etechnophiles.com/l293d-vs-l298n-motor-driver-differences-specifications-and-pinouts/)","title":"Why do we use the L293D vs L298N Motor Driver?"},{"location":"robots/20-faqs/#why-dont-we-just-create-a-remote-control-robot-car","text":"Remote control cars are very fun to play with. But we find that it often detracts from our mission of learning how to code. So we try to minimize the time students spend just driving their cars around our tracks.","title":"Why don't we just create a remote control robot car?"},{"location":"sensors/01-intro/","text":"Sensors in MicroPython Light Sensor Ping Temperature","title":"Introduction"},{"location":"sensors/01-intro/#sensors-in-micropython","text":"","title":"Sensors in MicroPython"},{"location":"sensors/01-intro/#light-sensor","text":"","title":"Light Sensor"},{"location":"sensors/01-intro/#ping","text":"","title":"Ping"},{"location":"sensors/01-intro/#temperature","text":"","title":"Temperature"},{"location":"sensors/02-photosensor/","text":"Light Sensor with Raspberry Pi Pico in MicroPython A photoresistor is a sensor that decreases resistance when light is shined on its surface. With no light a photoresistor has high resistance in the range of megaohms. As light shines on the surface the resistance drops to kiloohms. We can use this effect as a light sensor. To convert the variable resistance of a photoresistor to something we can measure with our microcontroller we will need to build a small circuit that includes a 10K ohm resistor. We then measure the voltage between the photoresistor and the 10K resistor as light falls on the sensor. The top and bottom of the circuit are tied to ground and a power rail. This will move the voltage of the midpoint of the circuit. Circuit We want to make sure that we use the stable analog ground (AGND) and analog to reference voltage at either end of the circuit to protect the circuit from all the noise of the power in our processor. Using other power and ground pins will work, but power fluctuations will make the result noisy. Sample Code Our program will first use the Analog to Digital Circuit (ADC0) as an input. On the Pico this is on pin 26. 1 2 3 4 5 6 7 8 import machine import time photo_pin = machine . ADC ( 26 ) while True : val = photo_pin . read_u16 () print ( val ) time . sleep ( . 2 ) When you run the program a series of print values is displayed in the shell every 1/5th of a second. You can also use the Thonny plot window to see how the numbers change and you cover and uncover detector from a light source. Experiments What types of devices could use a light detector? How does a night-light work? How could you add an LED to the circuit so that the LED would turn on if the light level got too low? Could you automatically adjust the brightness of LEDs on a costume to get brighter in a sunny room and dim if you enter a dark room? What would that code look like? References Wikipedia Page on Photoresistor","title":"Photosensor"},{"location":"sensors/02-photosensor/#light-sensor-with-raspberry-pi-pico-in-micropython","text":"A photoresistor is a sensor that decreases resistance when light is shined on its surface. With no light a photoresistor has high resistance in the range of megaohms. As light shines on the surface the resistance drops to kiloohms. We can use this effect as a light sensor. To convert the variable resistance of a photoresistor to something we can measure with our microcontroller we will need to build a small circuit that includes a 10K ohm resistor. We then measure the voltage between the photoresistor and the 10K resistor as light falls on the sensor. The top and bottom of the circuit are tied to ground and a power rail. This will move the voltage of the midpoint of the circuit.","title":"Light Sensor with Raspberry Pi Pico in MicroPython"},{"location":"sensors/02-photosensor/#circuit","text":"We want to make sure that we use the stable analog ground (AGND) and analog to reference voltage at either end of the circuit to protect the circuit from all the noise of the power in our processor. Using other power and ground pins will work, but power fluctuations will make the result noisy.","title":"Circuit"},{"location":"sensors/02-photosensor/#sample-code","text":"Our program will first use the Analog to Digital Circuit (ADC0) as an input. On the Pico this is on pin 26. 1 2 3 4 5 6 7 8 import machine import time photo_pin = machine . ADC ( 26 ) while True : val = photo_pin . read_u16 () print ( val ) time . sleep ( . 2 ) When you run the program a series of print values is displayed in the shell every 1/5th of a second. You can also use the Thonny plot window to see how the numbers change and you cover and uncover detector from a light source.","title":"Sample Code"},{"location":"sensors/02-photosensor/#experiments","text":"What types of devices could use a light detector? How does a night-light work? How could you add an LED to the circuit so that the LED would turn on if the light level got too low? Could you automatically adjust the brightness of LEDs on a costume to get brighter in a sunny room and dim if you enter a dark room? What would that code look like?","title":"Experiments"},{"location":"sensors/02-photosensor/#references","text":"Wikipedia Page on Photoresistor","title":"References"},{"location":"sensors/02-pot/","text":"Reading a Potentiometer ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin. 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins. Sampling data Sometimes the data coming from your Potentiometer is noisy. You can sample the value multiple times and then average the values. Here is a sample program. Just pass in the pin and a count and it will return the average values. This version waits 5 milliseconds between samples. 1 2 3 4 5 6 def sample_pot ( pin , count ): total = 0 for i in range ( count ): total += int ( pin . read_u16 ()) utime . sleep_ms ( 5 ) return int ( total / count ) 1 2 3 pot_pin_1 = machine . ADC ( 26 ) # return a value after sampling 10 times sample_pot ( pot_pin_1 , 10 )","title":"Potentiometer"},{"location":"sensors/02-pot/#reading-a-potentiometer","text":"ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin. 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins.","title":"Reading a Potentiometer"},{"location":"sensors/02-pot/#sampling-data","text":"Sometimes the data coming from your Potentiometer is noisy. You can sample the value multiple times and then average the values. Here is a sample program. Just pass in the pin and a count and it will return the average values. This version waits 5 milliseconds between samples. 1 2 3 4 5 6 def sample_pot ( pin , count ): total = 0 for i in range ( count ): total += int ( pin . read_u16 ()) utime . sleep_ms ( 5 ) return int ( total / count ) 1 2 3 pot_pin_1 = machine . ADC ( 26 ) # return a value after sampling 10 times sample_pot ( pot_pin_1 , 10 )","title":"Sampling data"},{"location":"sensors/03-ping/","text":"Ultrasonic Ping Sensor The HC-SR04 is a low cost ($4) sensor that measures the distance to an object in front of it. Wiring Diagram Connect GND to any GND pin on the Pico Connnect VCC to VBUS or 5 Volt power Connect Trigger to pin 15. With USB on the top, this pin is the bottom left corner. Connect Echo to pin 14. One up from bottom left corner. Sample Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # Sample code to test HC-SR04 Ultrasonice Ping Sensor # Connect GND to any GND pin on the Pico # Connnect VCC to VBUS or 5 Volt power from machine import Pin , Timer import utime TRIGGER_PIN = 15 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 14 # One up from bottom left corner # Init HC-SR04 pins trigger = Pin ( TRIGGER_PIN , Pin . OUT ) # send trigger out to sensor echo = Pin ( ECHO_PIN , Pin . IN ) # get the delay interval back def ping (): trigger . low () utime . sleep_us ( 2 ) # Wait 2 microseconds low trigger . high () utime . sleep_us ( 5 ) # Stay high for 5 miroseconds trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance while True : print ( \"Distance:\" , ping (), \" cm\" ) utime . sleep ( . 25 ) OLED See the OLED example here: OLED Ping Example","title":"Ping Distance"},{"location":"sensors/03-ping/#ultrasonic-ping-sensor","text":"The HC-SR04 is a low cost ($4) sensor that measures the distance to an object in front of it.","title":"Ultrasonic Ping Sensor"},{"location":"sensors/03-ping/#wiring-diagram","text":"Connect GND to any GND pin on the Pico Connnect VCC to VBUS or 5 Volt power Connect Trigger to pin 15. With USB on the top, this pin is the bottom left corner. Connect Echo to pin 14. One up from bottom left corner.","title":"Wiring Diagram"},{"location":"sensors/03-ping/#sample-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # Sample code to test HC-SR04 Ultrasonice Ping Sensor # Connect GND to any GND pin on the Pico # Connnect VCC to VBUS or 5 Volt power from machine import Pin , Timer import utime TRIGGER_PIN = 15 # With USB on the top, this pin is the bottom left corner ECHO_PIN = 14 # One up from bottom left corner # Init HC-SR04 pins trigger = Pin ( TRIGGER_PIN , Pin . OUT ) # send trigger out to sensor echo = Pin ( ECHO_PIN , Pin . IN ) # get the delay interval back def ping (): trigger . low () utime . sleep_us ( 2 ) # Wait 2 microseconds low trigger . high () utime . sleep_us ( 5 ) # Stay high for 5 miroseconds trigger . low () while echo . value () == 0 : signaloff = utime . ticks_us () while echo . value () == 1 : signalon = utime . ticks_us () timepassed = signalon - signaloff distance = ( timepassed * 0.0343 ) / 2 return distance while True : print ( \"Distance:\" , ping (), \" cm\" ) utime . sleep ( . 25 )","title":"Sample Code"},{"location":"sensors/03-ping/#oled","text":"See the OLED example here: OLED Ping Example","title":"OLED"},{"location":"sensors/05-temp-dsb20/","text":"Temp with DS18B20 https://randomnerdtutorials.com/micropython-ds18b20-esp32-esp8266/ ```py Complete project details at https://RandomNerdTutorials.com import machine, onewire, ds18x20, time ds_pin = machine.Pin(4) ds_sensor = ds18x20.DS18X20(onewire.OneWire(ds_pin)) roms = ds_sensor.scan() print('Found DS devices: ', roms) while True: ds_sensor.convert_temp() time.sleep_ms(750) for rom in roms: print(rom) print(ds_sensor.read_temp(rom)) time.sleep(5) ```","title":"Temperature"},{"location":"sensors/05-temp-dsb20/#temp-with-ds18b20","text":"https://randomnerdtutorials.com/micropython-ds18b20-esp32-esp8266/ ```py","title":"Temp with DS18B20"},{"location":"sensors/05-temp-dsb20/#complete-project-details-at-httpsrandomnerdtutorialscom","text":"import machine, onewire, ds18x20, time ds_pin = machine.Pin(4) ds_sensor = ds18x20.DS18X20(onewire.OneWire(ds_pin)) roms = ds_sensor.scan() print('Found DS devices: ', roms) while True: ds_sensor.convert_temp() time.sleep_ms(750) for rom in roms: print(rom) print(ds_sensor.read_temp(rom)) time.sleep(5) ```","title":"Complete project details at https://RandomNerdTutorials.com"},{"location":"sensors/06-accelerometer-compass/","text":"MPU-9250 Accelerometer Gyroscope Compass The MPU-9250 by InvenSense is a nine-axis motion tracking device. It includes: A MPU-6500, which contains a 3-axis accelerometer and a 3-axis gyroscope and A AK8963, the market leading 3-axis digital compass that senses magnetic fields (Gyro + Accelerometer + Compass) MEMS MotionTracking\u2122 Device 1PCS GY-91 10DOF Accelerometer Gyroscope Compass Temp/Pressure MPU-9250 BMP-280 Art of Circuits Pinouts VIN: Voltage Supply Pin 3V3: 3.3v Regulator output GND: 0V Power Supply SCL: I2C Clock / SPI Clock SDA: I2C Data or SPI Data Input SDO/SAO: SPI Data output / I2C Slave Address configuration pin NCS: Chip Select for SPI mode only for MPU-9250 CSB: Chip Select for BMP280 You only need to hook the 3.3 to VIN, the GND to GND and the SCL and SDA. The other connections are not needed. I2C Scanner Results 1 2 3 4 5 import machine sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) Device found at decimal [104, 118] MPU9250 Drivers MicroPython Driver 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import utime from machine import I2C , Pin from mpu9250 import MPU9250 i2c = I2C ( scl = Pin ( 22 ), sda = Pin ( 21 )) sensor = MPU9250 ( i2c ) print ( \"MPU9250 id: \" + hex ( sensor . whoami )) while True : print ( sensor . acceleration ) print ( sensor . gyro ) print ( sensor . magnetic ) print ( sensor . temperature ) utime . sleep_ms ( 1000 )","title":"Accelerometer Compass"},{"location":"sensors/06-accelerometer-compass/#mpu-9250-accelerometer-gyroscope-compass","text":"The MPU-9250 by InvenSense is a nine-axis motion tracking device. It includes: A MPU-6500, which contains a 3-axis accelerometer and a 3-axis gyroscope and A AK8963, the market leading 3-axis digital compass that senses magnetic fields (Gyro + Accelerometer + Compass) MEMS MotionTracking\u2122 Device 1PCS GY-91 10DOF Accelerometer Gyroscope Compass Temp/Pressure MPU-9250 BMP-280 Art of Circuits","title":"MPU-9250 Accelerometer Gyroscope Compass"},{"location":"sensors/06-accelerometer-compass/#pinouts","text":"VIN: Voltage Supply Pin 3V3: 3.3v Regulator output GND: 0V Power Supply SCL: I2C Clock / SPI Clock SDA: I2C Data or SPI Data Input SDO/SAO: SPI Data output / I2C Slave Address configuration pin NCS: Chip Select for SPI mode only for MPU-9250 CSB: Chip Select for BMP280 You only need to hook the 3.3 to VIN, the GND to GND and the SCL and SDA. The other connections are not needed.","title":"Pinouts"},{"location":"sensors/06-accelerometer-compass/#i2c-scanner-results","text":"1 2 3 4 5 import machine sda = machine . Pin ( 16 ) # row one on our standard Pico breadboard scl = machine . Pin ( 17 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) Device found at decimal [104, 118]","title":"I2C Scanner Results"},{"location":"sensors/06-accelerometer-compass/#mpu9250-drivers","text":"MicroPython Driver 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import utime from machine import I2C , Pin from mpu9250 import MPU9250 i2c = I2C ( scl = Pin ( 22 ), sda = Pin ( 21 )) sensor = MPU9250 ( i2c ) print ( \"MPU9250 id: \" + hex ( sensor . whoami )) while True : print ( sensor . acceleration ) print ( sensor . gyro ) print ( sensor . magnetic ) print ( sensor . temperature ) utime . sleep_ms ( 1000 )","title":"MPU9250 Drivers"},{"location":"sensors/06-bme280/","text":"Read Temperature, Humidity and Pressure with BME280 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from machine import I2C import BME280 from time import sleep sda = machine . Pin ( 16 ) scl = machine . Pin ( 17 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) bme = BME280 . BME280 ( i2c = i2c ) # print(i2c.scan()) while True : temp = bme . temperature hum = bme . humidity pres = bme . pressure # uncomment for temperature in Fahrenheit temp = ( bme . read_temperature () / 100 ) * ( 9 / 5 ) + 32 #temp = str(round(temp, 2)) + 'F' print ( 'Temperature: ' , temp , end = '' ) print ( ' Humidity:' , hum , end = '' ) print ( ' Pressure:' , pres ) sleep ( 5 )","title":"Temp, Humidity, Pres"},{"location":"sensors/06-bme280/#read-temperature-humidity-and-pressure-with-bme280","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from machine import I2C import BME280 from time import sleep sda = machine . Pin ( 16 ) scl = machine . Pin ( 17 ) i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) bme = BME280 . BME280 ( i2c = i2c ) # print(i2c.scan()) while True : temp = bme . temperature hum = bme . humidity pres = bme . pressure # uncomment for temperature in Fahrenheit temp = ( bme . read_temperature () / 100 ) * ( 9 / 5 ) + 32 #temp = str(round(temp, 2)) + 'F' print ( 'Temperature: ' , temp , end = '' ) print ( ' Humidity:' , hum , end = '' ) print ( ' Pressure:' , pres ) sleep ( 5 )","title":"Read Temperature, Humidity and Pressure with BME280"},{"location":"sensors/07-VL53L0X_GY/","text":"VL53L0X Time-of-Flight Laser Ranging Module IR Distance Sensor Figure: VL53L0X in the GY-530 package. The VL53L0X is a low-cost ($5) time-of-flight light-based distance sensor that is easy to use. It comes packaged in a I2C board and gives precise distance measurements up to 1.5 meters away. It measures the time that light pulses take to travel to an object and back to estimate distance. Light travels about 1 foot every nanosecond, so the timing inside this little chip must be very accurate. The VL53L0X integrates a group of Single Photon Avalanche Diodes (SPAD) and embeds ST Electronic's second generation FlightSense\u2122 patented technology. The VL53L0X\u2019s 940 nm emitter Vertical Cavity Surface-Emitting Laser (VCSEL), is safe for kids and totally invisible to the human eye. Coupled with internal physical infrared filters, the sensor enables longer ranging distance, higher immunity to ambient light, and better robustness to cover glass optical crosstalk. Circuit Hook the VCC to the 3.3 out of the Pico, the GND of the sensor to andy of the GND pins of the Pico and then connect the Clock and Data to two pins such as GIPO pins 16 and 17. Scanner We first run the I2C scanner program to verify that the sensor is connected correct and is responding to the I2C bus scan. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) This should return a single decimal number. Download The VL53L0X Driver If you are using Thonny, you can try to use the \"Manage Packages\" menu and search for the driver. We have a sample of the driver here Create a Test Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Test program for VL53L0X import time from machine import Pin from machine import I2C import VL53L0X sda = machine . Pin ( 16 ) # lower right pin scl = machine . Pin ( 17 ) # one up from lower right pin i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) while True : tof . start () tof . read () print ( tof . read ()) tof . stop () time . sleep ( 0.1 ) Use the Thonny Plot Reference Purchase links ST Microelectronics User Manual Ebay $4 Amazon $12 eBay qty 10 for $25","title":"Time of Flight Distance"},{"location":"sensors/07-VL53L0X_GY/#vl53l0x-time-of-flight-laser-ranging-module-ir-distance-sensor","text":"Figure: VL53L0X in the GY-530 package. The VL53L0X is a low-cost ($5) time-of-flight light-based distance sensor that is easy to use. It comes packaged in a I2C board and gives precise distance measurements up to 1.5 meters away. It measures the time that light pulses take to travel to an object and back to estimate distance. Light travels about 1 foot every nanosecond, so the timing inside this little chip must be very accurate. The VL53L0X integrates a group of Single Photon Avalanche Diodes (SPAD) and embeds ST Electronic's second generation FlightSense\u2122 patented technology. The VL53L0X\u2019s 940 nm emitter Vertical Cavity Surface-Emitting Laser (VCSEL), is safe for kids and totally invisible to the human eye. Coupled with internal physical infrared filters, the sensor enables longer ranging distance, higher immunity to ambient light, and better robustness to cover glass optical crosstalk.","title":"VL53L0X Time-of-Flight Laser Ranging Module IR Distance Sensor"},{"location":"sensors/07-VL53L0X_GY/#circuit","text":"Hook the VCC to the 3.3 out of the Pico, the GND of the sensor to andy of the GND pins of the Pico and then connect the Clock and Data to two pins such as GIPO pins 16 and 17.","title":"Circuit"},{"location":"sensors/07-VL53L0X_GY/#scanner","text":"We first run the I2C scanner program to verify that the sensor is connected correct and is responding to the I2C bus scan. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # row one on our standard Pico breadboard scl = machine . Pin ( 1 ) # row two on our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) This should return a single decimal number.","title":"Scanner"},{"location":"sensors/07-VL53L0X_GY/#download-the-vl53l0x-driver","text":"If you are using Thonny, you can try to use the \"Manage Packages\" menu and search for the driver. We have a sample of the driver here","title":"Download The VL53L0X Driver"},{"location":"sensors/07-VL53L0X_GY/#create-a-test-program","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Test program for VL53L0X import time from machine import Pin from machine import I2C import VL53L0X sda = machine . Pin ( 16 ) # lower right pin scl = machine . Pin ( 17 ) # one up from lower right pin i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # Create a VL53L0X object tof = VL53L0X . VL53L0X ( i2c ) while True : tof . start () tof . read () print ( tof . read ()) tof . stop () time . sleep ( 0.1 )","title":"Create a Test Program"},{"location":"sensors/07-VL53L0X_GY/#use-the-thonny-plot","text":"","title":"Use the Thonny Plot"},{"location":"sensors/07-VL53L0X_GY/#reference-purchase-links","text":"ST Microelectronics User Manual Ebay $4 Amazon $12","title":"Reference Purchase links"},{"location":"sensors/07-VL53L0X_GY/#ebay","text":"qty 10 for $25","title":"eBay"},{"location":"sensors/08-ir-distance-sensor/","text":"IR Distance Sensors IR distance sensors are low cost (five for $3) but may have problems working in rooms with outdoor lighting. They have an adjustable potentiometer on them that can be used to adjust a triggering distance call the threshold distance. The sensors return a HIGH signal if there is no object within the threshold distance and a LOW signal if there is an object within this distance. Since the sensor threshold distance can not be adjusted programmatically they are best suited when you can manually adjust the potentiometer to change the threshold. Connections These sensors have three wires: GND - connect to a ground rail on your breadboard or directly to a GND ping on the Pico. VCC - connect to the 5 volt power rail powered by the motor controller voltage regulator OUT - a 5 volt digital signal that is usually 5 volts but is GND when triggered by an object Sample Python Code 1 2 3 4 # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) The KY-032 The KY-032 obstacle avoidance sensor is a four-wire distance-adjustable, infrared proximity sensor designed for wheeled robots. Also known as AD-032. The sensor detection distance ranges from 2cm to 40cm, it can be adjusted by turning the potentiometer knob. The operating voltage is 3.3V-5V so it is suitable for a variety of microcontrollers like Arduino, ESP32, Teensy, ESP8266, Raspberry Pi, and others. It has strong adaptability to ambient light and it is fairly accurate to sense changes in the surrounding environment. Speaker Test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 from machine import Pin , PWM from utime import sleep left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) def sound_off (): speaker . duty_u16 ( 0 ) def left_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second sound_off () def center_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 25 ) sound_off () def forward_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 1 ) speaker . freq ( 900 ) sleep ( . 1 ) speaker . freq ( 1200 ) sleep ( . 1 ) sound_off () # 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 while True : if left . value () == 0 : print ( 'Left' ) left_tone () drive_state = 2 if center . value () == 0 : print ( 'Center' ) center_tone () drive_state = 0 if right . value () == 0 : print ( 'Right' ) right_tone () drive_state = 3 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left . value () and center . value () and right . value (): print ( 'Go forward!' ) drive_state = 1 forward_tone () sleep ( . 25 ) Full Program ```py from machine import Pin, PWM from utime import sleep import ssd1306 Motor pins to the L293 H-Bridge RIGHT_FORWARD_PIN = 17 RIGHT_REVERSE_PIN = 16 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM(Pin(RIGHT_FORWARD_PIN)) right_reverse = PWM(Pin(RIGHT_REVERSE_PIN)) left_forward = PWM(Pin(LEFT_FORWARD_PIN)) left_reverse = PWM(Pin(LEFT_REVERSE_PIN)) connections to the three IR distance sensors left = Pin(8, Pin.IN, Pin.PULL_DOWN) center = Pin(7, Pin.IN, Pin.PULL_DOWN) right = Pin(6, Pin.IN, Pin.PULL_DOWN) SPEAKER_PIN = 21 create a Pulse Width Modulation Object on this pin speaker = PWM(Pin(SPEAKER_PIN)) WIDTH = 128 HEIGHT = 64 CS = machine.Pin(1) SCL = machine.Pin(2) SDA = machine.Pin(3) DC = machine.Pin(4) RES = machine.Pin(5) spi=machine.SPI(0, sck=SCL, mosi=SDA) oled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS) def turn_motor_on(pwm): pwm.duty_u16(65025) def turn_motor_off(pwm): pwm.duty_u16(0) def forward(): turn_motor_on(right_forward) turn_motor_on(left_forward) def reverse(): turn_motor_on(right_reverse) turn_motor_on(left_reverse) def turn_right(): turn_motor_on(right_forward) turn_motor_on(left_reverse) def turn_left(): turn_motor_on(right_reverse) turn_motor_on(left_forward) def sound_off(): speaker.duty_u16(0) def left_tone(): speaker.duty_u16(1000) speaker.freq(700) # 1 Kilohertz sleep(.5) # wait a 1/4 second sound_off() def center_tone(): speaker.duty_u16(1000) speaker.freq(900) sleep(.5) sound_off() def right_tone(): speaker.duty_u16(1000) speaker.freq(600) sleep(.5) sound_off() def forward_tone(): speaker.duty_u16(1000) speaker.freq(400) sleep(.1) speaker.freq(900) sleep(.1) speaker.freq(1200) sleep(.1) sound_off() def update_oled(): oled.fill(0) oled.text(\"CoderDojo Rocks!\", 0, 0, 1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 oled.text(\"Left:\", 0, 10, 1) oled.text(str(left.value()), 50, 10, 1) oled.text(\"Center:\", 0, 20, 1) oled.text(str(center.value()), 60, 20, 1) oled.text(\"Right:\", 0, 30, 1) oled.text(str(right.value()), 55, 30, 1) BAR_WIDTH = 40 BAR_HEIGHT = 20 if left.value(): oled.fill_rect(WIDTH-40, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(WIDTH-40, 50, BAR_WIDTH, BAR_HEIGHT, 1) if center.value(): oled.fill_rect(50, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(50, 50, BAR_WIDTH, BAR_HEIGHT, 1) if right.value(): oled.fill_rect(0, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(0, 50, BAR_WIDTH, BAR_HEIGHT, 1) oled.show() 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 counter = 0 while True: if left.value()==0: print('Left') #left_tone() turn_right() update_oled() drive_state = 2 if center.value()==0: print('Center') center_tone() reverse() update_oled() drive_state = 0 if right.value()==0: print('Right') #right_tone() turn_left() update_oled() drive_state = 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left.value() and center.value() and right.value(): print('Go forward!') drive_state = 1 # forward_tone() forward() update_oled() print(\"counter: \", counter) counter += 1 sleep(.25) ``` ## More to Explore 1. Try to change the values of the potentiometers on the sensors. What is the minimum and maximum distance you can detect and object? 2. Does the reflectivity of the object impact the distance of the object? 3. If you put a small mirror in front of the sensor what happens to the distance measured? 4. Place the robot near bright sun in a window or try the robot outdoors on both a cloudy day and a sunny day? What is the change is accuracy of the sensors under these conditions? What about running the robot in the dark?","title":"IR Distance Sensor"},{"location":"sensors/08-ir-distance-sensor/#ir-distance-sensors","text":"IR distance sensors are low cost (five for $3) but may have problems working in rooms with outdoor lighting. They have an adjustable potentiometer on them that can be used to adjust a triggering distance call the threshold distance. The sensors return a HIGH signal if there is no object within the threshold distance and a LOW signal if there is an object within this distance. Since the sensor threshold distance can not be adjusted programmatically they are best suited when you can manually adjust the potentiometer to change the threshold.","title":"IR Distance Sensors"},{"location":"sensors/08-ir-distance-sensor/#connections","text":"These sensors have three wires: GND - connect to a ground rail on your breadboard or directly to a GND ping on the Pico. VCC - connect to the 5 volt power rail powered by the motor controller voltage regulator OUT - a 5 volt digital signal that is usually 5 volts but is GND when triggered by an object","title":"Connections"},{"location":"sensors/08-ir-distance-sensor/#sample-python-code","text":"1 2 3 4 # connections to the three IR distance sensors left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN )","title":"Sample Python Code"},{"location":"sensors/08-ir-distance-sensor/#the-ky-032","text":"The KY-032 obstacle avoidance sensor is a four-wire distance-adjustable, infrared proximity sensor designed for wheeled robots. Also known as AD-032. The sensor detection distance ranges from 2cm to 40cm, it can be adjusted by turning the potentiometer knob. The operating voltage is 3.3V-5V so it is suitable for a variety of microcontrollers like Arduino, ESP32, Teensy, ESP8266, Raspberry Pi, and others. It has strong adaptability to ambient light and it is fairly accurate to sense changes in the surrounding environment.","title":"The KY-032"},{"location":"sensors/08-ir-distance-sensor/#speaker-test","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 from machine import Pin , PWM from utime import sleep left = Pin ( 8 , Pin . IN , Pin . PULL_DOWN ) center = Pin ( 7 , Pin . IN , Pin . PULL_DOWN ) right = Pin ( 6 , Pin . IN , Pin . PULL_DOWN ) SPEAKER_PIN = 21 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) def sound_off (): speaker . duty_u16 ( 0 ) def left_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second sound_off () def center_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 5 ) sound_off () def right_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 25 ) sound_off () def forward_tone (): speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 1 ) speaker . freq ( 900 ) sleep ( . 1 ) speaker . freq ( 1200 ) sleep ( . 1 ) sound_off () # 0=stopped, 1=forward, 2=turing right, 3=turning left drive_state = 0 while True : if left . value () == 0 : print ( 'Left' ) left_tone () drive_state = 2 if center . value () == 0 : print ( 'Center' ) center_tone () drive_state = 0 if right . value () == 0 : print ( 'Right' ) right_tone () drive_state = 3 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left . value () and center . value () and right . value (): print ( 'Go forward!' ) drive_state = 1 forward_tone () sleep ( . 25 )","title":"Speaker Test"},{"location":"sensors/08-ir-distance-sensor/#full-program","text":"```py from machine import Pin, PWM from utime import sleep import ssd1306","title":"Full Program"},{"location":"sensors/08-ir-distance-sensor/#motor-pins-to-the-l293-h-bridge","text":"RIGHT_FORWARD_PIN = 17 RIGHT_REVERSE_PIN = 16 LEFT_FORWARD_PIN = 18 LEFT_REVERSE_PIN = 19 right_forward = PWM(Pin(RIGHT_FORWARD_PIN)) right_reverse = PWM(Pin(RIGHT_REVERSE_PIN)) left_forward = PWM(Pin(LEFT_FORWARD_PIN)) left_reverse = PWM(Pin(LEFT_REVERSE_PIN))","title":"Motor pins to the L293 H-Bridge"},{"location":"sensors/08-ir-distance-sensor/#connections-to-the-three-ir-distance-sensors","text":"left = Pin(8, Pin.IN, Pin.PULL_DOWN) center = Pin(7, Pin.IN, Pin.PULL_DOWN) right = Pin(6, Pin.IN, Pin.PULL_DOWN) SPEAKER_PIN = 21","title":"connections to the three IR distance sensors"},{"location":"sensors/08-ir-distance-sensor/#create-a-pulse-width-modulation-object-on-this-pin","text":"speaker = PWM(Pin(SPEAKER_PIN)) WIDTH = 128 HEIGHT = 64 CS = machine.Pin(1) SCL = machine.Pin(2) SDA = machine.Pin(3) DC = machine.Pin(4) RES = machine.Pin(5) spi=machine.SPI(0, sck=SCL, mosi=SDA) oled = ssd1306.SSD1306_SPI(WIDTH, HEIGHT, spi, DC, RES, CS) def turn_motor_on(pwm): pwm.duty_u16(65025) def turn_motor_off(pwm): pwm.duty_u16(0) def forward(): turn_motor_on(right_forward) turn_motor_on(left_forward) def reverse(): turn_motor_on(right_reverse) turn_motor_on(left_reverse) def turn_right(): turn_motor_on(right_forward) turn_motor_on(left_reverse) def turn_left(): turn_motor_on(right_reverse) turn_motor_on(left_forward) def sound_off(): speaker.duty_u16(0) def left_tone(): speaker.duty_u16(1000) speaker.freq(700) # 1 Kilohertz sleep(.5) # wait a 1/4 second sound_off() def center_tone(): speaker.duty_u16(1000) speaker.freq(900) sleep(.5) sound_off() def right_tone(): speaker.duty_u16(1000) speaker.freq(600) sleep(.5) sound_off() def forward_tone(): speaker.duty_u16(1000) speaker.freq(400) sleep(.1) speaker.freq(900) sleep(.1) speaker.freq(1200) sleep(.1) sound_off() def update_oled(): oled.fill(0) oled.text(\"CoderDojo Rocks!\", 0, 0, 1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 oled.text(\"Left:\", 0, 10, 1) oled.text(str(left.value()), 50, 10, 1) oled.text(\"Center:\", 0, 20, 1) oled.text(str(center.value()), 60, 20, 1) oled.text(\"Right:\", 0, 30, 1) oled.text(str(right.value()), 55, 30, 1) BAR_WIDTH = 40 BAR_HEIGHT = 20 if left.value(): oled.fill_rect(WIDTH-40, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(WIDTH-40, 50, BAR_WIDTH, BAR_HEIGHT, 1) if center.value(): oled.fill_rect(50, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(50, 50, BAR_WIDTH, BAR_HEIGHT, 1) if right.value(): oled.fill_rect(0, 50, BAR_WIDTH, BAR_HEIGHT, 0) else: oled.fill_rect(0, 50, BAR_WIDTH, BAR_HEIGHT, 1) oled.show()","title":"create a Pulse Width Modulation Object on this pin"},{"location":"sensors/08-ir-distance-sensor/#0stopped-1forward-2turing-right-3turning-left","text":"drive_state = 0 counter = 0 while True: if left.value()==0: print('Left') #left_tone() turn_right() update_oled() drive_state = 2 if center.value()==0: print('Center') center_tone() reverse() update_oled() drive_state = 0 if right.value()==0: print('Right') #right_tone() turn_left() update_oled() drive_state = 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # if (left.value()==1) and (center.value()==1) and (right.value()==1): if left.value() and center.value() and right.value(): print('Go forward!') drive_state = 1 # forward_tone() forward() update_oled() print(\"counter: \", counter) counter += 1 sleep(.25) ``` ## More to Explore 1. Try to change the values of the potentiometers on the sensors. What is the minimum and maximum distance you can detect and object? 2. Does the reflectivity of the object impact the distance of the object? 3. If you put a small mirror in front of the sensor what happens to the distance measured? 4. Place the robot near bright sun in a window or try the robot outdoors on both a cloudy day and a sunny day? What is the change is accuracy of the sensors under these conditions? What about running the robot in the dark?","title":"0=stopped, 1=forward, 2=turing right, 3=turning left"},{"location":"sensors/bme280/","text":"BME280 Environmental Sensor The Bosch BME280 is a low-cost ($2) temperature, and pressure sensor that has an I2C interface. This is an ideal way to learn how to use an I2C interface. Note mbe280 is different from the BMP280 and does not read humidity. The default address is Hex x76 or decimal 118. Circuit The BME280 has a standard I2C interface with four wires: GND - connect to any of the GND pins VCC - connect this to the 3.3V output of the Pico SCL - clock SDA - data I2C Scanner After you have connected your sensor you can check the connection by running a quick \"I2C Scanner\" to find the address of the sensor. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # This is GP0 on row one of our standard Pico breadboard with the USB on top scl = machine . Pin ( 1 ) # Row two of our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) Results: 1 [118] This is decimal of hex 0x76 If the scanner does not return a number then your connections might not be working. BME280 Driver You should be able to find the BME280 driver by using the Thonny Tool -> Manage Packages... menu. If that does not work you can try a github search: Search GitHub for MBE 280 Python Code Test Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import machine from utime import sleep import BME280 sda = machine . Pin ( 0 ) # This is GP0 on row one of our standard Pico breadboard with the USB on top scl = machine . Pin ( 1 ) # Row two of our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # initialize the bme class using the default address bme = BME280 () ( chip_id , chip_version ) = bme . getID () print ( \"Chip ID:\" , chip_id ) print ( \"Version:\" , chip_version ) while True (): # get new data from the temperature , pressure , humidity = bme . getData () #adj_bar = bme.adj_baro(pressure, temperature) print ( \"Adj {} \" . format ( bme . adj_baro ( pressure , temperature ))) print ( \"Temperature: {} C\" . format ( temperature )) print ( \"Pressure: {} hpa, {} In\" . format ( pressure , round ( pressure * 0.02953 , 2 ))) sleep ( 1 ) References Robert HH BME280 Test Page Official Datasheet eBay BME280 Sensor Search Driver Sample code Digital Barometric Pressure Sensor Board Swap I2C/SPI BMP280 BME280 3.3V BME280 4. BME280 logger","title":"Environmental Sensor"},{"location":"sensors/bme280/#bme280-environmental-sensor","text":"The Bosch BME280 is a low-cost ($2) temperature, and pressure sensor that has an I2C interface. This is an ideal way to learn how to use an I2C interface. Note mbe280 is different from the BMP280 and does not read humidity. The default address is Hex x76 or decimal 118.","title":"BME280 Environmental Sensor"},{"location":"sensors/bme280/#circuit","text":"The BME280 has a standard I2C interface with four wires: GND - connect to any of the GND pins VCC - connect this to the 3.3V output of the Pico SCL - clock SDA - data","title":"Circuit"},{"location":"sensors/bme280/#i2c-scanner","text":"After you have connected your sensor you can check the connection by running a quick \"I2C Scanner\" to find the address of the sensor. 1 2 3 4 5 import machine sda = machine . Pin ( 0 ) # This is GP0 on row one of our standard Pico breadboard with the USB on top scl = machine . Pin ( 1 ) # Row two of our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) print ( \"Device found at decimal\" , i2c . scan ()) Results: 1 [118] This is decimal of hex 0x76 If the scanner does not return a number then your connections might not be working.","title":"I2C Scanner"},{"location":"sensors/bme280/#bme280-driver","text":"You should be able to find the BME280 driver by using the Thonny Tool -> Manage Packages... menu. If that does not work you can try a github search: Search GitHub for MBE 280 Python Code","title":"BME280 Driver"},{"location":"sensors/bme280/#test-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import machine from utime import sleep import BME280 sda = machine . Pin ( 0 ) # This is GP0 on row one of our standard Pico breadboard with the USB on top scl = machine . Pin ( 1 ) # Row two of our standard Pico breadboard i2c = machine . I2C ( 0 , sda = sda , scl = scl , freq = 400000 ) # initialize the bme class using the default address bme = BME280 () ( chip_id , chip_version ) = bme . getID () print ( \"Chip ID:\" , chip_id ) print ( \"Version:\" , chip_version ) while True (): # get new data from the temperature , pressure , humidity = bme . getData () #adj_bar = bme.adj_baro(pressure, temperature) print ( \"Adj {} \" . format ( bme . adj_baro ( pressure , temperature ))) print ( \"Temperature: {} C\" . format ( temperature )) print ( \"Pressure: {} hpa, {} In\" . format ( pressure , round ( pressure * 0.02953 , 2 ))) sleep ( 1 )","title":"Test Code"},{"location":"sensors/bme280/#references","text":"Robert HH BME280 Test Page Official Datasheet eBay BME280 Sensor Search Driver Sample code","title":"References"},{"location":"sensors/bme280/#digital-barometric-pressure-sensor-board-swap-i2cspi-bmp280-bme280-33v","text":"BME280 4. BME280 logger","title":"Digital Barometric Pressure Sensor Board Swap I2C/SPI BMP280 BME280 3.3V"},{"location":"sensors/dht11-temp-humidity/","text":"The DHT22 (AM2302) Temperature and Humidity Sensor The DHT22 is a low-cost ($2) digital temperature and humidity sensor. It uses a capacitive humidity sensor and a thermistor to measure the surrounding air, and transmits a digital signal on the data pin. These devices are easy to use since they have an internal analog to digital conversion. They are good for 20-80% humidity readings with 5% accuracy and 0-50\u00b0C temperature readings with \u00b12\u00b0C accuracy. They are designed to be polled about once every two seconds. Circuit References DHT22 Datasheet (PDF)","title":"DH11 Temp and Humidity"},{"location":"sensors/dht11-temp-humidity/#the-dht22-am2302-temperature-and-humidity-sensor","text":"The DHT22 is a low-cost ($2) digital temperature and humidity sensor. It uses a capacitive humidity sensor and a thermistor to measure the surrounding air, and transmits a digital signal on the data pin. These devices are easy to use since they have an internal analog to digital conversion. They are good for 20-80% humidity readings with 5% accuracy and 0-50\u00b0C temperature readings with \u00b12\u00b0C accuracy. They are designed to be polled about once every two seconds.","title":"The DHT22 (AM2302) Temperature and Humidity Sensor"},{"location":"sensors/dht11-temp-humidity/#circuit","text":"","title":"Circuit"},{"location":"sensors/dht11-temp-humidity/#references","text":"DHT22 Datasheet (PDF)","title":"References"},{"location":"sound/01-intro/","text":"Introduction to Sound and Music in MicroPython How Microcontrollers Generate Sound Microcontrollers are really great at generating digital outputs on their GPIO pins. These digital signals that quickly switch between zero and a positive voltage like 3.3 or 5 volts. However, they are not designed to create \"analog\" output of a continuous varying voltage. However, we can use a technique called \"Pulse Width Modulation\" to simulate the various frequencies of sound using digital only outputs. Pulse Width Modulation is the process of changing not the height of a electrical signal, but the width between the pulses of digital signals. By changing the distance of the spaces between the digital signals we can generate a signal that will sound like it has a higher or lower frequency or pitch. MicroPython provides a powerful library of tools for you to easily generate pulses of different shapes. This is called the PWM library. Will will use this in our sound and music programs. Here is a sample of how this is called in our code: Duty Cycle The Duty Cycle is what percent of time a pulse is high. For working with sound, we want to generate smooth sound waves that are on 1/2 of the time and off 1/2 of the time. So our duty cycles will be set to be 50%. On the Raspberry Pi Pico we can achieve this by the following function: 1 speaker.duty_u16(1000) When we are done playing a tone, we must always explicitly turn the duty cycle back to 0. 1 speaker.duty_u16(0) If we forget to add this line, the tone will continue to play despite the main program stopping. This shows you that the part of the chip that generates the tone pulses is an independent processor that is not dependant on the main program running! 1 2 from machine import Pin , PWM from utime import sleep Note that we will also need to pause between notes, so will use the sleep library to pause execution of our sound generation. Connecting a Sound Device There are several different ways that you can connect a sound device to you MicroController. Here are three options: Buzzers - These are small inexpensive devices that can mount directly on your breadboard. Piezoelectric Speaker - Wikipedia Page on Piezoelectric Speaker Speaker - A magnetic speaker with our without an amplifier is another way to hear sound. You can also purchase a small amplifier to increase the volume. Amplifier - For about $1.20 you can purchase a small amplifier for your speaker. eBay LM386 DC 5V-12V Mini Micro Audio Amplifier Module Board References https://electronics.stackexchange.com/questions/288930/what-is-the-difference-between-a-buzzer-and-a-speaker-and-are-there-any-other-ba","title":"Introduction"},{"location":"sound/01-intro/#introduction-to-sound-and-music-in-micropython","text":"","title":"Introduction to Sound and Music in MicroPython"},{"location":"sound/01-intro/#how-microcontrollers-generate-sound","text":"Microcontrollers are really great at generating digital outputs on their GPIO pins. These digital signals that quickly switch between zero and a positive voltage like 3.3 or 5 volts. However, they are not designed to create \"analog\" output of a continuous varying voltage. However, we can use a technique called \"Pulse Width Modulation\" to simulate the various frequencies of sound using digital only outputs. Pulse Width Modulation is the process of changing not the height of a electrical signal, but the width between the pulses of digital signals. By changing the distance of the spaces between the digital signals we can generate a signal that will sound like it has a higher or lower frequency or pitch. MicroPython provides a powerful library of tools for you to easily generate pulses of different shapes. This is called the PWM library. Will will use this in our sound and music programs. Here is a sample of how this is called in our code:","title":"How Microcontrollers Generate Sound"},{"location":"sound/01-intro/#duty-cycle","text":"The Duty Cycle is what percent of time a pulse is high. For working with sound, we want to generate smooth sound waves that are on 1/2 of the time and off 1/2 of the time. So our duty cycles will be set to be 50%. On the Raspberry Pi Pico we can achieve this by the following function: 1 speaker.duty_u16(1000) When we are done playing a tone, we must always explicitly turn the duty cycle back to 0. 1 speaker.duty_u16(0) If we forget to add this line, the tone will continue to play despite the main program stopping. This shows you that the part of the chip that generates the tone pulses is an independent processor that is not dependant on the main program running! 1 2 from machine import Pin , PWM from utime import sleep Note that we will also need to pause between notes, so will use the sleep library to pause execution of our sound generation.","title":"Duty Cycle"},{"location":"sound/01-intro/#connecting-a-sound-device","text":"There are several different ways that you can connect a sound device to you MicroController. Here are three options: Buzzers - These are small inexpensive devices that can mount directly on your breadboard. Piezoelectric Speaker - Wikipedia Page on Piezoelectric Speaker Speaker - A magnetic speaker with our without an amplifier is another way to hear sound. You can also purchase a small amplifier to increase the volume. Amplifier - For about $1.20 you can purchase a small amplifier for your speaker. eBay LM386 DC 5V-12V Mini Micro Audio Amplifier Module Board","title":"Connecting a Sound Device"},{"location":"sound/01-intro/#references","text":"https://electronics.stackexchange.com/questions/288930/what-is-the-difference-between-a-buzzer-and-a-speaker-and-are-there-any-other-ba","title":"References"},{"location":"sound/02-play-tone/","text":"Play Tones Using the PWM Since we will be using the sleep function many times, we will import it by name from the Micropthon time library like this: 1 from utime import sleep Now, instead of putting utime.sleep(.5) we can just reference sleep directly like this: 1 sleep ( . 5 ) This will pause for 1/2 a second. This is how long we wait for a tone to stay on or go off. The nice thing about this menthod is that our code is a little smaller. However, you can't run other functions in the utime library. So if you want to add them later you will need to import them also, just like we did for the sleep function. Lab 1: Play A Single Tone 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # set the duty cycle to be 50% speaker . duty_u16 ( 1000 ) speaker . freq ( 1000 ) # 50% on and off sleep ( 1 ) # wait a second speaker . duty_u16 ( 0 ) # turn off the PWM circuits off with a zero duty cycle speaker . duty_u16 ( 0 ) Note The tone will keep sounding until you turn the speaker duty to 0. This shows you that the circuitry that is generating the sound is independent of the main CPU. Experiments Try changing the frequency for the first lab. This is the line speaker.freq(1000) and rerunning the program. Try using values from 10 to 10000. What values seem the loudest to your ear? What happens if you comment out the last line that sets the duty cycle to be 0? Make sure to set it back to zero again or the tone will continue playing until the device is powered off.","title":"Playing a Tone"},{"location":"sound/02-play-tone/#play-tones-using-the-pwm","text":"Since we will be using the sleep function many times, we will import it by name from the Micropthon time library like this: 1 from utime import sleep Now, instead of putting utime.sleep(.5) we can just reference sleep directly like this: 1 sleep ( . 5 ) This will pause for 1/2 a second. This is how long we wait for a tone to stay on or go off. The nice thing about this menthod is that our code is a little smaller. However, you can't run other functions in the utime library. So if you want to add them later you will need to import them also, just like we did for the sleep function.","title":"Play Tones Using the PWM"},{"location":"sound/02-play-tone/#lab-1-play-a-single-tone","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # set the duty cycle to be 50% speaker . duty_u16 ( 1000 ) speaker . freq ( 1000 ) # 50% on and off sleep ( 1 ) # wait a second speaker . duty_u16 ( 0 ) # turn off the PWM circuits off with a zero duty cycle speaker . duty_u16 ( 0 ) Note The tone will keep sounding until you turn the speaker duty to 0. This shows you that the circuitry that is generating the sound is independent of the main CPU.","title":"Lab 1: Play A Single Tone"},{"location":"sound/02-play-tone/#experiments","text":"Try changing the frequency for the first lab. This is the line speaker.freq(1000) and rerunning the program. Try using values from 10 to 10000. What values seem the loudest to your ear? What happens if you comment out the last line that sets the duty cycle to be 0? Make sure to set it back to zero again or the tone will continue playing until the device is powered off.","title":"Experiments"},{"location":"sound/03-play-three-tones/","text":"Play Three Tones In this lesson we will play three consecutive tones. Each tone will have a specific time on and we will put a time between the tones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second speaker . duty_u16 ( 0 ) sleep ( . 25 ) speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 5 ) speaker . duty_u16 ( 0 ) sleep ( . 25 ) speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 5 ) # turn off the PWM speaker . duty_u16 ( 0 ) Using Variables We can also put the time each tone stays on and the space between the tones into variables so it is easier to modify the values in a single place. 1 2 3 4 # set the time each tone will be on ONTIME = . 5 # the time between the tones OFFTIME = . 100 Three Tones With Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # the time each tone will be on ON_TIME = . 25 # the time between the tones OFF_TIME = . 1 # Low tone speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) sleep ( ON_TIME ) speaker . duty_u16 ( 0 ) sleep ( OFF_TIME ) # High tone speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( ON_TIME ) speaker . duty_u16 ( 0 ) sleep ( OFF_TIME ) # Medium tone speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( ON_TIME ) # turn off the PWM speaker . duty_u16 ( 0 ) Experiments Change the ON_TIME in the above program. What is the shortest time that you can still hear? Change the order of the Low, High, Medium around. What is the most pleasing to your ears? What order would you suggest for the start of a game and what order would you like for a \"Game Over\" sound?","title":"Playing Three Tones"},{"location":"sound/03-play-three-tones/#play-three-tones","text":"In this lesson we will play three consecutive tones. Each tone will have a specific time on and we will put a time between the tones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) # 1 Kilohertz sleep ( . 5 ) # wait a 1/4 second speaker . duty_u16 ( 0 ) sleep ( . 25 ) speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( . 5 ) speaker . duty_u16 ( 0 ) sleep ( . 25 ) speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( . 5 ) # turn off the PWM speaker . duty_u16 ( 0 )","title":"Play Three Tones"},{"location":"sound/03-play-three-tones/#using-variables","text":"We can also put the time each tone stays on and the space between the tones into variables so it is easier to modify the values in a single place. 1 2 3 4 # set the time each tone will be on ONTIME = . 5 # the time between the tones OFFTIME = . 100","title":"Using Variables"},{"location":"sound/03-play-three-tones/#three-tones-with-variables","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) # the time each tone will be on ON_TIME = . 25 # the time between the tones OFF_TIME = . 1 # Low tone speaker . duty_u16 ( 1000 ) speaker . freq ( 300 ) sleep ( ON_TIME ) speaker . duty_u16 ( 0 ) sleep ( OFF_TIME ) # High tone speaker . duty_u16 ( 1000 ) speaker . freq ( 800 ) sleep ( ON_TIME ) speaker . duty_u16 ( 0 ) sleep ( OFF_TIME ) # Medium tone speaker . duty_u16 ( 1000 ) speaker . freq ( 400 ) sleep ( ON_TIME ) # turn off the PWM speaker . duty_u16 ( 0 )","title":"Three Tones With Variables"},{"location":"sound/03-play-three-tones/#experiments","text":"Change the ON_TIME in the above program. What is the shortest time that you can still hear? Change the order of the Low, High, Medium around. What is the most pleasing to your ears? What order would you suggest for the start of a game and what order would you like for a \"Game Over\" sound?","title":"Experiments"},{"location":"sound/04-play-scale/","text":"Play a Scale In this lesson, we will learn about how to automatically generate various pitches. We will see that the spacing between lower pitches is different from the spacing between higher pitches. Here is a program that plays a scale of notes from a starting frequency of 30 hertz to an upper frequency of around 10,000 hertz. Note that 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) def playtone ( frequency ): speaker . duty_u16 ( 1000 ) speaker . freq ( frequency ) sleep ( 0.3 ) def bequiet (): speaker . duty_u16 ( 0 ) freq = 30 for i in range ( 64 ): print ( freq ) playtone ( freq ) freq = int ( freq * 1.1 ) # Turn off the PWM speaker . duty_u16 ( 0 ) New Frequency Spacing When you run the prior example, note the frequencies printed to the console. Are they evenly spaced? Take a close look at the line that creates a new frequency: 1 freq = int ( freq * 1.1 ) The effect of this line is to create a new frequency that is 10% higher than the prior frequency. Experiments What happens if you change the frequency update to be freq = freq +100","title":"Playing a Scale"},{"location":"sound/04-play-scale/#play-a-scale","text":"In this lesson, we will learn about how to automatically generate various pitches. We will see that the spacing between lower pitches is different from the spacing between higher pitches. Here is a program that plays a scale of notes from a starting frequency of 30 hertz to an upper frequency of around 10,000 hertz. Note that 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from machine import Pin , PWM from utime import sleep # lower right corner with USB connector on top SPEAKER_PIN = 16 # create a Pulse Width Modulation Object on this pin speaker = PWM ( Pin ( SPEAKER_PIN )) def playtone ( frequency ): speaker . duty_u16 ( 1000 ) speaker . freq ( frequency ) sleep ( 0.3 ) def bequiet (): speaker . duty_u16 ( 0 ) freq = 30 for i in range ( 64 ): print ( freq ) playtone ( freq ) freq = int ( freq * 1.1 ) # Turn off the PWM speaker . duty_u16 ( 0 )","title":"Play a Scale"},{"location":"sound/04-play-scale/#new-frequency-spacing","text":"When you run the prior example, note the frequencies printed to the console. Are they evenly spaced? Take a close look at the line that creates a new frequency: 1 freq = int ( freq * 1.1 ) The effect of this line is to create a new frequency that is 10% higher than the prior frequency.","title":"New Frequency Spacing"},{"location":"sound/04-play-scale/#experiments","text":"What happens if you change the frequency update to be freq = freq +100","title":"Experiments"},{"location":"sound/05-play-mario/","text":"Play Mario on MicroPython ```py from machine import Pin, PWM from utime import sleep buzzer = PWM(Pin(16)) tones = { \"B0\": 31,\"C1\": 33,\"CS1\": 35,\"D1\": 37,\"DS1\": 39,\"E1\": 41,\"F1\": 44,\"FS1\": 46, \"G1\": 49,\"GS1\": 52,\"A1\": 55,\"AS1\": 58,\"B1\": 62,\"C2\": 65, \"CS2\": 69,\"D2\": 73,\"DS2\": 78,\"E2\": 82,\"F2\": 87,\"FS2\": 93,\"G2\": 98, \"GS2\": 104,\"A2\": 110,\"AS2\": 117,\"B2\": 123,\"C3\": 131,\"CS3\": 139, \"D3\": 147,\"DS3\": 156,\"E3\": 165,\"F3\": 175,\"FS3\": 185, \"G3\": 196,\"GS3\": 208,\"A3\": 220,\"AS3\": 233,\"B3\": 247,\"C4\": 262,\"CS4\": 277,\"D4\": 294,\"DS4\": 311, \"E4\": 330,\"F4\": 349,\"FS4\": 370,\"G4\": 392,\"GS4\": 415,\"A4\": 440,\"AS4\": 466,\"B4\": 494,\"C5\": 523,\"CS5\": 554,\"D5\": 587,\"DS5\": 622,\"E5\": 659,\"F5\": 698, \"FS5\": 740,\"G5\": 784,\"GS5\": 831,\"A5\": 880,\"AS5\": 932,\"B5\": 988,\"C6\": 1047,\"CS6\": 1109,\"D6\": 1175,\"DS6\": 1245,\"E6\": 1319,\"F6\": 1397,\"FS6\": 1480,\"G6\": 1568,\"GS6\": 1661, \"A6\": 1760,\"AS6\": 1865,\"B6\": 1976,\"C7\": 2093,\"CS7\": 2217,\"D7\": 2349,\"DS7\": 2489,\"E7\": 2637,\"F7\": 2794,\"FS7\": 2960,\"G7\": 3136,\"GS7\": 3322,\"A7\": 3520, \"AS7\": 3729,\"B7\": 3951,\"C8\": 4186,\"CS8\": 4435,\"D8\": 4699,\"DS8\": 4978 } song = [\"E5\",\"G5\",\"A5\",\"P\",\"E5\",\"G5\",\"B5\",\"A5\",\"P\",\"E5\",\"G5\",\"A5\",\"P\",\"G5\",\"E5\"] mario = [\"E7\", \"E7\", 0, \"E7\", 0, \"C7\", \"E7\", 0, \"G7\", 0, 0, 0, \"G6\", 0, 0, 0, \"C7\", 0, 0, \"G6\", 0, 0, \"E6\", 0, 0, \"A6\", 0, \"B6\", 0, \"AS6\", \"A6\", 0, \"G6\", \"E7\", 0, \"G7\", \"A7\", 0, \"F7\", \"G7\", 0, \"E7\", 0,\"C7\", \"D7\", \"B6\", 0, 0, \"C7\", 0, 0, \"G6\", 0, 0, \"E6\", 0, 0, \"A6\", 0, \"B6\", 0, \"AS6\", \"A6\", 0, \"G6\", \"E7\", 0, \"G7\", \"A7\", 0, \"F7\", \"G7\", 0, \"E7\", 0,\"C7\", \"D7\", \"B6\", 0, 0] def playtone(frequency): buzzer.duty_u16(1000) buzzer.freq(frequency) def bequiet(): buzzer.duty_u16(0) def playsong(mysong): for i in range(len(mysong)): if (mysong[i] == \"P\" or mysong[i] == 0 ): bequiet() else: playtone(tones[mysong[i]]) sleep(0.3) bequiet() playsong(mario) 1 ```","title":"Play Mario"},{"location":"sound/05-play-mario/#play-mario-on-micropython","text":"```py from machine import Pin, PWM from utime import sleep buzzer = PWM(Pin(16)) tones = { \"B0\": 31,\"C1\": 33,\"CS1\": 35,\"D1\": 37,\"DS1\": 39,\"E1\": 41,\"F1\": 44,\"FS1\": 46, \"G1\": 49,\"GS1\": 52,\"A1\": 55,\"AS1\": 58,\"B1\": 62,\"C2\": 65, \"CS2\": 69,\"D2\": 73,\"DS2\": 78,\"E2\": 82,\"F2\": 87,\"FS2\": 93,\"G2\": 98, \"GS2\": 104,\"A2\": 110,\"AS2\": 117,\"B2\": 123,\"C3\": 131,\"CS3\": 139, \"D3\": 147,\"DS3\": 156,\"E3\": 165,\"F3\": 175,\"FS3\": 185, \"G3\": 196,\"GS3\": 208,\"A3\": 220,\"AS3\": 233,\"B3\": 247,\"C4\": 262,\"CS4\": 277,\"D4\": 294,\"DS4\": 311, \"E4\": 330,\"F4\": 349,\"FS4\": 370,\"G4\": 392,\"GS4\": 415,\"A4\": 440,\"AS4\": 466,\"B4\": 494,\"C5\": 523,\"CS5\": 554,\"D5\": 587,\"DS5\": 622,\"E5\": 659,\"F5\": 698, \"FS5\": 740,\"G5\": 784,\"GS5\": 831,\"A5\": 880,\"AS5\": 932,\"B5\": 988,\"C6\": 1047,\"CS6\": 1109,\"D6\": 1175,\"DS6\": 1245,\"E6\": 1319,\"F6\": 1397,\"FS6\": 1480,\"G6\": 1568,\"GS6\": 1661, \"A6\": 1760,\"AS6\": 1865,\"B6\": 1976,\"C7\": 2093,\"CS7\": 2217,\"D7\": 2349,\"DS7\": 2489,\"E7\": 2637,\"F7\": 2794,\"FS7\": 2960,\"G7\": 3136,\"GS7\": 3322,\"A7\": 3520, \"AS7\": 3729,\"B7\": 3951,\"C8\": 4186,\"CS8\": 4435,\"D8\": 4699,\"DS8\": 4978 } song = [\"E5\",\"G5\",\"A5\",\"P\",\"E5\",\"G5\",\"B5\",\"A5\",\"P\",\"E5\",\"G5\",\"A5\",\"P\",\"G5\",\"E5\"] mario = [\"E7\", \"E7\", 0, \"E7\", 0, \"C7\", \"E7\", 0, \"G7\", 0, 0, 0, \"G6\", 0, 0, 0, \"C7\", 0, 0, \"G6\", 0, 0, \"E6\", 0, 0, \"A6\", 0, \"B6\", 0, \"AS6\", \"A6\", 0, \"G6\", \"E7\", 0, \"G7\", \"A7\", 0, \"F7\", \"G7\", 0, \"E7\", 0,\"C7\", \"D7\", \"B6\", 0, 0, \"C7\", 0, 0, \"G6\", 0, 0, \"E6\", 0, 0, \"A6\", 0, \"B6\", 0, \"AS6\", \"A6\", 0, \"G6\", \"E7\", 0, \"G7\", \"A7\", 0, \"F7\", \"G7\", 0, \"E7\", 0,\"C7\", \"D7\", \"B6\", 0, 0] def playtone(frequency): buzzer.duty_u16(1000) buzzer.freq(frequency) def bequiet(): buzzer.duty_u16(0) def playsong(mysong): for i in range(len(mysong)): if (mysong[i] == \"P\" or mysong[i] == 0 ): bequiet() else: playtone(tones[mysong[i]]) sleep(0.3) bequiet() playsong(mario) 1 ```","title":"Play Mario on MicroPython"}]}